<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="战战兢兢，如履薄冰">
<meta property="og:type" content="website">
<meta property="og:title" content="wnyxvo的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="wnyxvo的博客">
<meta property="og:description" content="战战兢兢，如履薄冰">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wnyxvo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>wnyxvo的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wnyxvo的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">15</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/09/6-S081-Leature-6-Trap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/09/6-S081-Leature-6-Trap/" class="post-title-link" itemprop="url">6.S081-Leature 6 Trap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-09 11:07:41" itemprop="dateCreated datePublished" datetime="2025-01-09T11:07:41+08:00">2025-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-14 17:32:55" itemprop="dateModified" datetime="2025-01-14T17:32:55+08:00">2025-01-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有三种事件会导致CPU暂停当前普通指令的执行，强制将控制权转移给处理该事件的特殊代码。</p>
<ul>
<li>系统调用 syscall：用户程序执行 <strong>ecall</strong> 指令要求内核为其做某事时。</li>
<li>指令异常 exception：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址。</li>
<li>设备中断 interrupt：外部设备发出请求信号，例如当磁盘硬件完成一个读写请求时。</li>
</ul>
<p>前两种来自 CPU 内部（同步），第三种来自 CPU 外部的 I&#x2F;O 设备（异步）。在本课程中这三者统称为<strong>trap</strong>。</p>
<p>trap的执行对当前正常指令流是透明的。通常的顺序是：</p>
<ul>
<li><p>trap迫使控制权转移到内核；</p>
</li>
<li><p>内核保存寄存器和其他状态，以便恢复执行；</p>
</li>
<li><p>内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；</p>
</li>
<li><p>内核恢复保存的状态，并从trap中返回；</p>
</li>
<li><p>代码从原来的地方恢复执行。</p>
</li>
</ul>
<p>Xv6 trap 处理分为四个阶段：</p>
<ul>
<li><p>RISC-V CPU采取的硬件行为，</p>
</li>
<li><p>为内核C代码准备入口的汇编程序，如<code>trampoline.S</code> 中的uservec</p>
</li>
<li><p>处理trap的C 处理程序，</p>
</li>
<li><p>系统调用处理或设备驱动服务。</p>
</li>
</ul>
<h2 id="RISC-V-trap-machinery"><a href="#RISC-V-trap-machinery" class="headerlink" title="RISC-V trap machinery"></a>RISC-V trap machinery</h2><p>每个RISC-V CPU都有一组控制寄存器，当系统发生一个陷阱（trap）时，这些寄存器会被使用或修改以处理 trap。</p>
<p>可能会用到的特权寄存器：</p>
<ol>
<li><p><code>sepc</code> (Supervisor Exception Program Counter)</p>
<ul>
<li>保存发生 trap 时的程序计数器（PC），在 trap 处理完成后，<code>sepc</code> 的值通常用于恢复到 trap 发生的地方继续执行。</li>
<li>当 trap 发生时，硬件会自动将当前 PC 的值保存到 <code>sepc</code>。</li>
<li><code>sret</code>（从trap中返回）指令将<code>sepc</code>复制到<code>pc</code>中。内核可以写<code>sepc</code>来控制<code>sret</code>的返回到哪里。</li>
</ul>
</li>
<li><p><code>stvec</code>(Supervisor Trap Vector Register)</p>
<ul>
<li>内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。</li>
</ul>
</li>
<li><p><code>scause</code>(Supervisor Cause Register)</p>
<ul>
<li>保存导致陷阱的原因</li>
</ul>
</li>
<li><p><code>sstatus</code> (Supervisor Status Register)</p>
<ul>
<li>保存陷阱发生时的系统状态，例如中断使能位。</li>
</ul>
</li>
<li><p><code>satp</code> (Supervisor Address Translation and Protection Register)</p>
<ul>
<li>保存根页表的地址</li>
</ul>
</li>
<li><p><code>SSRATCH</code>(Supervisor Scratch Register)</p>
<ul>
<li><p>是一个通用寄存器，没有固定用途</p>
</li>
<li><p>保存操作系统在进入中断或异常处理前需要暂存的值。</p>
</li>
</ul>
</li>
</ol>
<p>当需要执行trap时，<strong>RISC-V 硬件</strong>对所有的trap类型（除定时器中断外）进行以下操作：</p>
<ol>
<li>如果该trap是设备中断，且<code>sstatus</code> <strong>SIE</strong>位为0，则不执行以下任何操作。</li>
<li>通过清除SIE来禁用中断。</li>
<li>复制<code>pc</code>到<code>sepc</code>。</li>
<li>将当前模式（用户态或特权态）保存在<code>sstatus</code>的<strong>SPP</strong>位。</li>
<li>在<code>scause</code>设置该次trap的原因。</li>
<li>将模式转换为特权态。</li>
<li>将<code>stvec</code>复制到<code>pc</code>。</li>
<li>从新的<code>pc</code>开始执行。</li>
</ol>
<p>切换为 supervisor mode 后可以读写上述的特权寄存器和可以使用 PTE_U 标志位为 0 的PTE。supervisor mode 中的代码并不能读写任意物理地址。在supervisor mode中，就像普通的用户代码一样，也需要通过page table来访问内存，受限于当前页表设置的虚拟地址。。</p>
<h2 id="Trap-代码执行流程"><a href="#Trap-代码执行流程" class="headerlink" title="Trap 代码执行流程"></a>Trap 代码执行流程</h2><p>下面以 shell 中调用 write 系统调用为例子说明 trao 代码的执行流程。</p>
<p>从Shell的角度来说，write 就是个Shell代码中的C函数调用，但是实际上，write 通过执行ECALL指令来执行系统调用。ECALL指令会切换到具有supervisor mode的内核中。在这个过程中，内核中执行的第一个指令是一个由汇编语言写的函数，叫做<code>uservec</code>。这个函数是内核代码<code>trampoline.s</code>文件的一部分。所以执行的第一个代码就是这个uservec汇编函数。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_trap_flow.png" alt="trap_flow"></p>
<h2 id="ECALL-指令执行之前的状态"><a href="#ECALL-指令执行之前的状态" class="headerlink" title="ECALL 指令执行之前的状态"></a>ECALL 指令执行之前的状态</h2><p><code>sh.c</code>中的 getcmd() 调用了 fprintf() ，fprintf()封装了 write 库函数。可以在 <code>usys.S</code>（由 usys.pl 生成）在查看这个库函数的源代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>首先将系统调用号<code>SYS_write</code>加载到 a7 寄存器，再执行<code>ecall</code>指令，从这里开始代码执行跳转到了内核。内核完成它的工作之后，代码执行会返回到用户空间，继续执行<code>ecall</code>之后的指令<code>ret</code>，最终返回到Shell中。</p>
<p>为了在<code>ecall</code>指令处放置一个断点，可以通过查看由编译过程产生的<code>sh.asm</code>找出这个地址。这里的地址是 <code>0xde4</code>。打好断点，执行，如下图。还可以查看当前寄存器中的值。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb1.jpg"></p>
<p>这里的a0，a1，a2是Shell传递给write系统调用的参数。所以a0是文件描述符2；a1是Shell想要写入字符串的指针；a2是想要写入的字符数。查看<code>stvec</code>中的值，执行<code>ecall</code>后会跳转到这里。</p>
<p>使用 gdb-multiarch 调试，<code>si</code>后无法追踪<code>ecall</code>，而是直接到了<code>ret</code>。所以需要手动打断点，跳转到<code>03ffffff000</code>。另若不在 ecall 后追踪 03ffffff000 而是进入gdb后直接打断点，程序停止运行的 03ffffff000 不是我们所需要的。</p>
<p>从QEMU界面，输入<code>ctrl a + c</code>可以进入到QEMU的console，之后输入<em>info mem</em>，QEMU会打印完整的page table。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_mem1.jpg"></p>
<p>当前的地址属于第一条PTE指向的空间，且这条PTE用户空间可访问，可见当前是在用户态。最后两条PTE的虚拟地址非常大，非常接近虚拟地址的顶端，这两个page分别是trapframe page和trampoline page。它们都没有设置 u 标志，所以用户代码不能访问这两条PTE。一旦我们进入到了supervisor mode，就可以访问这两条PTE了。</p>
<p>即使trampoline page是在用户地址空间的user page table完成的映射，但用户代码不能写它，因为这些page对应的PTE并没有设置PTE_u标志位。这也是为什么trap机制是安全的。</p>
<h2 id="ECALL-指令执行之后的状态"><a href="#ECALL-指令执行之后的状态" class="headerlink" title="ECALL 指令执行之后的状态"></a>ECALL 指令执行之后的状态</h2><p>现在已经到了<code>uservec</code>处，再次打印页表，发现<strong>页表并没有改变</strong>。而且当前的地址属于最后一条PTE指向的空间<code>trampoline</code>，这里没有设置 u 标志。可以访问且程序没有崩溃，说明此时已不是用户态了。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb2.jpg"></p>
<p>查看寄存器，值也没有改变，这里还是用户程序拥有的一些寄存器内容。接下<code>uservec</code>中的代码就是要保存寄存器中的值。</p>
<p>ecall实际上只会改变三件事情：</p>
<ul>
<li>user mode 改到 supervisor mode</li>
<li>将 PC 的值保存在了<code>SEPC</code>寄存器</li>
<li>跳转到 <code>STVEC</code> 寄存器指向的指令</li>
</ul>
<p>RISC-V秉持了这样一个观点：<code>ecal</code>l只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这样能为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。</p>
<h2 id="uservec-函数"><a href="#uservec-函数" class="headerlink" title="uservec 函数"></a>uservec 函数</h2><p>现在程序位于trampoline page的起始，也是uservec函数的起始。现在要做的第一件事情就是保存寄存器的内容。在RISC-V中，supervisor mode下的代码不允许直接访问物理内存。所以只能使用page table中的内容。</p>
<p>对于保存用户寄存器，XV6在RISC-V上的实现包括了两个部分:</p>
<ol>
<li><p>XV6在每个user page table映射了trapframe page，这样每个进程都有自己的trapframe page。这个page中放置了<code>trapframe</code>结构体（定义在<code>proc.h</code>），有用来保存用户寄存器的32个空槽位和5个特殊用途槽位（对应了特殊的寄存器）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>比如第一个数据保存了kernel page table地址，这将会是trap处理代码将要加载到<code>SATP</code>寄存器的数值。这些值的设置在<code>usertrapret</code>函数中。</p>
</li>
<li><p><code>SSCRATCH</code>寄存器。它在这里的作用就是保存另一个寄存器的值，并将自己的值加载给另一个寄存器。RISC-V有一个指令<code>csrrw</code>允许交换任意两个寄存器的值。</p>
<p><code>csrrw</code>指令执行前，<code>SSCRATCH</code>寄存器中保存trapframe page的起始地址，a0寄存器保存的是write函数的第一个参数。这里换值，是为了下面使用a0寄存器而又要保存原值。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb3.jpg"></p>
</li>
</ol>
<p><strong>当与 a0 寄存器进行交换时，trapframe page的地址是怎么出现在<code>SSCRATCH</code>寄存器中的？</strong></p>
<p>​	在内核<strong>上一次</strong>切换回用户空间时，内核会执行set sscratch指令，将这个寄存器的内容设置为0x3fffffe000，也就是trapframe page的虚拟地址。具体来说就是，在 <code>trampoline.S</code> 的 <code>userret</code> 的最后两行，也是内核返回到用户空间前的最后两行代码。内核已经提前设置了a0保存的是trapframe地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line"># return to user mode and user pc.</span><br><span class="line"># usertrapret() set up sstatus and sepc.</span><br><span class="line">sret</span><br></pre></td></tr></table></figure>

<p><strong>那 a0 是如何有trapframe page的地址？（有点套娃）</strong></p>
<p>​	无论是内核启动后第一次切换到用户空间，还是 trap 完成后返回到用户空间，都要执行<code>sret</code> 流程。在 xv6 中，<code>sret</code> 被封装在 <code>trampoline.S</code> 的 <code>userret</code> 函数中。大概流程：</p>
<ul>
<li>要切换到用户空间时，调用<code>trap.c/usertrapret()</code>。详见下文。</li>
<li><code>usertrapret()</code>再调用 <code>trampoline.S</code> 中的 <code>userret</code> 函数，并为<code>userret</code> 设置参数TRAPFRAME, satp。调用函数时，第一个参数<code>TRAPFRAME</code>当然会存在a0中。也就是说哪怕在处理 trap 时使用的 a0 寄存器也是ok的（a0 在开始时存放了trapframe page的地址），内核会再次设置。</li>
</ul>
<hr>
<p><code>csrrw</code>指令后，a0 中就是trapframe page地址了。接下就是将寄存器中的值保存到trapframe 。</p>
<p>然后开始将 trapframe 中提前设置好的5个特殊值写入寄存器中。首先是加载进程的kernel stack pointer到 sp 寄存器。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb4.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Virtual Address Space:</span><br><span class="line"><span class="number">0x3ffffff000</span> - TRAMPOLINE (trampoline code)</span><br><span class="line"><span class="number">0x3fffffe000</span> - TRAPFRAME (trapframe <span class="keyword">struct</span>)</span><br><span class="line"><span class="number">0x3fffffd000</span> - Guard <span class="title function_">Page</span> <span class="params">(unmapped, invalid access)</span></span><br><span class="line">0x3fffffc000 - Kernel <span class="title function_">Stack</span> <span class="params">(<span class="keyword">for</span> process <span class="number">0</span>)</span></span><br><span class="line">0x3fffffb000 - Guard <span class="title function_">Page</span> <span class="params">(unmapped, invalid access)</span></span><br><span class="line">0x3fffffa000 - Kernel <span class="title function_">Stack</span> <span class="params">(<span class="keyword">for</span> process <span class="number">1</span>)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下一条指令是向 tp 寄存器写入处理器编号。make 时配置了单核运行，所以只能运行在核0上。</p>
<p>下一条指令是向 t0 寄存器写入函数<code>usertrap</code>的指针，这是将要执行的第一个C函数的指针。</p>
<p>下一条指令是向 t1 寄存器写入kernel page table的地址；接下来交换<code>SATP</code>和t1寄存器。这条指令执行完成之后，当前程序会从user page table切换到kernel page table。在QEMU中打印page table，可以看出与之前的page table不一样了。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb5.jpg"></p>
<p>trampoline 代码在用户空间和内核空间都映射到了同一个地址，所以即使是切换了页表程序仍能运行。至于前面加载的几个值，本来就是内核空间中的地址。</p>
<p>最后一条指令是 <em>jr t0</em>。执行了这条指令，就从 trampoline 跳到内核的C代码中。</p>
<h2 id="usertrap-函数"><a href="#usertrap-函数" class="headerlink" title="usertrap 函数"></a>usertrap 函数</h2><p><code>usertrap</code>函数是位于<code>trap.c</code>文件的一个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>更换中断向量表。当前已经处于内核空间中，此时若发生 trap ，处理方式与处于用户空间不同。</li>
<li>要获取当前进程，因为处于用户空间的参数等数据已被拷贝到 trapframe 中，需要通过proc 来获取。</li>
<li>要保存用户程序计数器，它仍然保存在<code>SEPC</code>寄存器中。因为当程序还在内核中执行时，可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致<code>SEPC</code>寄存器的内容被覆盖。</li>
<li><code>SCAUSE</code>寄存器会根据 trap 的类型不同而设置不同的值，需要据此了解当前 trap 的类型，进而进行不同的处理。</li>
<li><code> p-&gt;trapframe-&gt;epc += 4</code>，因为之前保存的用户 pc 是发生 ecall 指令的地址，返回用户态要执行的是下一条指令。</li>
<li>设置<code>SSTATUS_SIE</code>，Supervisor Interrupt Enable。XV6会在处理系统调用的时候使能中断，这样可以更快地处理中断，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，需要显式的打开中断。</li>
<li>系统调用的核心逻辑由 <code>syscall()</code> 处理，而 <code>usertrap</code> 仅负责识别和转发。</li>
<li>syscall() 中会将系统调用返回值写入<code>trapframe-&gt;a0</code>，当返回到用户空间，trapframe中的 a0 槽位的数值会写到实际的 a0 寄存器。</li>
</ol>
<h2 id="usertrapret-函数"><a href="#usertrapret-函数" class="headerlink" title="usertrapret 函数"></a>usertrapret 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将要返回用户态了，关闭<code>SSTATUS_SIE</code>。 </p>
</li>
<li><p>更换中断向量表，将要返回用户空间了。<code>TRAMPOLINE + (uservec - trampoline)</code> 为什么这么写？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># MAXVA:  MAXVA is actually one bit less than the max allowed by Sv39</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>w_stvec</code>的参数必须是物理地址。</li>
<li><code>TRAMPOLINE </code>是trapframe page的固定虚拟地址，但是映射到物理空间的也是这个地址。</li>
<li><code>uservec - trampoline</code>计算的是绝对偏移量，这样写也便于维护。</li>
</ul>
</li>
<li><p>设置进程的内核栈，<code>p-&gt;kstack</code> 是进程分配到的进程栈的栈底（低地址），<code>p-&gt;kstack + PGSIZE</code>才是栈顶。</p>
</li>
<li><p><code>SSTATUS_SPIE</code> 是 Supervisor Previous Interrupt Enable 位，也在 <code>sstatus</code> 寄存器中。它保存了<strong>上一个模式</strong>的中断使能状态。在异常或系统调用发生时，<code>SPIE</code> 的值 硬件自动保存到 <code>SSTATUS</code> 寄存器中。</p>
</li>
<li><p><code>((void (*)(uint64,uint64))fn)(TRAPFRAME, satp)</code>调用<code>userret</code>函数，并为其准备了参数。</p>
</li>
</ol>
<h2 id="userret-函数"><a href="#userret-函数" class="headerlink" title="userret 函数"></a>userret 函数</h2><p>现在程序执行又到了<code>trampoline.S</code>。<strong>到这里，<code>a0</code>寄存器中放置的是 trapframe page 地址。</strong>其中多次用到了<code>t0</code>寄存器，因为有些指令的操作数只能是寄存器。</p>
<ol>
<li>切换回用户页表。user page table 在<code>usertrapret</code>中作为第二个参数传递给了这里的<code>userret</code>函数，所以存在a1寄存器中。</li>
<li>恢复用户寄存器。<code>trapframe-&gt;a0</code>槽位的值作为返回值写入<code>ra</code>寄存器。</li>
<li>将 trap 前的 a0 寄存器中的值（一直保存在 trapframe中）写入 <code>SSCRATCH</code>，交换<code>SSCRATCH</code>和<code>a0</code>中的值。</li>
<li><code>SRET</code>。具体作用：<ul>
<li>根据 <code>SSTATUS.SPP</code> 位决定返回的模式</li>
<li>跳转到 <code>sepc</code> 中保存的地址</li>
<li>根据 <code>SSTATUS.SPIE</code> 位，恢复之前的中断状态</li>
</ul>
</li>
</ol>
<h2 id="Code-System-call-arguments"><a href="#Code-System-call-arguments" class="headerlink" title="Code: System call arguments"></a>Code: System call arguments</h2><ol>
<li><p>内核的系统调用实现需要找到用户代码传递的参数。</p>
<ul>
<li>用户代码调用系统调用的包装函数，参数首先会存放在寄存器a0、a1…中，<code>trampoline.S</code>将用户寄存器中的值保存到当前进程的trapframe中。函数<code>argint</code>、<code>argaddr</code>和<code>argfd</code>从trap rame中以整数、指针或文件描述符的形式检索第n个系统调用参数。</li>
<li>一些系统调用传递指针作为参数，而内核必须使用这些指针来读取或写入用户内存。但是这些地址可能是恶意的，况且内核页表映射与用户页表映射不一样，所以内核不能使用普通指令从用户提供的地址加载或存储。</li>
</ul>
</li>
<li><p>内核需要将数据复制到到用户提供的地址，例如系统调用需要将结果保存到提供的结构体中。</p>
<ul>
<li><code>fetchstr</code>（kernel&#x2F;syscall.c）</li>
<li><code>copyinstr</code>（kernel&#x2F;vm.c）</li>
<li><code>copyout</code>（kernel&#x2F;vm.c）</li>
</ul>
</li>
</ol>
<h2 id="Traps-from-kernel-space"><a href="#Traps-from-kernel-space" class="headerlink" title="Traps from kernel space"></a>Traps from kernel space</h2><p>Xv6 会根据当前是在用户空间还是内核空间，对<code>stvec</code>寄存器的配置略有不同行为。当处于内核空间时，<code>stvec</code>指向<code>kernelvec</code>上的汇编代码（kernel&#x2F;kernelvec.S）。由于xv6已经在内核中，<code>kernelvec</code>使用内核页表和内核的堆栈指针。</p>
<p><code>kernelvec</code>首先将所有寄存器保存到（被 trap 的）内核栈中，随后跳转到<code>kerneltrap</code>。</p>
<ol>
<li>要保存 trap 发生时的 <code>sepc</code>、<code>sstatus</code> 。因为当前 trao 若是定时器中断，当前进程会放弃 CPU， <code>sepc</code>、<code>sstatus</code>会被覆盖。</li>
<li>同样根据<code>scause</code> 中断号进行不同的处理。主要还是分为设备中断、定时器中断。</li>
<li>当<code>kerneltrap</code>的工作完成时，它需要返回到被中断的代码。也就需要恢复<code>sepc</code>、<code>sstatus</code> 。</li>
</ol>
<p><code>kerneltrap</code>执行完成后，<code>kernelvec</code>从栈中恢复保存的寄存器并执行<code>sret</code>，<code>sret</code>将<code>sepc</code>复制到<code>pc</code>并恢复中断的内核代码。</p>
<p>另，当CPU从用户空间进入内核时，Xv6将CPU的<code>stvec</code>设置为<code>kernelvec</code>的操作并不是首先执行的。内核空间一开始有段运行时间中<code>stvec</code>被设置为<code>uservec</code>，所以在这个窗口期，禁用设备中断是至关重要的。<strong>RISC-V总是在开始使用 trap 时禁用中断</strong>，xv6在设置<code>stvec</code>之前不会再次启用它们。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/29/LKD3-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/29/LKD3-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">LKD3-进程管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-29 23:49:26" itemprop="dateCreated datePublished" datetime="2024-08-29T23:49:26+08:00">2024-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-31 01:04:05" itemprop="dateModified" datetime="2024-08-31T01:04:05+08:00">2024-08-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><p>内核把进程的列表存放在任务队列中（task list）。链表中的每一项都是类型为<code>task_struct</code>的结构，被称为进程描述符（process descriptor）。该结构体定义在<code>include/linux/sched.h/line1172</code>，大约400行。它包含了进程管理中所需的所有信息，如进程状态、进程标识符 (PID)、调度信息、内存管理信息、打开的文件等。<code>task_struct</code> 在进程控制块 (PCB) 中扮演了关键角色，操作系统通过它来管理进程。</p>
<h3 id="分配进程描述符"><a href="#分配进程描述符" class="headerlink" title="分配进程描述符"></a>分配进程描述符</h3><p>2.6以后的内核使用<code>slab</code>分配器动态生成<code>task_struct</code> ，并在栈底创建一个新的结构体<code>thread_info</code>，可以称为线程描述符。<code>thread_info</code> 保存了指向 <code>task_struct</code> 的指针，并且保存了一些与线程执行状态有关的低级别信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/asm/thread_info.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>	*<span class="title">exec_domain</span>;</span>	<span class="comment">/* execution domain */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="type">int</span>			preempt_count;	<span class="comment">/* 0 =&gt; preemptable,</span></span><br><span class="line"><span class="comment">						          &lt;0 =&gt; BUG */</span></span><br><span class="line">	<span class="type">mm_segment_t</span>		addr_limit;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>    <span class="title">restart_block</span>;</span></span><br><span class="line">	<span class="type">void</span> __user		*sysenter_return;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>           previous_esp;   <span class="comment">/* ESP of the previous stack in</span></span><br><span class="line"><span class="comment">						   case of nested (IRQ) stacks */</span></span><br><span class="line">	__u8			supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span>			uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>task</strong>: 指向与该线程相关的主 <code>task_struct</code> 结构体。<code>task_struct</code> 是进程&#x2F;线程的主要描述符，而 <code>thread_info</code> 主要存储的是与特定线程的执行环境相关的低级信息。</li>
<li><strong>exec_domain</strong>: 指向线程的执行域结构体，执行域决定了线程运行的上下文，特别是在跨平台内核中，这个域可以包含与线程执行相关的特定信息。</li>
<li><strong>flags</strong>: 低级别的标志位，用于记录线程的各种状态和属性。这些标志位可以用于表示线程的某些特定状态，例如是否正在调试中，是否已被杀死等。</li>
</ul>
<ul>
<li><strong>status</strong>: 线程的同步标志，主要用于管理线程的同步状态，例如阻塞、挂起等。</li>
<li><strong>cpu</strong>: 当前线程正在运行的处理器编号。该字段在多核系统中特别重要，指示线程当前在哪个 CPU 核上执行。</li>
<li><strong>preempt_count</strong>: 用于管理线程的抢占计数器。<code>0</code> 表示线程是可抢占的，如果该值为负数，则意味着发生了错误。</li>
<li><strong>addr_limit</strong>: 线程的地址限制，用于定义线程能够访问的内存区域。通常用于区分用户态和内核态的地址空间。</li>
<li><strong>restart_block</strong>: 线程重启块，用于处理系统调用在某些情况下（例如被信号中断）需要重新启动的情况。</li>
<li><strong>sysenter_return</strong>: 指向用户态返回地址，用于 <code>sysenter</code> 系统调用快速路径的返回处理。</li>
<li><strong>previous_esp</strong> (仅在 <code>CONFIG_X86_32</code> 配置下有效): 保存之前栈的 ESP 值，用于嵌套（例如 IRQ）栈的情况。</li>
<li><strong>supervisor_stack</strong> (仅在 <code>CONFIG_X86_32</code> 配置下有效): 用于保存管理栈的值。</li>
<li><strong>uaccess_err</strong>: 记录用户态访问错误，用于在执行用户空间内存访问时检测并处理潜在的错误。</li>
</ul>
<p>对每个进程来说，Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的存储区间中：一个内核态的进程堆栈、另一个就是<code>thread_info</code>。这块区域的大小通常为8192B（2个连续的页），并且第一个页框的起始地址为2^13的倍数。<code>thread_info</code>结构时52个字节长，所以内核栈能扩展到8140字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">thread_union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">stack</span>[<span class="number">2048</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取进程描述符"><a href="#获取进程描述符" class="headerlink" title="获取进程描述符"></a>获取进程描述符</h3><p>内核很容易利用<code>esp</code>寄存器（存放栈指针）的值获取当前CPU上运行的进程的<code>thread_info</code>结构的地址。因为<code>thread_union</code>的长度为8K，且起始地址是2^13的倍数，所以清除<code>esp</code>的低13位后就可得到<code>thread_union</code>的基地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/asm/thread_info.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title function_">current_thread_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)</span><br><span class="line">		(current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>current_thread_info()-&gt;task</code>即可获得当前进程的<code>task_struct</code> 地址。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在 Linux 内核中，进程（<code>task_struct</code>）具有多种状态，用于表示进程当前的活动情况。这些状态定义在 <code>include/linux/sched.h</code> 文件中，并且通过不同的状态值来描述进程的不同执行情况。</p>
<ul>
<li><p>TASK_RUNNING（运行状态）：进程处于可执行状态，表示该进程正在运行或在就绪队列中等待 CPU 时间片。当 CPU 分配给该进程时，它将进入运行状态。</p>
</li>
<li><p>TASK_INTERRUPTIBLE（可中断的睡眠状态）：进程正在等待某个事件（例如 I&#x2F;O 操作完成），并且在等待期间可以被信号中断。如果进程收到信号，它将从睡眠状态唤醒，并处理信号。</p>
</li>
<li><p>TASK_UNINTERRUPTIBLE（不可中断的睡眠状态）：进程也在等待某个事件，但此状态下它不会响应任何信号，也不会被中断，直到等待的事件发生。例如，等待磁盘 I&#x2F;O 完成时，进程可能进入不可中断的睡眠状态。</p>
</li>
<li><p>TASK_STOPPED（停止状态）：进程已停止运行，通常是因为收到了 <code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code> 或 <code>SIGTTOU</code> 等信号。此时进程不会被调度执行，直到收到继续运行的信号（例如 <code>SIGCONT</code>）。</p>
</li>
<li><p>TASK_TRACED（跟踪状态）：进程处于被跟踪状态，通常是因为调试器（例如 <code>gdb</code>）正在跟踪该进程。当一个进程处于跟踪状态时，它不会被调度执行，除非被调试器释放。</p>
</li>
<li><p>EXIT_DEAD（僵尸进程状态）：进程的执行已经终止，所有资源已经被释放，但其父进程还没有通过 <code>wait()</code> 系列系统调用获取子进程的终止状态，导致进程仍然保留在进程表中。这种状态称为僵尸进程（Zombie）。</p>
</li>
<li><p>EXIT_ZOMBIE（僵尸状态）：进程已经终止，内核已经释放了该进程的大部分资源，但仍保留了一些信息以供父进程查询。这些信息会在父进程调用 <code>wait()</code> 后完全释放。</p>
</li>
<li><p>TASK_DEAD（死亡状态）：进程的所有资源都已经释放，进程完全终止。此状态意味着进程已不再存在。</p>
</li>
<li><p>TASK_WAKEKILL（可唤醒状态）：这是一个标志位，表示进程在 <code>TASK_INTERRUPTIBLE</code> 或 <code>TASK_UNINTERRUPTIBLE</code> 状态下，可以被唤醒并被信号杀死。</p>
</li>
<li><p>TASK_WAKING（唤醒中状态）：进程正在从睡眠状态转变为可运行状态，但尚未实际进入 <code>TASK_RUNNING</code> 状态。这是一个过渡状态，表示进程即将被调度器重新调度执行。</p>
</li>
<li><p>TASK_PARKED（暂停状态）：这个状态表示进程被暂停调度，一般与 CPU 热插拔或一些特殊的调度需求相关联。</p>
</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/21/6-S081-Leature-5-Calling-conventions-and-stack-frames/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/21/6-S081-Leature-5-Calling-conventions-and-stack-frames/" class="post-title-link" itemprop="url">6.S081-Leature 5 Calling conventions and stack frames</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-21 00:07:02" itemprop="dateCreated datePublished" datetime="2024-08-21T00:07:02+08:00">2024-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-09 11:08:45" itemprop="dateModified" datetime="2025-01-09T11:08:45+08:00">2025-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RISC-V-vs-x86"><a href="#RISC-V-vs-x86" class="headerlink" title="RISC-V vs x86"></a>RISC-V vs x86</h2><p>RISC-V：一种精简指令集（Reduced Instruction Set Computer）。</p>
<p>RISC-V区分了 Base Integer Instruction Set 和 Standard Extension Instruction Set。Base Integer Instruction Set 包含了所有的常用指令，比如add，mult。除此之外，处理器还可以选择性的支持 Standard Extension Instruction Set。每一个RISC-V处理器可以声明支持了哪些扩展指令集，然后编译器可以根据支持的指令集来编译代码。</p>
<p>x86：一种复杂指令集（Complex Instruction Set Computer）。</p>
<h2 id="RISC-V寄存器"><a href="#RISC-V寄存器" class="headerlink" title="RISC-V寄存器"></a>RISC-V寄存器</h2><p>下图展示了 RISC-V 的寄存器调用约定：</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/RISC-V%20calling%20convention%20register%20usage..jpg" alt="RVG calling convention"></p>
<p>表中第一列是寄存器名称，但是一般使用第二列的 ABI 名称，在编写汇编代码时也是使用ABI 名称。</p>
<p>在标准 RISC-V 调用约定中，堆栈向下增长，并且堆栈指针 sp 始终保持 16 字节对齐。</p>
<p>在寄存器中传递参数，最多 8 个整数寄存器 a0–a7 和最多 8 个浮点寄存器 fa0–fa7。如果一个函数有超过8个参数，就需要用内存了。</p>
<p>返回值保存在 a0 和 a1 以及浮点寄存器 fa0 和 fa1 。较大的返回值在内存中传递；调用者分配此内存区域并将指向它的指针作为第一个参数传递给被调用者。</p>
<p>RISC-V 采用小端法保存数据。寄存器都是 64 bits，各种各样的数据类型都会被改造的可以放进这64bit中。。比如说有一个32bit的整数，取决于整数是不是有符号的，会通过在前面补32个0或者1来使得这个整数变成64bit并存在这些寄存器中。</p>
<p>Caller Saved 调用者寄存器中的值有调用者保存，被调用者直接使用这些寄存器。</p>
<p>Callee Saved 被调用者寄存器的用法与 Caller Saved 相对应。被调用者若想使用 Callee Saved Reg ，则需要在使用前保存寄存器中的值，并在返回前恢复寄存器。</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>函数的 stack frame 是由编译器生成的机器代码在运行时构造的，调整堆栈指针（<code>sp</code>）以分配栈帧。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/stack%20frame.png" alt="stack frame"></p>
<p>对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。</p>
<p>一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。所以Stack Frame大小并不总是一样。</p>
<p>fp是frame pointer，用于指向当前帧底部（高地址），保存在寄存器s0中，同时每个函数栈帧中保存了调用当前函数的函数（父函数）的fp（保存在to prev frame那一栏中）</p>
<p>有关Stack Frame有两件事情是确定的：</p>
<ul>
<li>Return address总是会出现在Stack Frame的第一位</li>
<li>指向前一个Stack Frame的指针也会出现在栈中的固定位置</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/6-S081-Lab3-Page-Tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/14/6-S081-Lab3-Page-Tables/" class="post-title-link" itemprop="url">6.S081-Lab3-Page Tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-14 20:42:54" itemprop="dateCreated datePublished" datetime="2024-08-14T20:42:54+08:00">2024-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-07 18:29:11" itemprop="dateModified" datetime="2025-01-07T18:29:11+08:00">2025-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>一些操作系统（如 Linux）通过在用户空间和内核之间共享只读区域中的数据来加快某些系统调用的速度。创建每个进程时，在 USYSCALL（memlayout.h 中定义的一个 VA）处映射一个只读页面。 在该页面的开头，存储一个 struct usyscall（也在 memlayout.h 中定义），并将其初始化以存储当前进程的 PID。 在本实验中，用户空间侧提供了 ugetpid()，它将自动使用 USYSCALL 映射。 </p>
<p>实现：</p>
<ul>
<li><p>从<code>memlayout.h</code>中了解到USYSCALL在用户地址空间中的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建每个进程时完成映射。在<code>kernel/proc.c</code>的<code>proc_pagetable()</code>中学习<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的映射方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map one read-only page at USYSCALL(a VA defined in memlayout.h) just below   TRAPFRAME</span></span><br><span class="line"><span class="comment">// to speed up system calls who needs get the the PID of the current process.</span></span><br><span class="line"><span class="comment">// At the start of this page, store a struct usyscall (also defined in memlayout.h),</span></span><br><span class="line"><span class="comment">// and initialize it to store the PID of the current process.</span></span><br><span class="line"><span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;usyscallpage), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意要设置<code>PTE_U</code>，确保用户态下可以访问该PTE。</p>
<p>参照<code>p-&gt;trapframe</code>，需要在<code>proc</code>结构体中定义<code>usyscallpage</code>用于存放<code>struct usyscall</code>的地址，实际上就是<code>USYSCALL</code>的物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usyscallpage</span>;</span> <span class="comment">// Shared with kernel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个进程时的工作。在<code>kernel/proc.c</code>的<code>allocproc()</code>中为<code>USYSCALL</code>分配一个物理页空间。同时将当前进程的<code>pid</code>存放到<code>USYSCALL</code>页中的<code>usyscall</code>结构体中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a USYSCALL page.</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;usyscallpage = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;usyscallpage-&gt;pid = p-&gt;pid;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁一个进程时的工作。在<code>kernel/proc.c</code>的<code>freeproc()</code>中释放<code>USYSCALL</code>页空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;usyscallpage)</span><br><span class="line">  kfree((<span class="type">void</span>*)p-&gt;usyscallpage);</span><br><span class="line">p-&gt;usyscallpage = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此刻完成之后，运行 qemu 会 <code>panic</code> 错误。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">panic: freewalk: leaf</span><br></pre></td></tr></table></figure>

<p><code>panic: freewalk: leaf</code> 错误通常表示系统在页表管理过程中遇到了页表结构的损坏或误操作。这是因为在 <code>pagetable</code> 中任然存在我们之前的 PTE 映射。我们需要在 <code>kernel/proc.c</code> 的 <code>proc_freepagetable()</code> 中对其取消映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>编写一个可以打印页表内容的函数，定义一个名为 vmprint() 的函数。 它应该接受一个 pagetable_t 参数，并按照下面描述的格式打印该页表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line"> ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line"> .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line"> .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line"> .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line"> .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line"> ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line"> .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line"> .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000</span><br><span class="line"> .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000</span><br><span class="line"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>

<p> 在<code> exec.c</code> 中<code>return argc</code> 之前插入 <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，以打印第一个进程的页表。 </p>
<p>实现：</p>
<ul>
<li><p>按照提示参考<code>freewalk()</code>的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// A read/write/execute permission of 0 means it points to the next level of the page table.</span></span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      <span class="comment">// This is an intermediate page table, recursively released.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">// At least one of the read/write/execute permissions is 1, indicating that it points to physical memory.</span></span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：如何遍历页表、如何区分第三级页表的PTE(更高级别PTE中FLAG中没有RWX权限)。</p>
</li>
<li><p>关于打印格式中要注意，不同级别中PTE前面的<code> ..</code>不一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, uint16 level)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= level; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);     </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, (uint64)pte, child);</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        level++;</span><br><span class="line">        _vmprint((<span class="type">pagetable_t</span>)child, level);</span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, (uint64)pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>freewalk()</code>需要释放页表，所以要有<code>pagetable[i] = 0</code>，<code>_vmprint</code>中不能出现，否则会清空页表中的页表项，导致程序无法继续运行。</p>
</li>
</ul>
<h2 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h2><p>实现<code> pgaccess()</code>系统调用，用于报告哪些页面已被访问。系统调用需要三个参数。首先，它需要第一个要检查的用户页面的起始虚拟地址。其次，它接受要检查的页面数。最后，它需要一个缓冲区的用户地址，以便将结果存储到位掩码（一种数据结构，每页使用一位，其中第一页对应的是最小有效位）中。</p>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 baseaddr;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  uint64 maskbits = <span class="number">0</span>;</span><br><span class="line">  uint64 maskaddr;</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;baseaddr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">2</span>, &amp;maskaddr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va = PGROUNDDOWN(baseaddr);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    pte = walk(pagetable, va, <span class="number">1</span>);</span><br><span class="line">    va += PGSIZE;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_A)&#123;</span><br><span class="line">      maskbits |= (<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">      *pte &amp;= ~PTE_A;  <span class="comment">// clear PTE_A after checking if it is set.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, maskaddr, (<span class="type">char</span>*)&amp;maskbits, <span class="keyword">sizeof</span>(maskbits)) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;sys_pgacess copyout error&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>PTE_A</code>需要在<code>riscv.h</code>中设置；<code>walk()</code>需要在<code>defs.h</code>中声明。</p>
</li>
<li><p>获取<code>pagetable</code>时，下面的写法执行会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint64 x;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, satp&quot;</span> : <span class="string">&quot;=r&quot;</span> (x))</span>; </span><br><span class="line"><span class="type">pagetable_t</span> pagetable = (<span class="type">pagetable_t</span>)(x &amp; ~((uint64)<span class="number">0xfff</span>)); <span class="comment">// 去掉低12位</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="bug-Unresolved"><a href="#bug-Unresolved" class="headerlink" title="bug(Unresolved )"></a>bug(Unresolved )</h2><p><code>make grade</code>时<code>usertest</code>测试有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">== Test   usertests: all tests ==</span><br><span class="line">  usertests: all tests: FAIL</span><br><span class="line">    ...</span><br><span class="line">         test createdelete: OK</span><br><span class="line">         test linkunlink: OK</span><br><span class="line">         test linktest: OK</span><br><span class="line">         test unlinkread: OK</span><br><span class="line">         test concreate: qemu-system-riscv64: terminating on signal 15 from pid 19225 (make)</span><br><span class="line">    MISSING &#x27;^ALL TESTS PASSED$&#x27;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/24/6-S081-Leature-4-Page-tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/24/6-S081-Leature-4-Page-tables/" class="post-title-link" itemprop="url">6.S081-Leature 4 Page tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-24 22:55:27" itemprop="dateCreated datePublished" datetime="2024-07-24T22:55:27+08:00">2024-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-09 11:08:41" itemprop="dateModified" datetime="2025-01-09T11:08:41+08:00">2025-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>RISC-V 指令（包括用户和内核）操作的是虚拟地址。机器的 RAM，或者说物理内存，是用物理地址来做索引的。RISC-V的页表硬件通过将每个虚拟地址映射到（转换成）一个物理地址。</p>
<p> 由虚拟地址转换为物理地址是在处理器中的<strong>内存管理单元（Memory Management Unit, MMU）</strong>中完成的。将MMU视为一个“黑箱”，输入VP，输出PP。注意，<strong>页表保存在内存中</strong>，MMU只是会去查看页表。</p>
<p>xv6运行在Sv39 RISC-V上，这意味着只会使用64位虚拟地址的低39位，高25位没有被使用。可使用的低39位中的低12位为页内偏移地址<code>offset</code>，可以得知页大小为2^12B（4096B）；剩余的27位为页表的索引项<code>index</code>（或者称低12位为<strong>虚拟页偏移VPO</strong>，称剩余的27位为<strong>虚拟页号VPN</strong>）。</p>
<p>在这种Sv39配置中，一个RISC-V页表在逻辑上是一个由2^27（134,217,728）个<strong>页表项（Page Table Entry, PTE）</strong>组成的数组。每个PTE包含一个44位的<strong>物理页号（Physical Page Number, PPN）</strong>和一些标志位。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_pagework.jpg"></p>
<p>分页硬件通过利用39位中的高27位索引到页表中找到一个PTE来转换一个虚拟地址，并计算出一个56位的物理地址，它的前44位来自于PTE中的PPN，而它的后12位则是从原来的虚拟地址复制过来的。在逻辑上可以把页表看成是一个简单的PTE数组。</p>
<p>在Sv39 RISC-V中，虚拟地址的高25位不用于地址转换；将来RISC-V可能会使用这些位来定义更多的转换层。物理地址也有增长的空间：在PTE格式中，物理页号还有 10 位的增长空间。</p>
<p>VPN转换成PPN的实际过程分三步进行。一个页表以三层树的形式存储在物理内存中，多级页表。树的根部是一个 4096 字节的页表页，它包含 512 个 PTE，这些 PTE 包含树的下一级页表页的物理地址。每一页都包含 512 个 PTE，用于指向下一个页表或物理地址。分页硬件用 27 位中的高 9 位选择<strong>根页表页</strong>中的 PTE，用中间 9 位选择树中下一级页表页中的 PTE，用低 9 位选择最后的 PTE。根页表页的基地址存放在<code>satp</code>寄存器中。<code>satp</code>寄存器包含了还一些控制位，用于配置地址转换和保护机制。</p>
<p>页表页存放在单独的页中，每个页表页都包含 512 个 PTE，512*64bit&#x3D;4096B。</p>
<p>每个进程都有自己独立的页表，这个页表定义了进程的地址空间。所以当操作系统将CPU从一个进程切换到另一个进程时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应页表。写SATP寄存器是一条特权指令。在每个proc结构体，proc.h，里面有一个指向根页表的指针，这对应了SATP寄存器中的内容。</p>
<p>如果转换一个地址所需的三个 PTE 中的任何一个不存在，分页硬件就会引发一个<strong>缺页异常（page-fault exception）</strong>，让内核来处理这个异常。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_riscv_address_translation.jpg"></p>
<p>每个 PTE 都包含标志位，用于告诉分页硬件相关的虚拟地址被允许怎样使用。</p>
<ul>
<li><code>PTE_V</code> 表示 PTE 是否存在：如果Valid bit位为1，那么表明这是一条合法的PTE，可以用它来做地址翻译。如果没有设置（Valid bit位为0），对该页的引用会引起缺页异常。</li>
<li><code>PTE_R</code> 控制是否允许指令读取该页；<code>PTE_W</code> 控制是否允许指令向该页写入。</li>
<li><code>PTE_X</code> 控制 CPU 是否可以将页面的内容解释为指令并执行。</li>
<li><code>PTE_U</code> 控制是否允许用户态下的指令访问页面；如果不设置 <code>PTE_U</code>， 对应 PTE 只能在内核态下使用。</li>
</ul>
<p>标志位和与分页硬件相关的数据结构定义在（<code>kernel/riscv.h</code>）中。</p>
<p>每一级页表项可以有两种角色（前提是<code>PTE_V</code> 有效）：</p>
<ul>
<li><p><strong>指向物理页（叶节点）</strong>：如果设置了 R、W、X 中的任意一位，表示当前页表项是一个叶节点，映射到物理地址。</p>
</li>
<li><p><strong>指向下一级页表</strong>：如果 R&#x2F;W&#x2F;X 都为 0，表示当前页表项是一个中间节点，指向下一级页表。</p>
</li>
</ul>
<h2 id="页表缓存TLB"><a href="#页表缓存TLB" class="headerlink" title="页表缓存TLB"></a>页表缓存TLB</h2><p>如果回想一下虚拟地址转换成物理地址的过程，基本上都要做3次内存查找，第一次在最高级的page directory，第二次在中间级的page directory，最后一次在最低级的page directory。所以对于一个虚拟内存地址的寻址，需要读三次内存，代价有点高。</p>
<p>所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的转换结果有缓存。这个缓存被称为<strong>页表缓存（Translation Lookside Buffer, TLB）</strong>。TLB是对PTE的缓存，TLB会保存虚拟地址到物理地址的映射关系。这样访问虚拟地址时，处理器优先查看TLB，若TLB中存在对应的缓存会直接返回物理地址，而不需要通过页表得到结果。若TLB没有对应的缓存，再查看页表。这里用到cache的思想。</p>
<h2 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h2><p>Xv6 为每个进程维护一个用于描述进程的用户地址空间的页表，外加一个单独的描述内核地址空间的页表。</p>
<p>内核配置其地址空间的布局，使其能够通过可预测的虚拟地址访问物理内存和各种硬件资源。下图显示了这个设计是如何将内核虚拟地址映射到物理地址的。文件（<code>kernel/memlayout.h</code>）声明了 xv6 内核内存布局的常量。</p>
<p>图中左边是内核的虚拟地址空间，右边上半部分是物理内存（DRAM），右边下半部分是I&#x2F;O设备。图中的右半部分的结构完全由主板硬件设计者决定，如果得到的物理地址大于<code>0x80000000</code>会走向DRAM芯片，如果得到的物理地址低于<code>0x80000000</code>会流向不同的I&#x2F;O设备。在图中，I&#x2F;O设备是与DRAM统一编址的。</p>
<p>CPU只是主板的一小部分，DRAM芯片位于处理器之外。是主板设计者将处理器，DRAM和许多I&#x2F;O设备汇总在一起。对于一个操作系统来说，CPU只是一个部分，I&#x2F;O设备同样也很重要。所以当你在写一个操作系统时，你需要同时处理CPU和I&#x2F;O设备。下图左边是内核的虚拟地址空间，右边上半部分是物理内存或者说是DRAM。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_address_mapped.png"></p>
<p>回到上图的右侧，可以看到最下面是未被使用的地址。地址0x1000是boot ROM的物理地址，当主板上电时，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址<code>0x80000000</code>，操作系统需要确保那个地址有一些数据能够接着启动操作系统。</p>
<p>这里还有一些其他的I&#x2F;O设备：</p>
<ul>
<li>PLIC是中断控制器（Platform-Level Interrupt Controller）。</li>
<li>CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适 的处理函数。</li>
<li>UART0（Universal Asynchronous Receiver&#x2F;Transmitter）负责与Console和显示器交互。</li>
<li>VIRTIO disk，与磁盘进行交互。</li>
</ul>
<p>回到上图的左侧，这就是xv6的虚拟内存地址空间。当机器刚刚启动时，还没有可用的页，xv6操作系统会设置好内核使用的虚拟地址空间，也就是这张图左边的地址分布。虚拟内存从物理地址 <code>0x80000000</code> 开始， 到 <code>0x86400000</code>（xv6内存大小为128M），xv6 称之为 <code>PHYSTOP</code>。</p>
<p>因为想让xv6尽可能的简单易懂，内核对RAM和内存映射的设备寄存器使用“直接映射”，也就是将这些资源映射到和它们物理地址相同的虚拟地址上。例如，内核本身在虚拟地址空间和物理内存中的位置都是<code>KERNBASE=0x80000000</code>。直接映射简化了读&#x2F;写物理内存的内核代码。例如，当 <code>fork</code> 为子进程分配用户内存时，分配器返回该内存的物理地址；<code>fork</code> 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。</p>
<p>有几个内核虚拟地址不是直接映射：</p>
<ul>
<li><code>trampoline</code>页。它被映射在虚拟地址空间的顶端；用户页表也有这个映射。第 4 章讨论了 trampoline 页的作用，但我们在这里看到了页表的一个有趣的用例；一个物理页（存放 trampoline 代码）在内核的虚拟地址空间中被映射了两次：一次是在虚拟地址空间的顶部，一次是PHYSTOP下的Kernel text中直接映射，但是实际使用的时候用的是上面的部分，因为有Guard page会更加安全。可以两个虚拟地址映射到同一个物理地址。</li>
<li>内核栈页。<strong>每个进程都有自己的内核栈</strong>，内核栈被映射到高地址处，所以 xv6 可以在它后面留下一个未映射的保护页。<strong>Guard page（保护页）</strong>是操作系统用于检测和防止程序栈溢出的一种内存管理技术。它是一种特殊的内存页，Guard page对应的PTE的Valid 标志位没有设置，故意将其标记为不可访问，来捕获对该页的访问异常，从而实现栈溢出检测和处理。同时又不想浪费物理内存给Guard page，所以Guard page不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。</li>
</ul>
<p>内核将 trampoline 和 text（可执行程序的代码段）映射为有 <code>PTE_R</code> 和 <code>PTE_X</code> 权限的页。内核从这些页读取和执行指令。内核映射的其他页会有 <code>PTE_R</code> 和 <code>PTE_W</code> 权限，以便内核读写这些页面的内存。保护页的映射是无效的（不设置 <code>PTE_V</code>）。</p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p>为了保证强隔离性，每个程序都运行在自己的地址空间，并且这些地址空间彼此之间相互独立。所以现在我们的问题是如何在一个物理内存上，创建不同的地址空间，因为归根到底，我们使用的还是一堆存放了内存信息的DRAM芯片。</p>
<p>每个进程有一个页表，用于描述进程的用户地址空间，还有一个内核地址空间（所有进程共享这一个描述内核地址空间的页表）。为了让内核使用物理内存和硬件资源，内核需要按照一定的规则排布内核地址空间，以能够确定哪个虚拟地址对应自己需要的硬件资源地址。用户地址空间不需要也不能够知道这个规则，因为用户空间不允许直接访问这些硬件资源。</p>
<p>QEMU会模拟一个从0x80000000开始的RAM，一直到0x86400000。QEMU会将设备接口以控制寄存器的形式暴露给内核，这些控制寄存器在0x80000000以下。kernel对这些设备接口控制寄存器的访问是直接和这些设备而不是RAM进行交互的。</p>
<p>不同的进程页表将用户地址转化为物理内存的不同页，这样每个进程都有私有的用户内存。第二，每个进程都认为自己的内存具有从零开始的连续的虚拟地址，而进程的物理内存可以是不连续的。第三，内核会映射带有 <code>trampoline</code> 代码的页到用户地址空间顶端，因此有一个物理内存页在所有地址空间中都会出现。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_useraddress_space.png"></p>
<p>图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。栈只有一页，图中显示的是由<code>exec</code> 创建的初始内容。位于栈顶部的字符串中包含了命令行中输入的参数和指向他们的指针数组。在下方是允许程序在 <code>main</code> 启动的值，就像函数 <code>main(argc, argv)</code> 是刚刚被调用一样。</p>
<h2 id="Code-creating-an-address-space"><a href="#Code-creating-an-address-space" class="headerlink" title="Code: creating an address space"></a>Code: creating an address space</h2><p>大部分用于操作地址空间和页表的 xv6 代码都在<code>vm.c</code>（<code>kernel/vm.c:1</code>）中。核心数据结构是 <code>pagetable_t</code>，它实际上是一个指向 RISC-V 根页表页的指针；<code>pagetable_t</code>可以是内核页表，也可以是进程的页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br></pre></td></tr></table></figure>

<p>在机器启动时，在启动序列的靠前部分，<code>main</code> 调用 <code>kvminit</code>（<code>kernel/vm.c:22</code>）来创建内核页表。这个调用发生在 xv6 在 RISC-V 启用分页之前，所以地址直接指向物理内存。<code>kvminit</code>中直接调用<code>kvmmake</code>：</p>
<ul>
<li>为内核创建一个新的页表，分配顶级页表（根页表）。</li>
<li>调用 <code>kvmmap</code> 将内核所需要的硬件资源映射到物理地址。这些资源包括内核的指令和数据，<code>KERNBASE</code> 到 <code>PHYSTOP</code>的物理内存，以及实际上是设备的内存范围。</li>
<li>随后调用 <code>proc_mapstacks</code>为每个进程分配一个内核栈，并将其映射到内核虚拟地址空间中。</li>
</ul>
<p><code>kvmmap</code>（<code>kernel/vm.c:118</code>）调用 <code>mappages</code>（<code>kernel/vm.c:149</code>），它将指定范围的虚拟地址映射到一段物理地址。本质上就是按格式创建页表项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table .</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="comment">// perm: Permission flags for page table entries (e.g., PTE_R, PTE_W, PTE_X).</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// Page table not allocated and allocation of page table page failed</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      <span class="comment">// The page table entry has been marked as valid (PTE_V), </span></span><br><span class="line">      <span class="comment">// indicating that the virtual address has been mapped</span></span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>walk</code>：给定一个虚拟地址和一个页表，返回最低层页表中的PTE的地址，模拟MMU的功能。如果 PTE 无效，那么所需的物理页还没有被分配；如果 <code>alloc</code> 参数被设置，<code>walk</code> 会分配一个新的页表页，并把它的物理地址放在 PTE 中。（<code>kernel/vm.c:88</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>proc_mapstacks</code> 为每个进程分配内核栈，并建立映射，确保每个栈的位置固定且相互隔离。通过引入保护页，进一步提高了内核的稳定性和安全性。<code>KSTACK</code> 宏计算了每个进程内核栈在虚拟地址空间中的位置，并保证了它们之间的分布合理且一致。</p>
<p>虚拟内存中的保护页不会实际映射到物理地址中。由下面的宏可知，连续的两个内核栈地址相差2个<code>PGSIZE</code>，一个内核栈实际只占一个页，剩余的一个页即为保护页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for each process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_mapstacks</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="type">char</span> *pa = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code> 调用 <code>kvminithart</code>（<code>kernel/vm.c:53</code>）来映射内核页表。它将根页表页的物理地址写入寄存器 <code>satp</code> 中。在这之后，CPU 将使用内核页表翻译地址。</p>
<p><code>main</code> 调用<code>procinit</code>（<code>kernel/proc.c:26</code>），为每个进程分配一个内核栈。就是将<code>KSTACK(p)</code> 赋给<code>proc-&gt;kstack</code>。</p>
<p>每个 RISC-V CPU 都会在 **Translation Look-aside Buffer(TLB)**中缓存页表项，当 xv6 改变页表时，必须告诉 CPU 使相应的缓存 TLB 项无效。RISC-V 有一条指令 <code>sfence.vma</code>，可以刷新当前 CPU 的 TLB。xv6 在<code>kvminithart</code>中，重新加载 <code>satp</code> 寄存器后， 执行 <code>sfence.vma</code>，也会在从内核空间返回用户空间前，切换到用户页表的trampoline 代码中执行 <code>sfence.vma</code>（<code>kernel/trampoline.S:79</code>）。</p>
<h2 id="kvminithart"><a href="#kvminithart" class="headerlink" title="kvminithart"></a>kvminithart</h2><p><code>kvminithart</code> 是一个用于初始化每个硬件线程（hart）分页机制的函数。它的主要任务是将硬件的页表寄存器切换到内核页表，并启用分页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  sfence_vma();	<span class="comment">// flush the TLB.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数首先设置了SATP寄存器，kernel_pagetable变量来自于kvminit第一行。所以这里实际上是内核告诉MMU来使用刚刚设置好的page table。在这条指令之前，还不存在可用的page table，所以也就不存在地址翻译。执行完这条指令之后，程序计数器（Program Counter）增加了4。而之后的下一条指令被执行时，程序计数器会被内存中的page table翻译。</p>
<p>所以这条指令的执行时刻是一个非常重要的时刻。因为整个地址翻译从这条指令之后开始生效，之后的每一个使用的内存地址都可能对应到与之不同的物理内存地址。因为在这条指令之前，我们使用的都是物理内存地址，这条指令之后page table开始生效，所有的内存地址都变成了另一个含义，也就是虚拟内存地址。</p>
<h2 id="Code-Physical-memory-allocator"><a href="#Code-Physical-memory-allocator" class="headerlink" title="Code: Physical memory allocator"></a>Code: Physical memory allocator</h2><p>xv6对kernel space和<code>PHYSTOP</code>之间的物理空间在运行时进行分配，分配以页(4096 bytes)为单位。分配和释放是通过对空闲页链表进行追踪完成的，分配空间就是将一个页从链表中移除，释放空间就是将一页增加到链表中</p>
<p>kernel的物理空间的分配函数在<code>kernel/kalloc.c</code>中，每个页在链表中的元素是<code>struct run</code>。这个空闲页的链表<code>freelist</code>由自旋锁保护，包装在<code>struct kmem</code>中。</p>
<ul>
<li><code>kinit()</code>：对自旋锁进行初始化，并将kernel结尾到PHYSTOP之间的所有空闲空间都添加到kmem链表中，这是通过调用<code>freerange(end, PHYSTOP)</code>实现的</li>
<li><code>freerange()</code>对这个范围内所有页都调用一次<code>kfree</code>来将这个范围内的页添加到<code>freelist</code>链表中</li>
<li><code>kfree()</code>接受参数pa，pa必须是物理页的起始地址。将该页空间用1填充，并加入空闲页链表<code>freelist</code>中</li>
<li><code>kalloc()</code>从<code>freelist</code>中分配出一个空闲物理页。</li>
</ul>
<h2 id="Code-sbrk"><a href="#Code-sbrk" class="headerlink" title="Code: sbrk"></a>Code: sbrk</h2><p><code>sbrk</code> 是 一 个 进 程 收 缩 或 增 长 内 存 的 系 统 调 用 。 该 系 统 调 用 由 函 数<code>growproc</code>（<code>kernel/proc.c:239</code>）实现，<code>growproc</code> 调用 <code>uvmalloc</code> 或 <code>uvmdealloc</code>，取决于 <code>n</code> 是正数还是负数。</p>
<ul>
<li><p><code>uvmalloc</code>（<code>kernel/vm.c:229</code>）通过 <code>kalloc</code> 分配物理内存，并使用 <code>mappages</code> 将 PTE 添加到用户页表中。 </p>
</li>
<li><p><code>uvmdealloc</code> 调用 <code>uvmunmap</code>（<code>kernel/vm.c:174</code>），它使用 <code>walk</code> 来查找 PTE 并使用 <code>kfree</code> 来释放它们所引用的物理内存。</p>
</li>
</ul>
<p>xv6 使用进程的页表不仅是为了告诉硬件如何映射用户虚拟地址，也是将其作为分配给该进程的物理地址的唯一记录。这就是为什么释放用户内存（<code>uvmunmap</code> 中）需要检查用户页表的原因。</p>
<h2 id="Code-exec"><a href="#Code-exec" class="headerlink" title="Code: exec"></a>Code: exec</h2><p><code>exec</code> 系统调用用来创建一个地址空间的用户部分。相关代码在<code>kernel/exec.c</code>中，它读取储存在文件系统上的文件用来初始化一个地址空间的用户部分。其内部使用了<code>vm. c</code>和<code>kalloc.c</code>中的多个函数实现对用户地址空间的布置。</p>
<ul>
<li>二进制可执行文件数据读取，并检查ELF头部格式。首先通过<code>namei()</code>读取文件的inode，再快速检查文件是否是ELF格式。</li>
<li>分配用户页表。<code>proc_pagetable()</code>中调用<code>uvmcreate()</code>创建一个空的用户页表，再调用<code>mappages()</code>将<code>trampoline</code>和<code>trapframe</code>载入页表。</li>
<li>根据 ELF 文件的 Program headers 加载代码和数据段到内存。首先调用<code>uvmalloc</code>分配物理内存和PTE，再调用<code>loadseg</code>将各个segment写入内存中。</li>
<li>分配两个页，其中一个作为用户栈，一个作为栈保护页。 将 <code>argv</code> 的内容和指针复制到用户栈中，设置栈指针。</li>
<li>更新进程的页表、大小、用户栈指针以及入口点，并且释放该进程旧的页表。</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/22/6-S081-Lab2-System-calls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/6-S081-Lab2-System-calls/" class="post-title-link" itemprop="url">6.S081-Lab2-System calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 20:13:02" itemprop="dateCreated datePublished" datetime="2024-07-22T20:13:02+08:00">2024-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-06 20:34:37" itemprop="dateModified" datetime="2025-01-06T20:34:37+08:00">2025-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>添加一项系统调用跟踪功能。 创建一个新的系统调用<code>trace</code>来控制跟踪哪个系统调用。<code>trace</code>应该接受一个参数，即一个整数 “掩码”，其位指定要跟踪的系统调用，可以同时追踪多个系统调用。  <code>trace</code>系统调用追踪调用进程及随后派生的任意子进程，但不应影响其他进程。</p>
<p>思路：</p>
<ul>
<li><p><strong>系统调用函数的添加流程：</strong></p>
<ul>
<li><p>声明封装函数，为新的系统调用提供一个简便的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>user/usys.pl</code>注册一个存根，定义<code>ecall</code>到内核态下<code>trace</code>系统调用的入口。脚本文件user&#x2F;usys.pl的作用是生成 <code>usys.S</code> 文件，其中包含每个系统调用（syscall）的汇编桩代码（stub）。这些桩代码是用户程序调用系统调用的入口点，它们封装了触发系统调用的汇编逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.h</span></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...	</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/syscall.h</code>，添加系统调用号（syscall call number）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/syscall.c</code>，添加系统调用外部声明，更新系统调用表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/sysproc.c</code>，实现系统调用<code>trace</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// control trace System Calls</span></span><br><span class="line"><span class="comment">// save the mask fo tracing system calls</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;   <span class="comment">// an integer &quot;mask&quot;, whose bits specify which system calls to trace</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)  <span class="comment">// get the a0 register on the kernel stack</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;syscallnum = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意系统调用<code>trace</code>的实现中只是将要追踪的系统调用（可多个）的mask传递给进程的变量<code>syscallnum</code>，打印内容在<code>syscall</code>中实现。</p>
</li>
</ul>
</li>
<li><p>在<code>kernel/proc.h</code>中结构体<code>proc</code>的定义中添加一个变量来存储要追踪的系统调用的mask。</p>
</li>
<li><p>在<code>kernel/proc.c</code>中的<code>fork()</code>中，添加功能保证<code>trace</code>能追踪子进程中的系统调用情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy system call trace&#x27;s argument</span></span><br><span class="line">  np-&gt;syscallnum = p-&gt;syscallnum;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>kernel/syscall.c</code>中的<code>syscall()</code>来打印<code>trace</code>的追踪情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> *syscallname[<span class="number">22</span>]=&#123;<span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;   <span class="comment">// system call number</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;syscallnum &amp; (<span class="number">1</span> &lt;&lt; num))&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallname[num<span class="number">-1</span>], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在判断当前的系统调用是否被追踪时，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;syscallnum == (<span class="number">1</span> &lt;&lt; num))&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这里判断是否相等只能追踪一个系统调用。再看<code>mask</code>的含义，二进制下<code>00001000</code>表示追踪系统调用3，二进制下<code>00011000</code>表示追踪系统调用3和系统调用4。</p>
</li>
<li><p><code>Timeout! trace children</code>超时怎么办？电脑性能问题，在<code>gradelib.py</code>中改变超时判断时间30s为更长时间即可。</p>
</li>
</ul>
<h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>添加一个系统调用<code>sysinfo</code>，它收集有关正在运行的系统的信息。系统调用采用一个参数：一个指向<code>struct sysinfo</code>的指针。内核应该填写这个结构的字段：<code>freemem</code>字段应该设置为空闲内存的字节数，<code>nproc</code>字段应该设置为<code>state</code>字段不为<code>UNUSED</code>的进程数。</p>
<p>思路：</p>
<ul>
<li><p>按照系统调用函数的添加流程，添加系统调用。</p>
</li>
<li><p>在<code>kernel/kalloc.c</code>实现计算空闲内存的字节数的函数。查看该文件，系统的内存是<strong>按页分配</strong>空闲的，只要计算出空闲页数即可。系统中有空闲页链表<code>kmem.freelist</code>来记录空闲页，遍历空闲页链表即可得空闲页数。注意在访问<code>kmem</code>时要保证互斥，加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the number of bytes of free memory</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kgetfreemem</span><span class="params">(uint64 *freemem)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 freepage = <span class="number">0</span>;   <span class="comment">// the num of free page</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">p</span>;</span>    <span class="comment">// working pointer, is used to traverse the freelist</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  p = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(p)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    freepage++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  *freemem = freepage * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/proc.c</code>中实现计算<code>state</code>字段不为<code>UNUSED</code>的进程数的功能。查看该文件，系统中有一个<code>proc</code>结构体数组用于管理进程，遍历该数组分别查看<code>proc-&gt;state</code>即可。函数书写风格源于该文件下其他函数的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collect the number of processes.</span></span><br><span class="line"><span class="comment">// Traverse the process table, looking for processes with a statu of not UNUSED.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">collectproc</span><span class="params">(uint64 *nproc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> freeprocnum = <span class="number">0</span>;  <span class="comment">// the number of free proc</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      freeprocnum++;</span><br><span class="line">    &#125;</span><br><span class="line">     release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *nproc = NPROC - freeprocnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/sysproc.c</code>中实现系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 infopointer;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  kgetfreemem(&amp;info.freemem);</span><br><span class="line">  collectproc(&amp;info.nproc);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;infopointer) &lt; <span class="number">0</span>)  <span class="comment">// get the a0 register on the kernel stack</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                     <span class="comment">// a0 register sacves a pointer to a struct sysinfo</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, infopointer, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意要在<code>sysproc.c</code>中添加头文件<code>sysinfo.h</code>；在<code>defs.h</code>中添加<code>kgetfreemem()</code>和<code>collectproc()</code>的函数声明。</p>
</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/22/6-S081-xv6%E5%9C%A8qemu%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/6-S081-xv6%E5%9C%A8qemu%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">6.S081-xv6在qemu中的启动过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 10:56:00" itemprop="dateCreated datePublished" datetime="2024-07-22T10:56:00+08:00">2024-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-09 11:09:00" itemprop="dateModified" datetime="2025-01-09T11:09:00+08:00">2025-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Make-qemu-推导"><a href="#Make-qemu-推导" class="headerlink" title="Make qemu 推导"></a>Make qemu 推导</h2><p>参看 Makefile 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu: $K/kernel fs.img</span><br><span class="line">    $(QEMU) $(QEMUOPTS)</span><br></pre></td></tr></table></figure>

<p>目标 <code>kernel</code> 和 <code>fs.img</code> 存在且最新，执行 <code>$(QEMU) $(QEMUOPTS)</code> ，即 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -bios none \</span><br><span class="line">    -kernel kernel/kernel \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -smp 3 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -global virtio-mmio.force-legacy=false \</span><br><span class="line">    -drive file=fs.img,if=none,format=raw,id=x0 \</span><br><span class="line">    -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>qemu-system-riscv64</code>：启动 QEMU 的命令，模拟一台 64 位 RISC-V 架构的计算机。</li>
<li><code>-machine virt</code>：指定要模拟的虚拟机硬件的机器类型为 virt。</li>
<li><code>-bios none</code>：不使用 BIOS，因为 RISC-V 架构通常不需要 BIOS。</li>
<li><code>-kernel kernel/kernel</code>：指定要加载的内核映像文件路径。</li>
<li><code>-m 128M</code>：指定虚拟机的内存大小为128MB。</li>
<li><code>-smp 3</code>：指定虚拟机的 CPU 核心数量为3个。</li>
<li><code>-nographic</code>：以无图形界面模式运行虚拟机，所有输出将会通过终端输出。</li>
<li><code>-global virtio-mmio.force-legacy=false</code>：设置 virtio-mmio 设备为非遗留模式。在虚拟化环境中，virtio 是一种用于虚拟机和宿主机之间通信的设备标准。virtio-mmio 是一种 virtio 设备的接口规范，用于在内存映射 I&#x2F;O（MMIO）方式下与虚拟机进行通信。通过在 QEMU 中启用非遗留模式的 virtio-mmio 设备，可以提高设备的性能和功能。</li>
<li><code>-drive file=fs.img,if=none,format=raw,id=x0</code>：添加一个虚拟硬盘设备，并指定硬盘镜像文件为 “fs.img”。</li>
<li><code>-device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</code>：添加一个 virtio 块设备，并将之前创建的虚拟硬盘设备连接到其中。</li>
</ul>
<h2 id="Qemu-启动"><a href="#Qemu-启动" class="headerlink" title="Qemu 启动"></a>Qemu 启动</h2><p>在 QEMU 模拟的 virt 硬件平台上，物理内存的起始物理地址通常为0x80000000（即2GB）。由于使用了 <code>-m 128M</code> 选项进行配置，虚拟机 128MB 大小的内存对应物理地址区间为 <code>[0x80000000,0x88000000)</code> 。如果使用上面给出的命令启动 QEMU ，那么在 QEMU 开始执行任何指令之前，会将内核镜像文件 <code>kernel/kernel</code>加载到物理内存 <code>0x80000000</code> 上，<code>0x80000000</code> 这个位置是 QEMU 本身设置的[<a target="_blank" rel="noopener" href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c">https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c</a>]。</p>
<p>将必要的文件载入到 QEMU 物理内存之后，QEMU CPU 的程序计数器 PC 会被初始化为 <code>0x1000</code> ，因此 QEMU 实际执行的第一条指令位于物理地址 <code>0x1000</code> ，接下来它将执行数条指令并跳转到物理地址 <code>0x80000000</code> 。</p>
<p>启动QEMU，并打开gdb，<code>CPUS=1</code>单核启动便于调试。本质上来说 QEMU 内部有一个 gdb server，当我们启动之后，QEMU 会等待 gdb 客户端连接。运行 <code>gdb-multiarch</code>再启动一个gdb客户端，会出现一个警告，按照提示处理即可。可见 PC 确实被初始化为 <code>0x1000</code>。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu1.PNG"></p>
<p>运行 <code>layout asm</code> 命令，查看汇编指令，就是这几条指令控制程序转到物理地址 <code>0x80000000</code> 。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu2.PNG"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x1000 auipc t0,0x0      ; t0 = PC + (0x0 &lt;&lt; 12) = 0x1000</span><br><span class="line">0x1004 addi  a2,t0,40    ; a2 = t0 + 40 = 0x1028</span><br><span class="line">0x1008 csrr  a0,mhartid  ; 将硬件寄存器 mhartid 的值（当前硬件线程 ID 为 0）存入寄存器 a0 中。</span><br><span class="line">0x100c ld    a1,32(t0)   ; a1 = (0x1000 + 32) = (0x1020) = 0x87000000</span><br><span class="line">0x1010 ld    t0,24(t0)   ; t0 = (0x1000 + 24) = (0x1018) = 0x80000000</span><br><span class="line">0x1014 jr    t0          ; PC = t0，跳转到寄存器 t0 中保存的地址</span><br><span class="line">0x1018 unimp             ; unimplemented operation，0x0000</span><br><span class="line">0x101a .2byte 0x8000     ; .2byte汇编伪指令,直接将值0x8000存储到目标内存0x101a中</span><br></pre></td></tr></table></figure>

<p>RISC-V 架构通常使用小端（Little Endian）字节序来存储数据。在小端字节序中，最低有效字节（Least Significant Byte，LSB）存储在地址的最低字节处，而最高有效字节（Most Significant Byte，MSB）存储在地址的最高字节处。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu3.png"></p>
<p>跳转到 t0 中保存的地址 0x80000000，进入内核的第一条指令，计算机的控制权已经被移交给内核。</p>
<p>地址0x80000000是一个被QEMU认可的地址。也就是说如果你想使用QEMU，那么第一个指令地址必须是它。所以，我们会让内核加载器从那个位置开始加载内核。查看kernel.ld：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * ensure that entry.S / _entry is at 0x80000000,</span></span><br><span class="line"><span class="comment">   * where qemu&#x27;s -kernel jumps.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  . = <span class="number">0x80000000</span>;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h2 id="内核的第一个进程"><a href="#内核的第一个进程" class="headerlink" title="内核的第一个进程"></a>内核的第一个进程</h2><p>xv6内核已被加载到物理地址<code>0x80000000</code>的内存中。在<strong>机器模式</strong>下，CPU从 <code>_entry</code>（kernel&#x2F;entry.S:6）开始执行xv6。RISC-V在禁用分页硬件的情况下启动：虚拟地址直接映射到物理地址。</p>
<p>之所以将内核放在<code>0x80000000</code>而不是<code>0x0</code>，是因为地址范围<code>0x0:0x80000000</code>包含 I&#x2F;O 设备。现代的体系结构大多使用 MMIO(Memory-mapped IO) 的形式，使用相同的地址总线来寻址内存和 I&#x2F;O 设备。当CPU访问某个地址的时候，可能是要访问某一部分物理内存，也可能是要访问I&#x2F;O设备上的内存。</p>
<img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu5.jpg"/>

<p>在程序的入口处设置一个端点这是QEMU会跳转到的第一个指令。设置完断点之后，运行程序，但并没有停在<code>0x80000000</code>（在<code>kernel.asm</code>中，0x80000000是程序的起始位置），而是停在了<code>0x8000000a</code>。</p>
<p><code>_entry</code> 阶段主要是为硬件线程分配栈并跳转到内核初始化的主要逻辑 <code>start</code>。同时注意到<code>entry.s</code>与编译后的<code>kernel.asm</code>中的代码不尽相同，因为编译器对伪指令进行了解析、对符号进行了替换、并对目标内存地址进行了调整。</p>
<p>在现代操作系统中，<strong>硬件线程栈</strong>、<strong>用户栈</strong>和<strong>内核栈</strong>各自有明确的职责和作用，但它们之间相互关联，共同支持进程的运行和上下文切换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">######################                entry.S:                ######################   </span><br><span class="line">        # qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each hart (i.e. CPU) to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la    sp, stack0     ; sp = &amp;stack0</span><br><span class="line">        li    a0, 1024*4     ; a0 = 4096</span><br><span class="line">        csrr  a1, mhartid    ; a1 = mhartid</span><br><span class="line">        addi  a1, a1, 1      ; a1++</span><br><span class="line">        mul   a0, a0, a1     ; a0 = a0 * a1 = 4096 * (hartid + 1)</span><br><span class="line">        add   sp, sp, a0     ; sp += a0 = &amp;stack0 + 4096 * (hartid + 1)</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure>

<p>xv6从entry.S开始启动，这个时候没有内存分页，没有隔离性，并且运行在M-mode（machine mode）。xv6会尽可能快的跳转到supervisor mode。<code>call start</code>后，执行<code>kernel/start.c/start()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要完成了以下任务：</p>
<ul>
<li><p>将上一个特权模式设置为监督模式，以便从机器模式返回时进入监督模式。</p>
</li>
<li><p>设置异常返回地址为<code>main</code>函数的地址。</p>
</li>
<li><p>使用<code>mret</code>指令切换到监督模式并跳转到<code>main</code>函数。</p>
</li>
</ul>
<p>kernel&#x2F;main.c中代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main()</code>主要进行各种初始化，通过<code>userinit</code>运行第一个用户进程。<code>userinit()</code> 函数负责创建并初始化第一个用户态进程，<code>p-&gt;state = RUNNABLE</code>方便调度器调度。接下来会执行通过 <code>exec()</code> 来加载用户态的 <code>/init</code> 程序，这个进程执行了一个<code>initcode.S</code>的汇编程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a user program that calls exec(&quot;/init&quot;)</span></span><br><span class="line"><span class="comment">// od -t xC initcode</span></span><br><span class="line">uchar initcode[] = &#123;</span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x13</span>, <span class="number">0x05</span>, <span class="number">0x45</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x97</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x93</span>, <span class="number">0x85</span>, <span class="number">0x35</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xef</span>, <span class="number">0xf0</span>, <span class="number">0x9f</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x69</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个汇编程序中，它首先将init中的地址加载到a0，argv中的地址加载到a1，<code>exec</code>对应的系统调用号加载到a7，最后调用<code>ECALL</code>。所以这里执行了3条指令，之后在第4条指令执行系统调用将控制权交给了操作系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>num = p-&gt;trapframe-&gt;a7</code> 会读取使用的系统调用对应的整数。<code>p-&gt;trapframe-&gt;a0 = syscall[num]()</code> 这是实际执行系统调用。这里可以看出，num用来索引一个数组，这个数组是一个函数指针数组，可以预期的是syscall[7]对应了exec的入口函数<code>sys_exec</code>，从 <code>exec()</code> 系统调用返回后，用户态开始运行 <code>/init</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># user/init.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *argv[] = &#123; <span class="string">&quot;sh&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">      <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">      wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">        <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init会为用户空间设置好一些东西，比如配置好console，调用<code>fork</code>，并在子进程中执行shell。至此整个系统启动了。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/20/6-S081-Lecture-3-OS-Organization-and-System-Calls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/20/6-S081-Lecture-3-OS-Organization-and-System-Calls/" class="post-title-link" itemprop="url">6.S081-Lecture 3 OS Organization and System Calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-20 23:54:54" itemprop="dateCreated datePublished" datetime="2024-07-20T23:54:54+08:00">2024-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-09 11:08:50" itemprop="dateModified" datetime="2025-01-09T11:08:50+08:00">2025-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="操作系统隔离性（Isolation）"><a href="#操作系统隔离性（Isolation）" class="headerlink" title="操作系统隔离性（Isolation）"></a>操作系统隔离性（Isolation）</h2><p>一个操作系统必须满足三个要求：多路复用、隔离和交互。</p>
<p>隔离性的思想：</p>
<ul>
<li><p>在不同的应用程序之间应该有强隔离性。当某一个应用程序的代码出现了问题，不应该会影响到其他的应用程序。</p>
</li>
<li><p>在应用程序和操作系统之间有强隔离性。操作系统某种程度上为所有的应用程序服务，当一个应用程序出现问题时，操作系统不应该因此崩溃。</p>
</li>
<li><p>不同应用程序之间的内存是隔离的，这样一个应用程序就不会覆盖另一个应用程序的内存。</p>
</li>
</ul>
<p>如果没有操作系统会怎样？</p>
<ul>
<li><p>如果没有操作系统，应用程序会直接与硬件交互。比如，应用程序可以直接看到CPU的多个核，看到磁盘，内存。现在没有操作系统来帮助切换运行在CPU上的应用程序，这个程序可能永远不会释放CPU，其他程序就永远无法运行。</p>
</li>
<li><p>从内存的角度来说，如果应用程序直接运行在硬件资源之上，那么每个应用程序的文本，代码和数据都直接保存在物理内存中。应用程序的内存之间没有边界，这样一个应用程序就可能会覆盖另一个应用程序的内存。</p>
</li>
</ul>
<p>操作系统提供的接口通过抽象硬件资源（将硬件资源抽象为服务），使得强隔离性成为可能。</p>
<ul>
<li><p><code>fork</code>创建了进程。进程本身不是CPU，但是它们对应了CPU，它们使得你可以在CPU上运行计算任务。应用程序不能直接与CPU交互，只能与进程交互。操作系统内核会完成不同进程在CPU上的切换。所以，操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，<strong>进程抽象了CPU</strong>，这样操作系统才能在多个应用程序之间<strong>复用</strong>一个或者多个CPU。</p>
</li>
<li><p><strong><code>exec</code>抽象了内存</strong>。<code>exec</code>系统调用用于加载一个新程序到当前进程的地址空间，并开始执行这个新程序。这个调用过程确保了程序只能访问被分配的虚拟地址空间，不能直接访问物理内存。操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。</p>
</li>
<li><p><strong>files抽象了磁盘</strong>。在Unix和类Unix操作系统中，文件系统（file system）提供了一种抽象，使应用程序不需要直接与底层的硬件（如磁盘）交互。通过文件系统的抽象，操作系统可以实现对存储设备的管理和访问控制。</p>
<p>在Unix中，与存储系统交互的唯一方式就是通过files。Files提供了非常方便的磁盘抽象，你可以对文件命名，读写文件等等。之后，操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件。通过files的抽象，可以实现不同用户之间和同一个用户的不同进程之间的文件强隔离。</p>
</li>
</ul>
<h2 id="操作系统防御性（Defensive）"><a href="#操作系统防御性（Defensive）" class="headerlink" title="操作系统防御性（Defensive）"></a>操作系统防御性（Defensive）</h2><p>操作系统需要确保所有的组件都能工作，所以它需要做好准备抵御来自应用程序的攻击。如果说应用程序无意或者恶意的向系统调用传入一些错误的参数就会导致操作系统崩溃，操作系统因为崩溃了会拒绝为其他所有的应用程序提供服务。</p>
<p>另外，应用程序不能够打破操作系统对它的隔离。应用程序非常有可能是恶意的，攻击者可能想要打破对应用程序的隔离，进而控制内核。一旦有了对于内核的控制能力，就可以做任何事情，因为内核控制了所有的硬件资源。所以操作系统或者说内核需要具备防御性来避免类似的事情发生。</p>
<h2 id="硬件对于强隔离的支持"><a href="#硬件对于强隔离的支持" class="headerlink" title="硬件对于强隔离的支持"></a>硬件对于强隔离的支持</h2><p>硬件对于强隔离的支持包括了：用户态&#x2F;内核态、虚拟内存。</p>
<p>为了支持user&#x2F;kernel mode，处理器会有两种操作模式，第一种是user mode，第二种是kernel mode。当运行在kernel mode时，CPU可以运行特权指令（privileged instructions）；当运行在user mode时，CPU只能运行非特权指令（unprivileged instructions）。</p>
<p><strong>特权指令</strong>主要是一些直接操纵硬件的指令和设置保护的指令，只允许处于内核态下的程序执行。例如设置page table寄存器、关闭时钟中断。在处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。</p>
<p><strong>非特权指令</strong>就是普通权限指令，所有的应用程序都允许执行这些指令。例如将两个寄存器相加的指令ADD、将两个寄存器相减的指令SUB、跳转指令JRC、BRANCH指令等等。</p>
<p>在处理器里面有一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特权指令并且该bit被设置为1，处理器会拒绝执行这条指令。设置这个bit位的指令必须是特权指令。</p>
<p>为了实现进程隔离，RISC-V CPU在硬件上提供3种执行命令的模式：machine mode, supervisor mode, user mode。</p>
<ul>
<li><p>机器模式machine mode的权限最高，在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6会在机器模式下执行几条指令，然后转为监督者模式。</p>
</li>
<li><p>在监督者模式supervisor mode下，CPU被允许执行特权指令。如果用户模式下的应用程序试图执行一条特权指令，CPU不会执行该指令，而是切换到监督者模式，这样监督者模式的代码就可以终止该应用程序。</p>
</li>
<li><p>在用户模式user mode下只能执行非特权指令指令。要想让CPU从用户模式切换到监督者模式，RISC-V提供了一个特殊的<code>ecall</code>指令，要想从监督者模式切换到用户模式，调用<code>sret</code>指令。</p>
</li>
</ul>
<p>对于虚拟内存，处理器包含了页表page table，而页表将虚拟内存地址与物理内存地址做了对应。每一个进程都会有自己独立的页表，每一个进程只能访问出现在自己页表中的物理内存。</p>
<p>操作系统通过设置进程的页表，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存。一个进程不能随意编造一个内存地址，然后通过这个内存地址来访问其他进程的物理内存。这样就给提供了内存的强隔离性。</p>
<h2 id="用户态-内核态的切换"><a href="#用户态-内核态的切换" class="headerlink" title="用户态&#x2F;内核态的切换"></a>用户态&#x2F;内核态的切换</h2><p>用户态&#x2F;内核态是分隔用户空间和内核空间的边界，用户空间中运行的程序运行在用户态，内核空间中的程序运行在内核态。操作系统位于内核空间。</p>
<p>需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。在RISC-V中，有一个专门的指令用来实现这个功能，叫做<strong>ECALL</strong>。ECALL接收一个参数，当一个用户程序想要将程序执行的控制权转移到内核，只需要执行ECALL指令，并传入一个数字（系统调用号）。这里的数字参数代表了应用程序想要调用的System Call。</p>
<p>在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是哪个系统调用。</p>
<p>举个例子，用户态下用户程序调用<code>fork()</code>函数（这是封装好的系统调用函数，并不是真正的系统调用），<code>fork()</code>函数中调用<code>ecall sys_fork</code>，系统陷入内核态并执行syscall函数，再由syscall函数实际调用<code>fork</code>系统调用。</p>
<h2 id="宏内核与微内核"><a href="#宏内核与微内核" class="headerlink" title="宏内核与微内核"></a>宏内核与微内核</h2><p>宏内核：所有基本的操作系统服务（如进程管理、内存管理、文件系统、设备驱动等）都运行在内核空间。xv6是一个宏内核。</p>
<p>微内核：只包括最基本的操作系统服务，如进程管理、内存管理和进程间通信（IPC）。其他服务（如文件系统、设备驱动、网络协议等）在用户空间运行。</p>
<p>宏内核的设计适合对性能要求较高的系统，而微内核则适合对安全性和稳定性要求较高的系统。</p>
<h2 id="代码：xv6-组织"><a href="#代码：xv6-组织" class="headerlink" title="代码：xv6 组织"></a>代码：xv6 组织</h2><p>xv6内核源码在<code>kernel/</code>子目录下。按照模块化的概念，源码被分成了多个文件，模块间的接口在<code>kernel/defs.h</code>中定义。</p>
<table>
<thead>
<tr>
<th><strong>文件</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>bio.c</strong></td>
<td>文件系统的磁盘块缓存</td>
</tr>
<tr>
<td><strong>console.c</strong></td>
<td>连接到用户的键盘和屏幕</td>
</tr>
<tr>
<td><strong>entry.S</strong></td>
<td>首次启动指令</td>
</tr>
<tr>
<td><strong>exec.c</strong></td>
<td><code>exec()</code>系统调用</td>
</tr>
<tr>
<td><strong>file.c</strong></td>
<td>文件描述符支持</td>
</tr>
<tr>
<td><strong>fs.c</strong></td>
<td>文件系统</td>
</tr>
<tr>
<td><strong>kalloc.c</strong></td>
<td>物理页面分配器</td>
</tr>
<tr>
<td><strong>kernelvec.S</strong></td>
<td>处理来自内核的陷入指令以及计时器中断</td>
</tr>
<tr>
<td><strong>log.c</strong></td>
<td>文件系统日志记录以及崩溃修复</td>
</tr>
<tr>
<td><strong>main.c</strong></td>
<td>在启动过程中控制其他模块初始化</td>
</tr>
<tr>
<td><strong>pipe.c</strong></td>
<td>管道</td>
</tr>
<tr>
<td><strong>plic.c</strong></td>
<td>RISC-V中断控制器</td>
</tr>
<tr>
<td><strong>printf.c</strong></td>
<td>格式化输出到控制台</td>
</tr>
<tr>
<td><strong>proc.c</strong></td>
<td>进程和调度</td>
</tr>
<tr>
<td><strong>sleeplock.c</strong></td>
<td>Locks that yield the CPU</td>
</tr>
<tr>
<td><strong>spinlock.c</strong></td>
<td>Locks that don’t yield the CPU.</td>
</tr>
<tr>
<td><strong>start.c</strong></td>
<td>早期机器模式启动代码</td>
</tr>
<tr>
<td><strong>string.c</strong></td>
<td>字符串和字节数组库</td>
</tr>
<tr>
<td><strong>swtch.c</strong></td>
<td>线程切换</td>
</tr>
<tr>
<td><strong>syscall.c</strong></td>
<td>调度系统调用处理函数</td>
</tr>
<tr>
<td><strong>sysfile.c</strong></td>
<td>文件相关的系统调用</td>
</tr>
<tr>
<td><strong>sysproc.c</strong></td>
<td>进程相关的系统调用</td>
</tr>
<tr>
<td><strong>trampoline.S</strong></td>
<td>用于在用户和内核之间切换的汇编代码</td>
</tr>
<tr>
<td><strong>trap.c</strong></td>
<td>对陷入指令和中断进行处理并返回的C代码</td>
</tr>
<tr>
<td><strong>uart.c</strong></td>
<td>串口控制台设备驱动程序</td>
</tr>
<tr>
<td><strong>virtio_disk.c</strong></td>
<td>磁盘设备驱动程序</td>
</tr>
<tr>
<td><strong>vm.c</strong></td>
<td>管理页表和地址空间</td>
</tr>
</tbody></table>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>xv6中的隔离单位是一个进程。进程抽象可以防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等，它还可以防止进程破坏内核。</p>
<p>为了帮助实施隔离，进程抽象为程序提供了一种错觉。一个进程为程序提供了一个看似私有的内存系统（地址空间）。进程还为程序提供了看似私有的CPU，用来执行程序的指令。</p>
<p>xv6为每个进程维护一个单独的页表，用于定义该进程的地址空间。如下图所示，进程的用户空间内存的地址空间是从虚拟地址0开始的，依次是指令、全局变量、栈、堆区。RISC-V上的指针是64位宽；硬件在页表中查找虚拟地址时只使用低的39位；xv6只使用39位中的38位。因此，最大地址是2^{38}-1&#x3D; 0x3fffffffff，也就是<code>MAXVA</code>（kernel&#x2F;riscv.h:348）。在地址空间的顶端，xv6保留了一页，用于trampoline和映射进程trapframe的页，以便切换到内核。</p>
<img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter2_address_space.jpg" style="zoom:50%;" />

<p>xv6内核为每个进程维护了许多状态，记录在<code>proc</code>结构体(kernel&#x2F;proc.h:86)。一个进程最重要的内核状态是它的页表、内核栈和运行状态。</p>
<ul>
<li><p><code>p-&gt;state</code>表示进程是创建、就绪、运行、等待I&#x2F;O，还是退出。</p>
</li>
<li><p><code>p-&gt;pagetable</code>以RISC-V硬件需要的格式保存进程的页表。进程的页表记录分配给该进程内存的物理页地址。</p>
</li>
<li><p><code>p-&gt;kstack</code>通常指的是一个进程结构体中的内核栈指针。在内核态执行系统调用或处理中断时，内核会使用当前进程的内核栈。</p>
</li>
</ul>
<p>每个进程有两个栈：用户栈和内核栈。当进程在执行用户指令时，只有它的用户栈在被使用，而它的内核栈是空的。当进程进入内核时（因为系统调用或中断），内核代码在进程的内核栈上执行；当进程在内核中时，它的用户栈仍然包含保存的数据，但不被主动使用。进程的线程在用户栈和内核栈中交替执行。内核栈是独立的（并且受到保护，不受用户代码的影响），所以即使一个进程用户栈被破坏了，内核也可以执行。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/01/xv6-riscv-book-chapter1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/01/xv6-riscv-book-chapter1/" class="post-title-link" itemprop="url">xv6-riscv-book-chapter1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-01 14:25:29" itemprop="dateCreated datePublished" datetime="2024-07-01T14:25:29+08:00">2024-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-09 11:09:11" itemprop="dateModified" datetime="2025-01-09T11:09:11+08:00">2025-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章：操作系统接口"><a href="#第一章：操作系统接口" class="headerlink" title="第一章：操作系统接口"></a>第一章：操作系统接口</h1><p>内核（kernel）：一个向其他运行中的程序提供服务的特殊程序。进程（process）：每一个正在运行的程序。每个进程的内存空间中存储自己的指令、数据、栈。指令实现程序的运算，数据是用于运算过程的变量，栈则管理程序的过程调用。一台计算机通常有许多进程，但只有一个内核。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/1.1kernel%20and%20user%20processes%20.png" alt="内核与用户程序"></p>
<p>内核使用CPU提供的硬件保护机制来确保在用户空间中执行的每个进程只能访问自己的内存。内核运行时拥有硬件特权，可以访问这些受到保护的资源，而用户程序运行时则没有这些特权。</p>
<p>当一个进程需要使用内核的服务时，它就会调用系统调用(system call)。系统调用会进入内核，让内核执行服务然后返回，所以进程会在用户空间和内核空间之间交替运行。</p>
<h2 id="1-1-进程和内存"><a href="#1-1-进程和内存" class="headerlink" title="1.1 进程和内存"></a>1.1 进程和内存</h2><p>在xv6中，每个进程拥有自己的用户空间内存以及内核空间状态。xv6对进程提供分时特性，即xv6可以切换当前cpu上运行的进程。当一个进程暂时不使用cpu时，xv6会保存它的CPU寄存器（代表了进程的状态），在下次运行该进程时恢复它们。对被切换的进程来说好像时自己独占了cpu。内核为每个进程关联一个进程描述符PID(process identifier)，用于唯一标识进程。</p>
<ul>
<li><p><code>fork</code>：形式：<code>int fork()</code>。调用<code>fork</code>的进程称为父进程，新创建的进程称为子进程，子进程的内存内容与父进程完全相同。但子进程不是完全拷贝了父进程，它拥有自己的地址空间、寄存器、程序计数器PC等。<code>fork</code>调用一次，返回两次。在父进程中，<code>fork</code>的返回值是子进程的PID；在子进程中，返回值是0。父、子进程时并发运行的独立进程，内核能够以任意方式交替运行。</p>
</li>
<li><p><code>exit</code>：形式：<code>int exit(int status)</code>。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数status，0代表以正常状态退出，1代表以非正常状态退出。</p>
</li>
<li><p><code>wait</code>：形式：<code>int wait(int *status)</code>。调用进程会被挂起，直到<code>wait</code>返回。等待子进程退出，返回子进程PID，将子进程的退出状态存储到<code>int *status</code>这个地址中。如果调用者没有子进程，<code>wait</code>将返回-1。如果父进程不关心子进程的退出状态，可以传递一个0地址给wait。</p>
</li>
<li><p><code>exec</code>：形式：<code>int exec(char *file, char *argv[])</code>。从可执行程序中加载代码和静态数据，并重新初始化进程内存空间。然后执行该程序，参数通过<code>argv</code>传递给该进程。因此<code>exec</code>并没有创建新的进程，只是将当前运行的程序替换为不同的程序。如果执行错误返回-1，执行成功则不会返回。文件必须是ELF格式。<code>exec</code>系统调用会保留当前的文件描述符表单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码会执行&#x2F;bin&#x2F;echo程序，并将argv数组作为参数。注意参数数组<code>argv</code>的第一个元素是程序名称。由于<code>exec</code>并不会返回，所以printf(“exec error\n”);&#96;并不会执行。</p>
</li>
</ul>
<p>这种分离<code>fork</code>和<code>exec</code>的做法在构建shell时非常有用，在这两个调用之间，shell有机会重定向子进程的I&#x2F;O，而不干扰父进程的I&#x2F;O设置。</p>
<h2 id="1-2-I-O和文件描述符"><a href="#1-2-I-O和文件描述符" class="headerlink" title="1.2 I&#x2F;O和文件描述符"></a>1.2 I&#x2F;O和文件描述符</h2><p>文件描述符是一个小整数（非负数），代表一个可由进程读取或写入的内核管理对象。文件描述符用于指代被打开的文件，所有执行I&#x2F;O操作的系统调用都通过文件描述符来实现。</p>
<p>在内部，xv6内核为每一个进程单独维护一个以文件描述符为索引的表（进程级的文件打开表）。按照约定，一个进程从文件描述符0(标准输入)读取数据，向文件描述符1(标准输出)写入输出，向文件描述符2(标准错误)写入错误信息。shell确保自己总是有三个文件描述符打开。</p>
<ul>
<li><p><code>read</code>和<code>write</code>：形式<code>int write(int fd, char *buf, int n)</code>和<code>int read(int fd, char *buf, int n)</code>。从（向）文件描述符<code>fd</code>处读（写）n个字节<code>buf</code>的内容，返回值是成功读取（写入）的字节数。每个文件描述符有一个offset，<code>read</code>会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个<code>read</code>将从新的offset开始读取字节。<code>write</code>也有类似的offset。</p>
</li>
<li><p><code>close</code>：形式是<code>int close(int fd)</code>，参数是想要关闭文件的文件描述符<code>fd</code>。文件关闭后，该文件描述符可以被重新使用，新分配的文件描述符总是当前进程中最小的未使用描述符。</p>
<p>文件描述符和fork相互作用，使I&#x2F;O重定向易于实现。<code>fork</code>将父进程的文件描述符表和它的内存一起复制，这样子进程开始时打开的文件和父进程完全一样。<code>exec</code>替换调用进程的内存，但会保留文件描述符表。下面是shell运行<code>cat &lt; input.txt</code>命令的简化版代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      close(<span class="number">0</span>);  <span class="comment">// 释放标准输入的文件描述符</span></span><br><span class="line">      open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);  <span class="comment">// fd = 0被重新分配，这时input.txt的文件描述符为0</span></span><br><span class="line">      <span class="comment">// 即标准输入为input.txt</span></span><br><span class="line">      exec(<span class="string">&quot;cat&quot;</span>, argv);  <span class="comment">// cat从0读取，并输出到1，见上个代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子进程关闭文件描述符0后，此时0将是最小的可用文件描述符，新打开的input.txt就使用该文件描述符0。如果 cat 没有给出任何参数，它会从标准输入0读入数据，在上例中cat就从input.txt中读取字符。这不会改变父进程的文件描述符表，它只会修改子进程的描述符表，但是文件中的offset将被共享。</p>
</li>
<li><p><code>dup</code>：形式是<code>int dup(int fd)</code>，复制一个现有的文件描述符fd，返回一个新的描述符，它们指向同一个底层I&#x2F;O对象。两个I&#x2F;O对象(文件)的偏移量offset相同。</p>
<p>如果两个文件描述符是通过一系列的<code>fork</code>和<code>dup</code>调用从同一个原始文件描述符衍生出来的，那么这两个文件描述符共享一个偏移量。否则，文件描述符不共享偏移量。</p>
</li>
</ul>
<h2 id="1-3-管道"><a href="#1-3-管道" class="headerlink" title="1.3 管道"></a>1.3 管道</h2><p>管道（pipes）是一个小的内核缓冲区，作为一对文件描述符提供给进程，一个用于读，一个用于写。将数据写入管道的一端就可以从管道的另一端读取数据。管道在内核空间中实现，为进程提供了一种通信方式。</p>
<p><code>pipe</code>是一个system call，形式为<code>int pipe(int p[])</code>，参数<code>p[]</code>是一个大小为 2 的整数数组，用于接收创建的文件描述符。<code>p[0]</code>为读取的文件描述符，<code>p[1]</code>为写入的文件描述符。管道中的数据只能被读一次。</p>
<p>下面的示例代码运行程序wc，标准输入连接到管道的读取端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>);  <span class="comment">// 释放子进程中的文件描述符0</span></span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// 复制一个p[0](管道读端)，此后文件描述符0（标准输入）也引用管道读端</span></span><br><span class="line">    close(p[<span class="number">0</span>]); <span class="comment">// 关闭子进程中的管道读端</span></span><br><span class="line">    close(p[<span class="number">1</span>]); <span class="comment">// 如果不关闭p[1]写端，管道的读端会一直等待读取，wc就永远也无法等到EOF</span></span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv); <span class="comment">// wc 从标准输入读取数据，并写入到参数中的每// 一个文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有管道中暂时没有数据可读，管道上的<code>read</code>操作会等待数据被写入，或者等待所有指向写端的文件描述符被关闭；在后一种情况下，读操作将返回0。如果没有数据写入，读操作会无限阻塞，直到新数据不可能到达为止（写端被关闭），这也是子进程在执行上面的wc之前关闭管道的写端很重要的一个原因：如果wc的一个文件描述符仍然引用了管道的写端，那么wc将永远看不到文件的关闭（被自己阻塞）。</p>
<p>xv6的shell实现了管道，如下，shell的实现类似于上面的代码（user&#x2F;sh.c:100）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep fork sh.c | wc -l</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/sh.c:100</span></span><br><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">  pcmd = (*<span class="keyword">struct</span>* pipecmd*)*cmd*;</span><br><span class="line">  <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">   panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">   close(<span class="number">1</span>);</span><br><span class="line">   dup(p[<span class="number">1</span>]);</span><br><span class="line">   close(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">1</span>]);</span><br><span class="line">   runcmd(pcmd-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">   close(<span class="number">0</span>);</span><br><span class="line">   dup(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">1</span>]);</span><br><span class="line">   runcmd(pcmd-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  close(p[<span class="number">0</span>]);</span><br><span class="line">  close(p[<span class="number">1</span>]);</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h1 id="1-4-文件系统"><a href="#1-4-文件系统" class="headerlink" title="1.4 文件系统"></a>1.4 文件系统</h1><p>xv6文件系统包含了文件（byte arrays）和目录（对其他文件和目录的引用）。目录生成了一个树，树从根目录<code>/</code>开始。对于不以<code>/</code>开头的路径，认为是是相对路径。</p>
<ul>
<li><code>chdir</code>：形式：<code>int chdir(const char *path)</code>。使得当前进程的工作目录更改为指定路径名 <code>path</code> 所指向的目录。</li>
<li><code>mkdir</code>：形式：<code>int mkdir(char *dir)</code>。在文件系统中创建新目录。</li>
</ul>
<ul>
<li><code>mknod</code>：形式：<code>int mknod(char *file, int, int)</code>。创建设备文件，一个设备文件有一个主要设备号（major device #）和一个次要设备号（minor device #）用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将<code>read</code>和<code>write</code>的system call重新定向到设备上。</li>
</ul>
<p>文件控制块（FCB）是用来存放控制文件所需的各种信息的数据结构，FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。<strong>FCB &#x3D; 文件名称 + 索引节点指针</strong>。 索引节点中存放文件的元数据，包括文件类型（文件或目录或设备），文件长度，文件内容在磁盘上的位置，以及文件的链接数量。</p>
<p>文件名称与文件是不同的；底层文件（非磁盘上的文件）被称为<strong>inode</strong>，一个inode可以有多个名称，称为<strong>链接</strong>。每个链接由目录中的一个项组成；该项包含一个文件名和对inode的引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory entry</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;        <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];  <span class="comment">// file or directory name</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File metadata information</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>stat</code>：形式：<code>int stat(char *path, struct stat *st)</code>。用于指定文件的元数据，并将信息存储在 <code>struct stat</code> 类型的变量 <code>st</code> 中。</li>
<li><code>fstat</code>：形式：<code>int fstat(int fd, struct stat *st)</code>。用于获取与文件描述符 <code>fd</code> 关联的文件的元数据，并将信息存储在 <code>struct stat</code> 类型的变量 <code>st</code> 中。</li>
<li><code>link</code>将创建一个指向同一个inode的文件名。<code>unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除。</li>
</ul>
<p>Unix提供了shell可调用的文件操作程序，作为用户级程序，例如<strong>mkdir</strong>、<strong>ln</strong>和<strong>rm</strong>。这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。现在看来，这个设计似乎是显而易见的，但在Unix时期设计的其他系统通常将这类命令内置到shell中（并将shell内置到内核中）。</p>
<p>有一个例外，那就是cd，它是在shell中实现的 (user&#x2F;sh.c:160)。cd 必须改变 shell 自身的当前工作目录。如果cd作为一个普通命令执行，那么shell就会fork一个子进程，而子进程会运行cd，cd只会改变子进程的当前工作目录。父进程（即shell）的工作目录则保持不变。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/10/6-S081-Lab1-Xv6-and-Unix-utilities/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/10/6-S081-Lab1-Xv6-and-Unix-utilities/" class="post-title-link" itemprop="url">6.S081-Lab1-Xv6 and Unix utilities</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-10 00:28:36" itemprop="dateCreated datePublished" datetime="2024-06-10T00:28:36+08:00">2024-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-03 20:58:47" itemprop="dateModified" datetime="2025-01-03T20:58:47+08:00">2025-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>利用系统调用<code>sleep</code>实现指定tick的时间休眠。如果用户忘记传递参数，sleep 程序要打印错误信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep number_of_ticks\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  number = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;(nothing happens for a little while)\n&quot;</span>);</span><br><span class="line">  sleep(number);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>利用系统调用<code>fork</code>和<code>pipe</code>在父、子进程中传递信息。父、子进程交互流程：</p>
<ul>
<li><p>父进程应向子进程发送一个字节；</p>
</li>
<li><p>子进程应打印”<pid>: received ping”（<pid>是其进程 ID），并将该字节写入父进程的管道，然后退出；</p>
</li>
<li><p>父进程应从子进程读取该字节，打印”<pid>: received pong”，然后退出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pingpong</span></span><br><span class="line">4: received ping</span><br><span class="line">3: received pong</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>思路：</p>
<ul>
<li>正常情况下<code>fork()</code>过后，父、子进程的并发运行的，执行顺序并不能确定。</li>
<li>要确保先运行父进程，必须要阻塞子进程。子进程要从管道中读取信息，当管道中暂时没有数据可读时，<code>read</code>就会阻塞子进程。</li>
<li>父进程发完信息后，要等待子进程执行结束后再次运行。</li>
<li>注意当管道的端口不再使用后要及时关闭。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> buf[<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  pipe(p);</span><br><span class="line">  <span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    read(p[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    wait(<span class="number">0</span>);  <span class="comment">// waiting for child process to exit; not care about the return </span></span><br><span class="line">    read(p[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, pid);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>质数筛选器：对于一组数，先print出最小的一个数，这是一个素数，然后用其他剩下的数依次尝试整除这个素数，如果可以整除则不是质数，则将其drop，不能整除则将其参与下一轮筛选，直到最后打印出所有的素数。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lab1_primes_filter.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = get a number from left neighbor</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = get a number from left neighbor</span><br><span class="line">    if (p does not divide n)</span><br><span class="line">        send n to right neighbor</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>主进程生成初始数字，子进程递归地负责筛选质数，进程间使用管道传递数字。</li>
<li>内核中可以同时存在的管道数是有限的，当管道的端口不再使用后要及时关闭。</li>
<li>在主进程中要注意等待子进程结束。</li>
</ul>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lab1_primes_filter2.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_INT 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">Filter</span><span class="params">(<span class="type">int</span> pipe_fd[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">  close(pipe_fd[<span class="number">1</span>]);  <span class="comment">// close the write port</span></span><br><span class="line">  <span class="type">int</span> prime;</span><br><span class="line">  <span class="keyword">if</span>(read(pipe_fd[<span class="number">0</span>], &amp;prime, SIZE_INT) != SIZE_INT)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when read the prime number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">int</span> flag = read(pipe_fd[<span class="number">0</span>], &amp;num, SIZE_INT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// There are no more numbers to judge.</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pipe_fd2[<span class="number">2</span>];</span><br><span class="line">  pipe(pipe_fd2);</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">    close(pipe_fd2[<span class="number">0</span>]); <span class="comment">// close the read port</span></span><br><span class="line">    <span class="keyword">if</span>(num % prime != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the num is  a prime</span></span><br><span class="line">      write(pipe_fd2[<span class="number">1</span>], &amp;num, SIZE_INT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(read(pipe_fd[<span class="number">0</span>], &amp;num, SIZE_INT) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(num % prime != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// the num is  a prime</span></span><br><span class="line">        write(pipe_fd2[<span class="number">1</span>], &amp;num, SIZE_INT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd2[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    Filter(pipe_fd2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  pipe(p);</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">    close(p[<span class="number">0</span>]);  <span class="comment">// close the read port</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(write(p[<span class="number">1</span>], &amp;i, SIZE_INT) != SIZE_INT)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when write the number 2-35\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    Filter(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when fork in primes_main\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>一个简单版本的 UNIX find功能，在指定的文件夹下符合某个名字的文件，打印出其路径。</p>
<ul>
<li>首先按照提示阅读<strong>user&#x2F;ls.c</strong>学习如何读取目录，照猫画虎。</li>
</ul>
<ul>
<li>注意检查find命令行中的path参数，要为目录名。</li>
</ul>
<ul>
<li>字符串结尾处要有结束标识符<code>\0</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *target)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The first argument to find must be a directory</span></span><br><span class="line">  <span class="keyword">if</span>(st.type != T_DIR)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: &lt;*directory*&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">  p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">  *p++ = <span class="string">&#x27;/&#x27;</span>; <span class="comment">// now the end is &#x27;/&#x27;, not &#x27;\0&#x27;</span></span><br><span class="line">  <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="comment">// Read one directory entry at a time</span></span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    memmove(p, de.name, DIRSIZ);</span><br><span class="line">    p[DIRSIZ] = <span class="number">0</span>;  <span class="comment">// add the null terminator, \0, to make it a C string.</span></span><br><span class="line">    <span class="comment">// Match successful?</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name, target) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.type == T_DIR)&#123;</span><br><span class="line">      find(buf, target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: %s &lt;directory&gt; &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>实现一个简单版本的 UNIX xargs 程序，从标准输入中读取行，并为每一行运行一个指定的命令，同时将该行作为参数提供给命令。默认每次执行指定的命令时只从标准输入中额外获取一个参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;1\n2&quot;</span> | xargs <span class="built_in">echo</span> line</span></span><br><span class="line">line 1</span><br><span class="line">line 2</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>从标准输入中读取字符，以分隔符为界分割出参数，使用<code>fork</code>和<code>exec</code>执行命令。</li>
<li>ulibs.c中gets()提供类似按行读取的功能。</li>
<li><code>argv[argc] </code>处必须是NULL，用于标识指针数组的结束。字符数组用<code>\0</code>标识结束。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">xargsexec</span><span class="params">(<span class="type">char</span> *argv_xargs[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when xargsexec fork()&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    exec(argv_xargs[<span class="number">0</span>], argv_xargs);</span><br><span class="line">    <span class="comment">// never get there</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when exec()&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: xargs needs three arguments at least\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *argv_xargs[MAXARG];</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">  argv_xargs[<span class="number">0</span>] = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    gets(buf, <span class="number">512</span>); <span class="comment">// Read a line from standard input</span></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123; </span><br><span class="line">      <span class="comment">// There is no more text in the standard input</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// Read the ulib.c/gets(), gets() preserves \n or \r</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; i++)&#123;</span><br><span class="line">      argv_xargs[i] = argv[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    argv_xargs[argc - <span class="number">1</span>] = buf;</span><br><span class="line">    argv_xargs[argc] = (<span class="type">void</span> *)<span class="number">0</span>;  <span class="comment">// add the terminator NULL</span></span><br><span class="line"></span><br><span class="line">    xargsexec(argv_xargs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wnyxvo</p>
  <div class="site-description" itemprop="description">战战兢兢，如履薄冰</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wnyxvo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">79k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:12</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
