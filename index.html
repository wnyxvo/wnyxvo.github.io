<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="战战兢兢，如履薄冰">
<meta property="og:type" content="website">
<meta property="og:title" content="wnyxvo的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="wnyxvo的博客">
<meta property="og:description" content="战战兢兢，如履薄冰">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wnyxvo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>wnyxvo的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wnyxvo的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/6-S081-Lab3-Page-Tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/14/6-S081-Lab3-Page-Tables/" class="post-title-link" itemprop="url">6.S081-Lab3-Page Tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-14 20:42:54" itemprop="dateCreated datePublished" datetime="2024-08-14T20:42:54+08:00">2024-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-20 23:59:50" itemprop="dateModified" datetime="2024-08-20T23:59:50+08:00">2024-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>一些操作系统（如 Linux）通过在用户空间和内核之间共享只读区域中的数据来加快某些系统调用的速度。创建每个进程时，在 USYSCALL（memlayout.h 中定义的一个 VA）处映射一个只读页面。 在该页面的开头，存储一个 struct usyscall（也在 memlayout.h 中定义），并将其初始化以存储当前进程的 PID。 在本实验中，用户空间侧提供了 ugetpid()，它将自动使用 USYSCALL 映射。 </p>
<p>实现：</p>
<ul>
<li><p>从<code>memlayout.h</code>中了解到USYSCALL在用户地址空间中的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建每个进程时完成映射。在<code>kernel/proc.c</code>的<code>proc_pagetable()</code>中学习<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的映射方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map one read-only page at USYSCALL(a VA defined in memlayout.h) just below   TRAPFRAME</span></span><br><span class="line"><span class="comment">// to speed up system calls who needs get the the PID of the current process.</span></span><br><span class="line"><span class="comment">// At the start of this page, store a struct usyscall (also defined in memlayout.h),</span></span><br><span class="line"><span class="comment">// and initialize it to store the PID of the current process.</span></span><br><span class="line"><span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;usyscallpage), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参照<code>p-&gt;trapframe</code>，需要在<code>proc</code>结构体中定义<code>usyscallpage</code>用于存放<code>struct usyscall</code>的地址，实际上就是<code>USYSCALL</code>的物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usyscallpage</span>;</span> <span class="comment">// Shared with kernel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个进程时的工作。在<code>kernel/proc.c</code>的<code>allocproc()</code>中为<code>USYSCALL</code>分配一个物理页空间。同时将当前进程的<code>pid</code>存放到<code>USYSCALL</code>页中的<code>usyscall</code>结构体中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a USYSCALL page.</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;usyscallpage = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;usyscallpage-&gt;pid = p-&gt;pid;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁一个进程时的工作。在<code>kernel/proc.c</code>的<code>freeproc()</code>中释放<code>USYSCALL</code>页空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;usyscallpage)</span><br><span class="line">  kfree((<span class="type">void</span>*)p-&gt;usyscallpage);</span><br><span class="line">p-&gt;usyscallpage = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此刻完成之后，运行 qemu 会 <code>panic</code> 错误。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">panic: freewalk: leaf</span><br></pre></td></tr></table></figure>

<p><code>panic: freewalk: leaf</code> 错误通常表示系统在页表管理过程中遇到了页表结构的损坏或误操作。这是因为在 <code>pagetable</code> 中任然存在我们之前的 PTE 映射。我们需要在 <code>kernel/proc.c</code> 的 <code>proc_freepagetable()</code> 中对其取消映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>编写一个可以打印页表内容的函数，定义一个名为 vmprint() 的函数。 它应该接受一个 pagetable_t 参数，并按照下面描述的格式打印该页表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line"> ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line"> .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line"> .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line"> .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line"> .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line"> ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line"> .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line"> .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000</span><br><span class="line"> .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000</span><br><span class="line"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>

<p> 在<code> exec.c</code> 中<code>return argc</code> 之前插入 <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，以打印第一个进程的页表。 </p>
<p>实现：</p>
<ul>
<li><p>按照提示参考<code>freewalk()</code>的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// A read/write/execute permission of 0 means it points to the next level of the page table.</span></span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      <span class="comment">// This is an intermediate page table, recursively released.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">// At least one of the read/write/execute permissions is 1, indicating that it points to physical memory.</span></span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：如何遍历页表、如何区分第三级页表的PTE(更高级别PTE中FLAG中没有RWX权限)。</p>
</li>
<li><p>关于打印格式中要注意，不同级别中PTE前面的<code> ..</code>不一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, uint16 level)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= level; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);     </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, (uint64)pte, child);</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        level++;</span><br><span class="line">        _vmprint((<span class="type">pagetable_t</span>)child, level);</span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, (uint64)pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>freewalk()</code>需要释放页表，所以要有<code>pagetable[i] = 0</code>，<code>_vmprint</code>中不能出现，否则会清空页表中的页表项，导致程序无法继续运行。</p>
</li>
</ul>
<h2 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h2><p>实现<code> pgaccess()</code>系统调用，用于报告哪些页面已被访问。系统调用需要三个参数。首先，它需要第一个要检查的用户页面的起始虚拟地址。其次，它接受要检查的页面数。最后，它需要一个缓冲区的用户地址，以便将结果存储到位掩码（一种数据结构，每页使用一位，其中第一页对应的是最小有效位）中。</p>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 baseaddr;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  uint64 maskbits = <span class="number">0</span>;</span><br><span class="line">  uint64 maskaddr;</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;baseaddr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">2</span>, &amp;maskaddr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va = PGROUNDDOWN(baseaddr);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    pte = walk(pagetable, va, <span class="number">1</span>);</span><br><span class="line">    va += PGSIZE;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_A)&#123;</span><br><span class="line">      maskbits |= (<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">      *pte &amp;= ~PTE_A;  <span class="comment">// clear PTE_A after checking if it is set.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, maskaddr, (<span class="type">char</span>*)&amp;maskbits, <span class="keyword">sizeof</span>(maskbits)) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;sys_pgacess copyout error&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>PTE_A</code>需要在<code>riscv.h</code>中设置；<code>walk()</code>需要在<code>defs.h</code>中声明。</p>
</li>
<li><p>获取<code>pagetable</code>时，下面的写法执行会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint64 x;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, satp&quot;</span> : <span class="string">&quot;=r&quot;</span> (x))</span>; </span><br><span class="line"><span class="type">pagetable_t</span> pagetable = (<span class="type">pagetable_t</span>)(x &amp; ~((uint64)<span class="number">0xfff</span>)); <span class="comment">// 去掉低12位</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="bug-Unresolved"><a href="#bug-Unresolved" class="headerlink" title="bug(Unresolved )"></a>bug(Unresolved )</h2><p><code>make grade</code>时<code>usertest</code>测试有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">== Test   usertests: all tests ==</span><br><span class="line">  usertests: all tests: FAIL</span><br><span class="line">    ...</span><br><span class="line">         test createdelete: OK</span><br><span class="line">         test linkunlink: OK</span><br><span class="line">         test linktest: OK</span><br><span class="line">         test unlinkread: OK</span><br><span class="line">         test concreate: qemu-system-riscv64: terminating on signal 15 from pid 19225 (make)</span><br><span class="line">    MISSING &#x27;^ALL TESTS PASSED$&#x27;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/24/6-S081-Leature-4-Page-tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/24/6-S081-Leature-4-Page-tables/" class="post-title-link" itemprop="url">6.S081-Leature 4 Page tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-24 22:55:27" itemprop="dateCreated datePublished" datetime="2024-07-24T22:55:27+08:00">2024-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-20 23:53:38" itemprop="dateModified" datetime="2024-08-20T23:53:38+08:00">2024-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>RISC-V 指令（包括用户和内核）操作的是虚拟地址。机器的 RAM，或者说物理内存，是用物理地址来做索引的。RISC-V的页表硬件通过将每个虚拟地址映射到（转换成）一个物理地址。</p>
<p> 由虚拟地址转换为物理地址是在处理器中的<strong>内存管理单元（Memory Management Unit, MMU）</strong>中完成的。将MMU视为一个“黑箱”，输入VP，输出PP。注意，<strong>页表保存在内存中</strong>，MMU只是会去查看页表。</p>
<p>xv6运行在Sv39 RISC-V上，这意味着只会使用64位虚拟地址的低39位，高25位没有被使用。可使用的低39位中的低12位为页内偏移地址<code>offset</code>，可以得知页大小为2^12B（4096B）；剩余的27位为页表的索引项<code>index</code>（或者称低12位为<strong>虚拟页偏移VPO</strong>，称剩余的27位为<strong>虚拟页号VPN</strong>）。</p>
<p>在这种Sv39配置中，一个RISC-V页表在逻辑上是一个由2^27（134,217,728）个<strong>页表项（Page Table Entry, PTE）</strong>组成的数组。每个PTE包含一个44位的<strong>物理页号（Physical Page Number, PPN）</strong>和一些标志位。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_pagework.jpg"></p>
<p>分页硬件通过利用39位中的高27位索引到页表中找到一个PTE来转换一个虚拟地址，并计算出一个56位的物理地址，它的前44位来自于PTE中的PPN，而它的后12位则是从原来的虚拟地址复制过来的。在逻辑上可以把页表看成是一个简单的PTE数组。</p>
<p>在Sv39 RISC-V中，虚拟地址的高25位不用于地址转换；将来RISC-V可能会使用这些位来定义更多的转换层。物理地址也有增长的空间：在PTE格式中，物理页号还有 10 位的增长空间。</p>
<p>VPN转换成PPN的实际过程分三步进行。一个页表以三层树的形式存储在物理内存中，多级页表。树的根部是一个 4096 字节的页表页，它包含 512 个 PTE，这些 PTE 包含树的下一级页表页的物理地址。每一页都包含 512 个 PTE，用于指向下一个页表或物理地址。分页硬件用 27 位中的高 9 位选择<strong>根页表页</strong>中的 PTE，用中间 9 位选择树中下一级页表页中的 PTE，用低 9 位选择最后的 PTE。根页表页的基地址存放在<code>satp</code>寄存器中。<code>satp</code>寄存器包含了还一些控制位，用于配置地址转换和保护机制。</p>
<p>页表页存放在单独的页中，每个页表页都包含 512 个 PTE，512*64bit&#x3D;4096B。</p>
<p>每个进程都有自己独立的页表，这个页表定义了进程的地址空间。所以当操作系统将CPU从一个进程切换到另一个进程时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应页表。写SATP寄存器是一条特权指令。</p>
<p>如果转换一个地址所需的三个 PTE 中的任何一个不存在，分页硬件就会引发一个<strong>缺页异常（page-fault exception）</strong>，让内核来处理这个异常。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_riscv_address_translation.jpg"></p>
<p>每个 PTE 都包含标志位，用于告诉分页硬件相关的虚拟地址被允许怎样使用。</p>
<ul>
<li><code>PTE_V</code> 表示 PTE 是否存在：如果Valid bit位为1，那么表明这是一条合法的PTE，可以用它来做地址翻译。如果没有设置（Valid bit位为0），对该页的引用会引起缺页异常。</li>
<li><code>PTE_R</code> 控制是否允许指令读取该页；<code>PTE_W</code> 控制是否允许指令向该页写入。</li>
<li><code>PTE_X</code> 控制 CPU 是否可以将页面的内容解释为指令并执行。</li>
<li><code>PTE_U</code> 控制是否允许用户态下的指令访问页面；如果不设置 <code>PTE_U</code>， 对应 PTE 只能在内核态下使用。</li>
</ul>
<p>标志位和与分页硬件相关的数据结构定义在（<code>kernel/riscv.h</code>）中。</p>
<h2 id="页表缓存TLB"><a href="#页表缓存TLB" class="headerlink" title="页表缓存TLB"></a>页表缓存TLB</h2><p>如果回想一下虚拟地址转换成物理地址的过程，基本上都要做3次内存查找，第一次在最高级的page directory，第二次在中间级的page directory，最后一次在最低级的page directory。所以对于一个虚拟内存地址的寻址，需要读三次内存，代价有点高。</p>
<p>所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的转换结果有缓存。这个缓存被称为<strong>页表缓存（Translation Lookside Buffer, TLB）</strong>。TLB是对PTE的缓存，TLB会保存虚拟地址到物理地址的映射关系。这样访问虚拟地址时，处理器优先查看TLB，若TLB中存在对应的缓存会直接返回物理地址，而不需要通过页表得到结果。若TLB没有对应的缓存，再查看页表。这里用到cache的思想。</p>
<h2 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h2><p>Xv6 为每个进程维护一个用于描述进程的用户地址空间的页表，外加一个单独的描述内核地址空间的页表。</p>
<p>内核配置其地址空间的布局，使其能够通过可预测的虚拟地址访问物理内存和各种硬件资源。下图显示了这个设计是如何将内核虚拟地址映射到物理地址的。文件（<code>kernel/memlayout.h</code>）声明了 xv6 内核内存布局的常量。</p>
<p>图中左边是内核的虚拟地址空间，右边上半部分是物理内存（DRAM），右边下半部分是I&#x2F;O设备。图中的右半部分的结构完全由主板硬件设计者决定，如果得到的物理地址大于<code>0x80000000</code>会走向DRAM芯片，如果得到的物理地址低于<code>0x80000000</code>会流向不同的I&#x2F;O设备。在图中，I&#x2F;O设备是与DRAM统一编址的。</p>
<p>CPU只是主板的一小部分，DRAM芯片位于处理器之外。是主板设计者将处理器，DRAM和许多I&#x2F;O设备汇总在一起。对于一个操作系统来说，CPU只是一个部分，I&#x2F;O设备同样也很重要。所以当你在写一个操作系统时，你需要同时处理CPU和I&#x2F;O设备。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_address_mapped.png"></p>
<p>回到上图的右侧，可以看到最下面是未被使用的地址。地址0x1000是boot ROM的物理地址，当主板上电时，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址<code>0x80000000</code>，操作系统需要确保那个地址有一些数据能够接着启动操作系统。</p>
<p>这里还有一些其他的I&#x2F;O设备：</p>
<ul>
<li>PLIC是中断控制器（Platform-Level Interrupt Controller）。</li>
<li>CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数。</li>
<li>UART0（Universal Asynchronous Receiver&#x2F;Transmitter）负责与Console和显示器交互。</li>
<li>VIRTIO disk，与磁盘进行交互。</li>
</ul>
<p>回到上图的左侧，这就是xv6的虚拟内存地址空间。当机器刚刚启动时，还没有可用的页，xv6操作系统会设置好内核使用的虚拟地址空间，也就是这张图左边的地址分布。虚拟内存从物理地址 <code>0x80000000</code> 开始， 到 <code>0x86400000</code>（xv6内存大小为128M），xv6 称之为 <code>PHYSTOP</code>。</p>
<p>因为想让xv6尽可能的简单易懂，内核对RAM和内存映射的设备寄存器使用“直接映射”，也就是将这些资源映射到和它们物理地址相同的虚拟地址上。例如，内核本身在虚拟地址空间和物理内存中的位置都是<code>KERNBASE=0x80000000</code>。直接映射简化了读&#x2F;写物理内存的内核代码。例如，当 <code>fork</code> 为子进程分配用户内存时，分配器返回该内存的物理地址；<code>fork</code> 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。</p>
<p>有几个内核虚拟地址不是直接映射：</p>
<ul>
<li><code>trampoline</code>页。它被映射在虚拟地址空间的顶端；用户页表也有这个映射。第 4 章讨论了 trampoline 页的作用，但我们在这里看到了页表的一个有趣的用例；一个物理页（存放 trampoline 代码）在内核的虚拟地址空间中被映射了两次：一次是在虚拟地址空间的顶部，一次是直接映射。可以两个虚拟地址映射到同一个物理地址。</li>
<li>内核栈页。<strong>每个进程都有自己的内核栈</strong>，内核栈被映射到高地址处，所以 xv6 可以在它后面留下一个未映射的保护页。<strong>Guard page（保护页）</strong>是操作系统用于检测和防止程序栈溢出的一种内存管理技术。它是一种特殊的内存页，Guard page对应的PTE的Valid 标志位没有设置，故意将其标记为不可访问，来捕获对该页的访问异常，从而实现栈溢出检测和处理。同时又不想浪费物理内存给Guard page，所以Guard page不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。</li>
</ul>
<p>内核将 trampoline 和 text（可执行程序的代码段）映射为有 <code>PTE_R</code> 和 <code>PTE_X</code> 权限的页。内核从这些页读取和执行指令。内核映射的其他页会有 <code>PTE_R</code> 和 <code>PTE_W</code> 权限，以便内核读写这些页面的内存。保护页的映射是无效的（不设置 <code>PTE_V</code>）。</p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p>为了保证强隔离性，每个程序都运行在自己的地址空间，并且这些地址空间彼此之间相互独立。所以现在我们的问题是如何在一个物理内存上，创建不同的地址空间，因为归根到底，我们使用的还是一堆存放了内存信息的DRAM芯片。</p>
<p>每个进程有一个页表，用于描述进程的用户地址空间，还有一个内核地址空间（所有进程共享这一个描述内核地址空间的页表）。为了让内核使用物理内存和硬件资源，内核需要按照一定的规则排布内核地址空间，以能够确定哪个虚拟地址对应自己需要的硬件资源地址。用户地址空间不需要也不能够知道这个规则，因为用户空间不允许直接访问这些硬件资源。</p>
<p>QEMU会模拟一个从0x80000000开始的RAM，一直到0x86400000。QEMU会将设备接口以控制寄存器的形式暴露给内核，这些控制寄存器在0x80000000以下。kernel对这些设备接口控制寄存器的访问是直接和这些设备而不是RAM进行交互的。</p>
<p>不同的进程页表将用户地址转化为物理内存的不同页，这样每个进程都有私有的用户内存。第二，每个进程都认为自己的内存具有从零开始的连续的虚拟地址，而进程的物理内存可以是不连续的。第三，内核会映射带有 <code>trampoline</code> 代码的页到用户地址空间顶端，因此有一个物理内存页在所有地址空间中都会出现。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_useraddress_space.png"></p>
<p>图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。栈只有一页，图中显示的是由<code>exec</code> 创建的初始内容。位于栈顶部的字符串中包含了命令行中输入的参数和指向他们的指针数组。在下方是允许程序在 <code>main</code> 启动的值，就像函数 <code>main(argc, argv)</code> 是刚刚被调用一样。</p>
<h2 id="Code-creating-an-address-space"><a href="#Code-creating-an-address-space" class="headerlink" title="Code: creating an address space"></a>Code: creating an address space</h2><p>大部分用于操作地址空间和页表的 xv6 代码都在<code>vm.c</code>（<code>kernel/vm.c:1</code>）中。核心数据结构是 <code>pagetable_t</code>，它实际上是一个指向 RISC-V 根页表页的指针；<code>pagetable_t</code>可以是内核页表，也可以是进程的页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br></pre></td></tr></table></figure>

<p>在机器启动时，在启动序列的靠前部分，<code>main</code> 调用 <code>kvminit</code>（<code>kernel/vm.c:22</code>）来创建内核页表。这个调用发生在 xv6 在 RISC-V 启用分页之前，所以地址直接指向物理内存。<code>kvminit</code>中直接调用<code>kvmmake</code>，在<code>kvmmake</code>中首先分配一页物理内存来存放根页表页。然后调用 <code>kvmmap</code> 将内核所需要的硬件资源映射到物理地址。这些资源包括内核的指令和数据，<code>KERNBASE</code> 到 <code>PHYSTOP</code>的物理内存，以及实际上是设备的内存范围。随后调用 <code>proc_mapstacks</code>为每个进程分配一个内核栈，并将其映射到内核虚拟地址空间中。</p>
<ul>
<li><p><code>kvmmap</code>（<code>kernel/vm.c:118</code>）调用 <code>mappages</code>（<code>kernel/vm.c:149</code>），它将指定范围的虚拟地址映射到一段物理地址。本质上就是将物理地址转换成虚拟地址格式填入页表项。</p>
</li>
<li><p>虚拟内存中的保护页不会实际映射到物理地址中。由下面的宏可知，连续的两个内核栈地址相差2个<code>PGSIZE</code>，一个内核栈实际只占一个页，剩余的一个页即为保护页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>walk</code>：给定一个虚拟地址和一个页表，返回一个PTE指针。如果 PTE 无效，那么所需的物理页还没有被分配；如果 <code>alloc</code> 参数被设置，<code>walk</code> 会分配一个新的页表页，并把它的物理地址放在 PTE 中。它返回最低层PTE的地址（<code>kernel/vm.c:88</code>）。</p>
</li>
</ul>
<p><code>main</code> 调用 <code>kvminithart</code>（<code>kernel/vm.c:53</code>）来映射内核页表。它将根页表页的物理地址写入寄存器 <code>satp</code> 中。在这之后，CPU 将使用内核页表翻译地址。</p>
<p><code>main</code> 调用<code>procinit</code>（<code>kernel/proc.c:26</code>），为每个进程分配一个内核栈。就是将<code>KSTACK(p)</code> 赋给<code>proc-&gt;kstack</code>。</p>
<p>每个 RISC-V CPU 都会在 **Translation Look-aside Buffer(TLB)**中缓存页表项，当 xv6 改变页表时，必须告诉 CPU 使相应的缓存 TLB 项无效。RISC-V 有一条指令 <code>sfence.vma</code>，可以刷新当前 CPU 的 TLB。xv6 在<code>kvminithart</code>中，重新加载 <code>satp</code> 寄存器后， 执行 <code>sfence.vma</code>，也会在从内核空间返回用户空间前，切换到用户页表的trampoline 代码中执行 <code>sfence.vma</code>（<code>kernel/trampoline.S:79</code>）。</p>
<h2 id="物理内存分配"><a href="#物理内存分配" class="headerlink" title="物理内存分配"></a>物理内存分配</h2><p>xv6对kernel space和<code>PHYSTOP</code>之间的物理空间在运行时进行分配，分配以页(4096 bytes)为单位。分配和释放是通过对空闲页链表进行追踪完成的，分配空间就是将一个页从链表中移除，释放空间就是将一页增加到链表中</p>
<p>kernel的物理空间的分配函数在<code>kernel/kalloc.c</code>中，每个页在链表中的元素是<code>struct run</code>，每个<code>run</code>存储在空闲页本身中。这个空闲页的链表<code>freelist</code>由自旋锁保护，包装在<code>struct kmem</code>中。</p>
<ul>
<li><code>kinit()</code>：对分配函数进行初始化，将kernel结尾到PHYSTOP之间的所有空闲空间都添加到kmem链表中，这是通过调用<code>freerange(end, PHYSTOP)</code>实现的</li>
<li><code>freerange()</code>对这个范围内所有页都调用一次<code>kfree</code>来将这个范围内的页添加到<code>freelist</code>链表中</li>
</ul>
<h2 id="Code-sbrk"><a href="#Code-sbrk" class="headerlink" title="Code: sbrk"></a>Code: sbrk</h2><p><code>sbrk</code> 是 一 个 进 程 收 缩 或 增 长 内 存 的 系 统 调 用 。 该 系 统 调 用 由 函 数<code>growproc</code>（<code>kernel/proc.c:239</code>）实现，<code>growproc</code> 调用 <code>uvmalloc</code> 或 <code>uvmdealloc</code>，取决于 <code>n</code> 是正数还是负数。<code>uvmalloc</code>（<code>kernel/vm.c:229</code>）通过 <code>kalloc</code> 分配物理内存，并使用 <code>mappages</code> 将 PTE 添加到用户页表中。 <code>uvmdealloc</code> 调用 <code>uvmunmap</code>（<code>kernel/vm.c:174</code>），它使用 <code>walk</code> 来查找 PTE 并使用 <code>kfree</code> 来释放它们所引用的物理内存。</p>
<p>xv6 使用进程的页表不仅是为了告诉硬件如何映射用户虚拟地址，也是将其作为分配给该进程的物理地址的唯一记录。这就是为什么释放用户内存（<code>uvmunmap</code> 中）需要检查用户页表的原因。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/22/6-S081-Lab2-System-calls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/6-S081-Lab2-System-calls/" class="post-title-link" itemprop="url">6.S081-Lab2-System calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 20:13:02" itemprop="dateCreated datePublished" datetime="2024-07-22T20:13:02+08:00">2024-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-24 20:11:07" itemprop="dateModified" datetime="2024-07-24T20:11:07+08:00">2024-07-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>添加一项系统调用跟踪功能。 创建一个新的系统调用<code>trace</code>来控制跟踪哪个系统调用。<code>trace</code>应该接受一个参数，即一个整数 “掩码”，其位指定要跟踪的系统调用，可以同时追踪多个系统调用。  <code>trace</code>系统调用追踪调用进程及随后派生的任意子进程，但不应影响其他进程。</p>
<p>思路：</p>
<ul>
<li><p><strong>系统调用函数的添加流程：</strong></p>
<ul>
<li><p>声明封装函数，为新的系统调用提供一个简便的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>user/usys.pl</code>注册一个存根，定义<code>ecall</code>到内核态下<code>trace</code>系统调用的入口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.h</span></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...	</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/syscall.h</code>，添加系统调用号（syscall call number）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/syscall.c</code>，添加系统调用外部声明，更新系统调用表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/sysproc.c</code>，实现系统调用<code>trace</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// control trace System Calls</span></span><br><span class="line"><span class="comment">// save the mask fo tracing system calls</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;   <span class="comment">// an integer &quot;mask&quot;, whose bits specify which system calls to trace</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)  <span class="comment">// get the a0 register on the kernel stack</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;syscallnum = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意系统调用<code>trace</code>的实现中只是将要追踪的系统调用（可多个）的mask传递给进程的变量<code>syscallnum</code>，打印内容在<code>syscall</code>中实现。</p>
</li>
</ul>
</li>
<li><p>在<code>kernel/proc.h</code>中结构体<code>proc</code>的定义中添加一个变量来存储要追踪的系统调用的mask。</p>
</li>
<li><p>在<code>kernel/proc.c</code>中的<code>fork()</code>中，添加功能保证<code>trace</code>能追踪子进程中的系统调用情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy system call trace&#x27;s argument</span></span><br><span class="line">  np-&gt;syscallnum = p-&gt;syscallnum;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>kernel/syscall.c</code>中的<code>syscall()</code>来打印<code>trace</code>的追踪情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> *syscallname[<span class="number">22</span>]=&#123;<span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;   <span class="comment">// system call number</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;syscallnum &amp; (<span class="number">1</span> &lt;&lt; num))&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallname[num<span class="number">-1</span>], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在判断当前的系统调用是否被追踪时，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;syscallnum == (<span class="number">1</span> &lt;&lt; num))&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这里判断是否相等只能追踪一个系统调用。再看<code>mask</code>的含义，二进制下<code>00001000</code>表示追踪系统调用3，二进制下<code>00011000</code>表示追踪系统调用3和系统调用4。</p>
</li>
<li><p><code>Timeout! trace children</code>超时怎么办？电脑性能问题，在.gradelib.py&#96;中改变超时判断时间30s为更长时间即可。</p>
</li>
</ul>
<h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>添加一个系统调用<code>sysinfo</code>，它收集有关正在运行的系统的信息。系统调用采用一个参数：一个指向<code>struct sysinfo</code>的指针。内核应该填写这个结构的字段：<code>freemem</code>字段应该设置为空闲内存的字节数，<code>nproc</code>字段应该设置为<code>state</code>字段不为<code>UNUSED</code>的进程数。</p>
<p>思路：</p>
<ul>
<li><p>按照系统调用函数的添加流程，添加系统调用。</p>
</li>
<li><p>在<code>kernel/kalloc.c</code>实现计算空闲内存的字节数的函数。查看该文件，系统的内存是<strong>按页分配</strong>空闲的，只要计算出空闲页数即可。系统中有空闲页链表<code>kmem.freelist</code>来记录空闲页，遍历空闲页链表即可得空闲页数。注意在访问<code>kmem</code>时要保证互斥，加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the number of bytes of free memory</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kgetfreemem</span><span class="params">(uint64 *freemem)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 freepage = <span class="number">0</span>;   <span class="comment">// the num of free page</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">p</span>;</span>    <span class="comment">// working pointer, is used to traverse the freelist</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  p = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(p)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    freepage++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  *freemem = freepage * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/proc.c</code>中实现计算<code>state</code>字段不为<code>UNUSED</code>的进程数的功能。查看该文件，系统中有一个<code>proc</code>结构体数组用于管理进程，遍历该数组分别查看<code>proc-&gt;state</code>即可。函数书写风格源于该文件下其他函数的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collect the number of processes.</span></span><br><span class="line"><span class="comment">// Traverse the process table, looking for processes with a statu of not UNUSED.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">collectproc</span><span class="params">(uint64 *nproc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> freeprocnum = <span class="number">0</span>;  <span class="comment">// the number of free proc</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      freeprocnum++;</span><br><span class="line">    &#125;</span><br><span class="line">     release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *nproc = NPROC - freeprocnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/sysproc.c</code>中实现系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 infopointer;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  kgetfreemem(&amp;info.freemem);</span><br><span class="line">  collectproc(&amp;info.nproc);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;infopointer) &lt; <span class="number">0</span>)  <span class="comment">// get the a0 register on the kernel stack</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                     <span class="comment">// a0 register sacves a pointer to a struct sysinfo</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, infopointer, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意要在<code>sysproc.c</code>中添加头文件<code>sysinfo.h</code>；在<code>defs.h</code>中添加<code>kgetfreemem()</code>和<code>collectproc()</code>的函数声明。</p>
</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/22/6-S081-xv6%E5%9C%A8qemu%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/6-S081-xv6%E5%9C%A8qemu%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">6.S081-xv6在qemu中的启动过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-22 10:56:00 / 修改时间：16:40:56" itemprop="dateCreated datePublished" datetime="2024-07-22T10:56:00+08:00">2024-07-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Make-qemu-推导"><a href="#Make-qemu-推导" class="headerlink" title="Make qemu 推导"></a>Make qemu 推导</h2><p>参看 Makefile 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu: $K/kernel fs.img</span><br><span class="line">    $(QEMU) $(QEMUOPTS)</span><br></pre></td></tr></table></figure>

<p>目标 <code>kernel</code> 和 <code>fs.img</code> 存在且最新，执行 <code>$(QEMU) $(QEMUOPTS)</code> ，即 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -bios none \</span><br><span class="line">    -kernel kernel/kernel \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -smp 3 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -global virtio-mmio.force-legacy=false \</span><br><span class="line">    -drive file=fs.img,if=none,format=raw,id=x0 \</span><br><span class="line">    -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>qemu-system-riscv64</code>：启动 QEMU 的命令，模拟一台 64 位 RISC-V 架构的计算机。</li>
<li><code>-machine virt</code>：指定要模拟的虚拟机硬件的机器类型为 virt。</li>
<li><code>-bios none</code>：不使用 BIOS，因为 RISC-V 架构通常不需要 BIOS。</li>
<li><code>-kernel kernel/kernel</code>：指定要加载的内核映像文件路径。</li>
<li><code>-m 128M</code>：指定虚拟机的内存大小为128MB。</li>
<li><code>-smp 3</code>：指定虚拟机的 CPU 核心数量为3个。</li>
<li><code>-nographic</code>：以无图形界面模式运行虚拟机，所有输出将会通过终端输出。</li>
<li><code>-global virtio-mmio.force-legacy=false</code>：设置 virtio-mmio 设备为非遗留模式。在虚拟化环境中，virtio 是一种用于虚拟机和宿主机之间通信的设备标准。virtio-mmio 是一种 virtio 设备的接口规范，用于在内存映射 I&#x2F;O（MMIO）方式下与虚拟机进行通信。通过在 QEMU 中启用非遗留模式的 virtio-mmio 设备，可以提高设备的性能和功能。</li>
<li><code>-drive file=fs.img,if=none,format=raw,id=x0</code>：添加一个虚拟硬盘设备，并指定硬盘镜像文件为 “fs.img”。</li>
<li><code>-device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</code>：添加一个 virtio 块设备，并将之前创建的虚拟硬盘设备连接到其中。</li>
</ul>
<h2 id="Qemu-启动"><a href="#Qemu-启动" class="headerlink" title="Qemu 启动"></a>Qemu 启动</h2><p>在 QEMU 模拟的 virt 硬件平台上，物理内存的起始物理地址通常为0x80000000（即2GB）。由于使用了 <code>-m 128M</code> 选项进行配置，虚拟机 128MB 大小的内存对应物理地址区间为 <code>[0x80000000,0x88000000)</code> 。如果使用上面给出的命令启动 QEMU ，那么在 QEMU 开始执行任何指令之前，会将内核镜像文件 <code>kernel/kernel</code>加载到物理内存 <code>0x80000000</code> 上，<code>0x80000000</code> 这个位置是 QEMU 本身设置的[<a target="_blank" rel="noopener" href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c">https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c</a>]。</p>
<p>将必要的文件载入到 QEMU 物理内存之后，QEMU CPU 的程序计数器 PC 会被初始化为 <code>0x1000</code> ，因此 QEMU 实际执行的第一条指令位于物理地址 <code>0x1000</code> ，接下来它将执行数条指令并跳转到物理地址 <code>0x80000000</code> 。</p>
<p>启动QEMU，并打开gdb，<code>CPUS=1</code>单核启动便于调试。本质上来说 QEMU 内部有一个 gdb server，当我们启动之后，QEMU 会等待 gdb 客户端连接。运行 <code>gdb-multiarch</code>再启动一个gdb客户端，会出现一个警告，按照提示处理即可。可见 PC 确实被初始化为 <code>0x1000</code>。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu1.PNG"></p>
<p>运行 <code>layout asm</code> 命令，查看汇编指令，就是这几条指令控制程序转到物理地址 <code>0x80000000</code> 。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu2.PNG"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x1000 auipc t0,0x0      ; t0 = PC + (0x0 &lt;&lt; 12) = 0x1000</span><br><span class="line">0x1004 addi  a2,t0,40    ; a2 = t0 + 40 = 0x1028</span><br><span class="line">0x1008 csrr  a0,mhartid  ; 将硬件寄存器 mhartid 的值（当前硬件线程 ID 为 0）存入寄存器 a0 中。</span><br><span class="line">0x100c ld    a1,32(t0)   ; a1 = (0x1000 + 32) = (0x1020) = 0x87000000</span><br><span class="line">0x1010 ld    t0,24(t0)   ; t0 = (0x1000 + 24) = (0x1018) = 0x80000000</span><br><span class="line">0x1014 jr    t0          ; PC = t0，跳转到寄存器 t0 中保存的地址</span><br></pre></td></tr></table></figure>

<p>RISC-V 架构通常使用小端（Little Endian）字节序来存储数据。在小端字节序中，最低有效字节（Least Significant Byte，LSB）存储在地址的最低字节处，而最高有效字节（Most Significant Byte，MSB）存储在地址的最高字节处。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu3.png"></p>
<p>跳转到 t0 中保存的地址 0x80000000，进入内核的第一条指令，计算机的控制权已经被移交给内核。</p>
<p>地址0x80000000是一个被QEMU认可的地址。也就是说如果你想使用QEMU，那么第一个指令地址必须是它。所以，我们会让内核加载器从那个位置开始加载内核。查看kernel.ld：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * ensure that entry.S / _entry is at 0x80000000,</span></span><br><span class="line"><span class="comment">   * where qemu&#x27;s -kernel jumps.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  . = <span class="number">0x80000000</span>;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h2 id="内核的第一个进程"><a href="#内核的第一个进程" class="headerlink" title="内核的第一个进程"></a>内核的第一个进程</h2><p>xv6内核已被加载到物理地址<code>0x80000000</code>的内存中。在<strong>机器模式</strong>下，CPU从 <code>_entry</code>（kernel&#x2F;entry.S:6）开始执行xv6。RISC-V在禁用分页硬件的情况下启动：虚拟地址直接映射到物理地址。</p>
<p>之所以将内核放在<code>0x80000000</code>而不是<code>0x0</code>，是因为地址范围<code>0x0:0x80000000</code>包含 I&#x2F;O 设备。现代的体系结构大多使用 MMIO(Memory-mapped IO) 的形式，使用相同的地址总线来寻址内存和 I&#x2F;O 设备。当CPU访问某个地址的时候，可能是要访问某一部分物理内存，也可能是要访问I&#x2F;O设备上的内存。</p>
<img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu4.png"/>

<p>在程序的入口处设置一个端点这是QEMU会跳转到的第一个指令。设置完断点之后，运行程序，但并没有停在<code>0x80000000</code>（在<code>kernel.asm</code>中，0x80000000是程序的起始位置），而是停在了<code>0x8000000a</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">######################                entry.S:                ######################   </span><br><span class="line">        # qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each hart (i.e. CPU) to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096</span><br><span class="line">        la    sp, stack0     ; sp = &amp;stack0</span><br><span class="line">        li    a0, 1024*4     ; a0 = 4096</span><br><span class="line">        csrr  a1, mhartid    ; a1 = mhartid</span><br><span class="line">        addi  a1, a1, 1      ; a1++</span><br><span class="line">        mul   a0, a0, a1     ; a0 = a0 * a1 = 4096 * (hartid + 1)</span><br><span class="line">        add   sp, sp, a0     ; sp += a0 = &amp;stack0 + 4096 * (hartid + 1)</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure>

<p>xv6从entry.S开始启动，这个时候没有内存分页，没有隔离性，并且运行在M-mode（machine mode）。xv6会尽可能快的跳转到supervisor mode。<code>call start</code>后，执行<code>kernel/start.c/start()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要完成了以下任务：</p>
<ul>
<li><p>将上一个特权模式设置为监督模式，以便从机器模式返回时进入监督模式。</p>
</li>
<li><p>设置异常返回地址为<code>main</code>函数的地址。</p>
</li>
<li><p>使用<code>mret</code>指令切换到监督模式并跳转到<code>main</code>函数。</p>
</li>
</ul>
<p>kernel&#x2F;main.c中代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main()</code>主要进行各种初始化，通过<code>userinit</code>运行第一个进程。这个进程执行了一个<code>initcode.S</code>的汇编程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个汇编程序中，它首先将init中的地址加载到a0，argv中的地址加载到a1，<code>exec</code>对应的系统调用号加载到a7，最后调用<code>ECALL</code>。所以这里执行了3条指令，之后在第4条指令执行系统调用将控制权交给了操作系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>num = p-&gt;trapframe-&gt;a7</code> 会读取使用的系统调用对应的整数。<code>p-&gt;trapframe-&gt;a0 = syscall[num]()</code> 这是实际执行系统调用。这里可以看出，num用来索引一个数组，这个数组是一个函数指针数组，可以预期的是syscall[7]对应了exec的入口函数<code>sys_exec</code>，通过<code>exec</code>调用init程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># user/init.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *argv[] = &#123; <span class="string">&quot;sh&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">      <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">      wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">        <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init会为用户空间设置好一些东西，比如配置好console，调用<code>fork</code>，并在子进程中执行shell。至此整个系统启动了。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/20/6-S081-Lecture-3-OS-Organization-and-System-Calls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/20/6-S081-Lecture-3-OS-Organization-and-System-Calls/" class="post-title-link" itemprop="url">6.S081-Lecture 3 OS Organization and System Calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-20 23:54:54" itemprop="dateCreated datePublished" datetime="2024-07-20T23:54:54+08:00">2024-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-22 10:52:38" itemprop="dateModified" datetime="2024-07-22T10:52:38+08:00">2024-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="操作系统隔离性（Isolation）"><a href="#操作系统隔离性（Isolation）" class="headerlink" title="操作系统隔离性（Isolation）"></a>操作系统隔离性（Isolation）</h2><p>一个操作系统必须满足三个要求：多路复用、隔离和交互。</p>
<p>隔离性的思想：</p>
<ul>
<li><p>在不同的应用程序之间应该有强隔离性。当某一个应用程序的代码出现了问题，不应该会影响到其他的应用程序。</p>
</li>
<li><p>在应用程序和操作系统之间有强隔离性。操作系统某种程度上为所有的应用程序服务，当一个应用程序出现问题时，操作系统不应该因此崩溃。</p>
</li>
<li><p>不同应用程序之间的内存是隔离的，这样一个应用程序就不会覆盖另一个应用程序的内存。</p>
</li>
</ul>
<p>如果没有操作系统会怎样？</p>
<ul>
<li><p>如果没有操作系统，应用程序会直接与硬件交互。比如，应用程序可以直接看到CPU的多个核，看到磁盘，内存。现在没有操作系统来帮助切换运行在CPU上的应用程序，这个程序可能永远不会释放CPU，其他程序就永远无法运行。</p>
</li>
<li><p>从内存的角度来说，如果应用程序直接运行在硬件资源之上，那么每个应用程序的文本，代码和数据都直接保存在物理内存中。应用程序的内存之间没有边界，这样一个应用程序就可能会覆盖另一个应用程序的内存。</p>
</li>
</ul>
<p>操作系统提供的接口通过抽象硬件资源（将硬件资源抽象为服务），使得强隔离性成为可能。</p>
<ul>
<li><p><code>fork</code>创建了进程。进程本身不是CPU，但是它们对应了CPU，它们使得你可以在CPU上运行计算任务。应用程序不能直接与CPU交互，只能与进程交互。操作系统内核会完成不同进程在CPU上的切换。所以，操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，<strong>进程抽象了CPU</strong>，这样操作系统才能在多个应用程序之间<strong>复用</strong>一个或者多个CPU。</p>
</li>
<li><p><strong><code>exec</code>抽象了内存</strong>。<code>exec</code>系统调用用于加载一个新程序到当前进程的地址空间，并开始执行这个新程序。这个调用过程确保了程序只能访问被分配的虚拟地址空间，不能直接访问物理内存。操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。</p>
</li>
<li><p><strong>files抽象了磁盘</strong>。在Unix和类Unix操作系统中，文件系统（file system）提供了一种抽象，使应用程序不需要直接与底层的硬件（如磁盘）交互。通过文件系统的抽象，操作系统可以实现对存储设备的管理和访问控制。</p>
<p>在Unix中，与存储系统交互的唯一方式就是通过files。Files提供了非常方便的磁盘抽象，你可以对文件命名，读写文件等等。之后，操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件。通过files的抽象，可以实现不同用户之间和同一个用户的不同进程之间的文件强隔离。</p>
</li>
</ul>
<h2 id="操作系统防御性（Defensive）"><a href="#操作系统防御性（Defensive）" class="headerlink" title="操作系统防御性（Defensive）"></a>操作系统防御性（Defensive）</h2><p>操作系统需要确保所有的组件都能工作，所以它需要做好准备抵御来自应用程序的攻击。如果说应用程序无意或者恶意的向系统调用传入一些错误的参数就会导致操作系统崩溃，操作系统因为崩溃了会拒绝为其他所有的应用程序提供服务。</p>
<p>另外，应用程序不能够打破操作系统对它的隔离。应用程序非常有可能是恶意的，攻击者可能想要打破对应用程序的隔离，进而控制内核。一旦有了对于内核的控制能力，就可以做任何事情，因为内核控制了所有的硬件资源。所以操作系统或者说内核需要具备防御性来避免类似的事情发生。</p>
<h2 id="硬件对于强隔离的支持"><a href="#硬件对于强隔离的支持" class="headerlink" title="硬件对于强隔离的支持"></a>硬件对于强隔离的支持</h2><p>硬件对于强隔离的支持包括了：用户态&#x2F;内核态、虚拟内存。</p>
<p>为了支持user&#x2F;kernel mode，处理器会有两种操作模式，第一种是user mode，第二种是kernel mode。当运行在kernel mode时，CPU可以运行特权指令（privileged instructions）；当运行在user mode时，CPU只能运行非特权指令（unprivileged instructions）。</p>
<p><strong>特权指令</strong>主要是一些直接操纵硬件的指令和设置保护的指令，只允许处于内核态下的程序执行。例如设置page table寄存器、关闭时钟中断。在处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。</p>
<p><strong>非特权指令</strong>就是普通权限指令，所有的应用程序都允许执行这些指令。例如将两个寄存器相加的指令ADD、将两个寄存器相减的指令SUB、跳转指令JRC、BRANCH指令等等。</p>
<p>在处理器里面有一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特权指令并且该bit被设置为1，处理器会拒绝执行这条指令。设置这个bit位的指令必须是特权指令。</p>
<p>为了实现进程隔离，RISC-V CPU在硬件上提供3种执行命令的模式：machine mode, supervisor mode, user mode。</p>
<ul>
<li><p>机器模式machine mode的权限最高，在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6会在机器模式下执行几条指令，然后转为监督者模式。</p>
</li>
<li><p>在监督者模式supervisor mode下，CPU被允许执行特权指令。如果用户模式下的应用程序试图执行一条特权指令，CPU不会执行该指令，而是切换到监督者模式，这样监督者模式的代码就可以终止该应用程序。</p>
</li>
<li><p>在用户模式user mode下只能执行非特权指令指令。要想让CPU从用户模式切换到监督者模式，RISC-V提供了一个特殊的<code>ecall</code>指令，要想从监督者模式切换到用户模式，调用<code>sret</code>指令。</p>
</li>
</ul>
<p>对于虚拟内存，处理器包含了页表page table，而页表将虚拟内存地址与物理内存地址做了对应。每一个进程都会有自己独立的页表，每一个进程只能访问出现在自己页表中的物理内存。</p>
<p>操作系统通过设置进程的页表，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存。一个进程不能随意编造一个内存地址，然后通过这个内存地址来访问其他进程的物理内存。这样就给提供了内存的强隔离性。</p>
<h2 id="用户态-内核态的切换"><a href="#用户态-内核态的切换" class="headerlink" title="用户态&#x2F;内核态的切换"></a>用户态&#x2F;内核态的切换</h2><p>用户态&#x2F;内核态是分隔用户空间和内核空间的边界，用户空间中运行的程序运行在用户态，内核空间中的程序运行在内核态。操作系统位于内核空间。</p>
<p>需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。在RISC-V中，有一个专门的指令用来实现这个功能，叫做<strong>ECALL</strong>。ECALL接收一个参数，当一个用户程序想要将程序执行的控制权转移到内核，只需要执行ECALL指令，并传入一个数字（系统调用号）。这里的数字参数代表了应用程序想要调用的System Call。</p>
<p>在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是哪个系统调用。</p>
<p>举个例子，用户态下用户程序调用<code>fork()</code>函数（这是封装好的系统调用函数，并不是真正的系统调用），<code>fork()</code>函数中调用<code>ecall sys_fork</code>，系统陷入内核态并执行syscall函数，再由syscall函数实际调用<code>fork</code>系统调用。</p>
<h2 id="宏内核与微内核"><a href="#宏内核与微内核" class="headerlink" title="宏内核与微内核"></a>宏内核与微内核</h2><p>宏内核：所有基本的操作系统服务（如进程管理、内存管理、文件系统、设备驱动等）都运行在内核空间。xv6是一个宏内核。</p>
<p>微内核：只包括最基本的操作系统服务，如进程管理、内存管理和进程间通信（IPC）。其他服务（如文件系统、设备驱动、网络协议等）在用户空间运行。</p>
<p>宏内核的设计适合对性能要求较高的系统，而微内核则适合对安全性和稳定性要求较高的系统。</p>
<h2 id="代码：xv6-组织"><a href="#代码：xv6-组织" class="headerlink" title="代码：xv6 组织"></a>代码：xv6 组织</h2><p>xv6内核源码在<code>kernel/</code>子目录下。按照模块化的概念，源码被分成了多个文件，模块间的接口在<code>kernel/defs.h</code>中定义。</p>
<table>
<thead>
<tr>
<th><strong>文件</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>bio.c</strong></td>
<td>文件系统的磁盘块缓存</td>
</tr>
<tr>
<td><strong>console.c</strong></td>
<td>连接到用户的键盘和屏幕</td>
</tr>
<tr>
<td><strong>entry.S</strong></td>
<td>首次启动指令</td>
</tr>
<tr>
<td><strong>exec.c</strong></td>
<td><code>exec()</code>系统调用</td>
</tr>
<tr>
<td><strong>file.c</strong></td>
<td>文件描述符支持</td>
</tr>
<tr>
<td><strong>fs.c</strong></td>
<td>文件系统</td>
</tr>
<tr>
<td><strong>kalloc.c</strong></td>
<td>物理页面分配器</td>
</tr>
<tr>
<td><strong>kernelvec.S</strong></td>
<td>处理来自内核的陷入指令以及计时器中断</td>
</tr>
<tr>
<td><strong>log.c</strong></td>
<td>文件系统日志记录以及崩溃修复</td>
</tr>
<tr>
<td><strong>main.c</strong></td>
<td>在启动过程中控制其他模块初始化</td>
</tr>
<tr>
<td><strong>pipe.c</strong></td>
<td>管道</td>
</tr>
<tr>
<td><strong>plic.c</strong></td>
<td>RISC-V中断控制器</td>
</tr>
<tr>
<td><strong>printf.c</strong></td>
<td>格式化输出到控制台</td>
</tr>
<tr>
<td><strong>proc.c</strong></td>
<td>进程和调度</td>
</tr>
<tr>
<td><strong>sleeplock.c</strong></td>
<td>Locks that yield the CPU</td>
</tr>
<tr>
<td><strong>spinlock.c</strong></td>
<td>Locks that don’t yield the CPU.</td>
</tr>
<tr>
<td><strong>start.c</strong></td>
<td>早期机器模式启动代码</td>
</tr>
<tr>
<td><strong>string.c</strong></td>
<td>字符串和字节数组库</td>
</tr>
<tr>
<td><strong>swtch.c</strong></td>
<td>线程切换</td>
</tr>
<tr>
<td><strong>syscall.c</strong></td>
<td>Dispatch system calls to handling function.</td>
</tr>
<tr>
<td><strong>sysfile.c</strong></td>
<td>文件相关的系统调用</td>
</tr>
<tr>
<td><strong>sysproc.c</strong></td>
<td>进程相关的系统调用</td>
</tr>
<tr>
<td><strong>trampoline.S</strong></td>
<td>用于在用户和内核之间切换的汇编代码</td>
</tr>
<tr>
<td><strong>trap.c</strong></td>
<td>对陷入指令和中断进行处理并返回的C代码</td>
</tr>
<tr>
<td><strong>uart.c</strong></td>
<td>串口控制台设备驱动程序</td>
</tr>
<tr>
<td><strong>virtio_disk.c</strong></td>
<td>磁盘设备驱动程序</td>
</tr>
<tr>
<td><strong>vm.c</strong></td>
<td>管理页表和地址空间</td>
</tr>
</tbody></table>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>xv6中的隔离单位是一个进程。进程抽象可以防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等，它还可以防止进程破坏内核。</p>
<p>为了帮助实施隔离，进程抽象为程序提供了一种错觉。一个进程为程序提供了一个看似私有的内存系统（地址空间）。进程还为程序提供了看似私有的CPU，用来执行程序的指令。</p>
<p>xv6为每个进程维护一个单独的页表，用于定义该进程的地址空间。如下图所示，进程的用户空间内存的地址空间是从虚拟地址0开始的，依次是指令、全局变量、栈、堆区。RISC-V上的指针是64位宽；硬件在页表中查找虚拟地址时只使用低的39位；xv6只使用39位中的38位。因此，最大地址是2^{38}-1&#x3D; 0x3fffffffff，也就是<code>MAXVA</code>（kernel&#x2F;riscv.h:348）。在地址空间的顶端，xv6保留了一页，用于trampoline和映射进程trapframe的页，以便切换到内核。</p>
<img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter2_address_space.jpg" style="zoom:50%;" />

<p>xv6内核为每个进程维护了许多状态，记录在<code>proc</code>结构体(kernel&#x2F;proc.h:86)。一个进程最重要的内核状态是它的页表、内核栈和运行状态。</p>
<ul>
<li><p><code>p-&gt;state</code>表示进程是创建、就绪、运行、等待I&#x2F;O，还是退出。</p>
</li>
<li><p><code>p-&gt;pagetable</code>以RISC-V硬件需要的格式保存进程的页表。进程的页表记录分配给该进程内存的物理页地址。</p>
</li>
<li><p><code>p-&gt;kstack</code>通常指的是一个进程结构体中的内核栈指针。在内核态执行系统调用或处理中断时，内核会使用当前进程的内核栈。</p>
</li>
</ul>
<p>每个进程有两个栈：用户栈和内核栈。当进程在执行用户指令时，只有它的用户栈在被使用，而它的内核栈是空的。当进程进入内核时（因为系统调用或中断），内核代码在进程的内核栈上执行；当进程在内核中时，它的用户栈仍然包含保存的数据，但不被主动使用。进程的线程在用户栈和内核栈中交替执行。内核栈是独立的（并且受到保护，不受用户代码的影响），所以即使一个进程用户栈被破坏了，内核也可以执行。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/01/xv6-riscv-book-chapter1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/01/xv6-riscv-book-chapter1/" class="post-title-link" itemprop="url">xv6-riscv-book-chapter1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-01 14:25:29" itemprop="dateCreated datePublished" datetime="2024-07-01T14:25:29+08:00">2024-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 17:23:54" itemprop="dateModified" datetime="2024-07-19T17:23:54+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章：操作系统接口"><a href="#第一章：操作系统接口" class="headerlink" title="第一章：操作系统接口"></a>第一章：操作系统接口</h1><p>内核（kernel）：一个向其他运行中的程序提供服务的特殊程序。进程（process）：每一个正在运行的程序。每个进程的内存空间中存储自己的指令、数据、栈。指令实现程序的运算，数据是用于运算过程的变量，栈则管理程序的过程调用。一台计算机通常有许多进程，但只有一个内核。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/1.1kernel%20and%20user%20processes%20.png" alt="内核与用户程序"></p>
<p>内核使用CPU提供的硬件保护机制来确保在用户空间中执行的每个进程只能访问自己的内存。内核运行时拥有硬件特权，可以访问这些受到保护的资源，而用户程序运行时则没有这些特权。</p>
<p>当一个进程需要使用内核的服务时，它就会调用系统调用(system call)。系统调用会进入内核，让内核执行服务然后返回，所以进程会在用户空间和内核空间之间交替运行。</p>
<h2 id="1-1-进程和内存"><a href="#1-1-进程和内存" class="headerlink" title="1.1 进程和内存"></a>1.1 进程和内存</h2><p>在xv6中，每个进程拥有自己的用户空间内存以及内核空间状态。xv6对进程提供分时特性，即xv6可以切换当前cpu上运行的进程。当一个进程暂时不使用cpu时，xv6会保存它的CPU寄存器（代表了进程的状态），在下次运行该进程时恢复它们。对被切换的进程来说好像时自己独占了cpu。内核为每个进程关联一个进程描述符PID(process identifier)，用于唯一标识进程。</p>
<ul>
<li><p><code>fork</code>：形式：<code>int fork()</code>。调用<code>fork</code>的进程称为父进程，新创建的进程称为子进程，子进程的内存内容与父进程完全相同。但子进程不是完全拷贝了父进程，它拥有自己的地址空间、寄存器、程序计数器PC等。<code>fork</code>调用一次，返回两次。在父进程中，<code>fork</code>的返回值是子进程的PID；在子进程中，返回值是0。父、子进程时并发运行的独立进程，内核能够以任意方式交替运行。</p>
</li>
<li><p><code>exit</code>：形式：<code>int exit(int status)</code>。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数status，0代表以正常状态退出，1代表以非正常状态退出。</p>
</li>
<li><p><code>wait</code>：形式：<code>int wait(int *status)</code>。调用进程会被挂起，直到<code>wait</code>返回。等待子进程退出，返回子进程PID，将子进程的退出状态存储到<code>int *status</code>这个地址中。如果调用者没有子进程，<code>wait</code>将返回-1。如果父进程不关心子进程的退出状态，可以传递一个0地址给wait。</p>
</li>
<li><p><code>exec</code>：形式：<code>int exec(char *file, char *argv[])</code>。从可执行程序中加载代码和静态数据，并重新初始化进程内存空间。然后执行该程序，参数通过<code>argv</code>传递给该进程。因此<code>exec</code>并没有创建新的进程，只是将当前运行的程序替换为不同的程序。如果执行错误返回-1，执行成功则不会返回。文件必须是ELF格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码会执行&#x2F;bin&#x2F;echo程序，并将argv数组作为参数。注意参数数组<code>argv</code>的第一个元素是程序名称。由于<code>exec</code>并不会返回，所以printf(“exec error\n”);&#96;并不会执行。</p>
</li>
</ul>
<p>这种分离<code>fork</code>和<code>exec</code>的做法在构建shell时非常有用，在这两个调用之间，shell有机会重定向子进程的I&#x2F;O，而不干扰父进程的I&#x2F;O设置。</p>
<h2 id="1-2-I-O和文件描述符"><a href="#1-2-I-O和文件描述符" class="headerlink" title="1.2 I&#x2F;O和文件描述符"></a>1.2 I&#x2F;O和文件描述符</h2><p>文件描述符是一个小整数（非负数），代表一个可由进程读取或写入的内核管理对象。文件描述符用于指代被打开的文件，所有执行I&#x2F;O操作的系统调用都通过文件描述符来实现。</p>
<p>在内部，xv6内核为每一个进程单独维护一个以文件描述符为索引的表（进程级的文件打开表）。按照约定，一个进程从文件描述符0(标准输入)读取数据，向文件描述符1(标准输出)写入输出，向文件描述符2(标准错误)写入错误信息。shell确保自己总是有三个文件描述符打开。</p>
<ul>
<li><p><code>read</code>和<code>write</code>：形式<code>int write(int fd, char *buf, int n)</code>和<code>int read(int fd, char *buf, int n)</code>。从（向）文件描述符<code>fd</code>处读（写）n个字节<code>buf</code>的内容，返回值是成功读取（写入）的字节数。每个文件描述符有一个offset，<code>read</code>会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个<code>read</code>将从新的offset开始读取字节。<code>write</code>也有类似的offset。</p>
</li>
<li><p><code>close</code>：形式是<code>int close(int fd)</code>，参数是想要关闭文件的文件描述符<code>fd</code>。文件关闭后，该文件描述符可以被重新使用，新分配的文件描述符总是当前进程中最小的未使用描述符。</p>
<p>文件描述符和fork相互作用，使I&#x2F;O重定向易于实现。<code>fork</code>将父进程的文件描述符表和它的内存一起复制，这样子进程开始时打开的文件和父进程完全一样。<code>exec</code>替换调用进程的内存，但会保留文件描述符表。下面是shell运行<code>cat &lt; input.txt</code>命令的简化版代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      close(<span class="number">0</span>);  <span class="comment">// 释放标准输入的文件描述符</span></span><br><span class="line">      open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);  <span class="comment">// fd = 0被重新分配，这时input.txt的文件描述符为0</span></span><br><span class="line">      <span class="comment">// 即标准输入为input.txt</span></span><br><span class="line">      exec(<span class="string">&quot;cat&quot;</span>, argv);  <span class="comment">// cat从0读取，并输出到1，见上个代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子进程关闭文件描述符0后，此时0将是最小的可用文件描述符，新打开的input.txt就使用该文件描述符0。如果 cat 没有给出任何参数，它会从标准输入0读入数据，在上例中cat就从input.txt中读取字符。这不会改变父进程的文件描述符表，它只会修改子进程的描述符表，但是文件中的offset将被共享。</p>
</li>
<li><p><code>dup</code>：形式是<code>int dup(int fd)</code>，复制一个现有的文件描述符fd，返回一个新的描述符，它们指向同一个底层I&#x2F;O对象。两个I&#x2F;O对象(文件)的偏移量offset相同。</p>
<p>如果两个文件描述符是通过一系列的<code>fork</code>和<code>dup</code>调用从同一个原始文件描述符衍生出来的，那么这两个文件描述符共享一个偏移量。否则，文件描述符不共享偏移量。</p>
</li>
</ul>
<h2 id="1-3-管道"><a href="#1-3-管道" class="headerlink" title="1.3 管道"></a>1.3 管道</h2><p>管道（pipes）是一个小的内核缓冲区，作为一对文件描述符提供给进程，一个用于读，一个用于写。将数据写入管道的一端就可以从管道的另一端读取数据。管道在内核空间中实现，为进程提供了一种通信方式。</p>
<p><code>pipe</code>是一个system call，形式为<code>int pipe(int p[])</code>，参数<code>p[]</code>是一个大小为 2 的整数数组，用于接收创建的文件描述符。<code>p[0]</code>为读取的文件描述符，<code>p[1]</code>为写入的文件描述符。管道中的数据只能被读一次。</p>
<p>下面的示例代码运行程序wc，标准输入连接到管道的读取端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>);  <span class="comment">// 释放子进程中的文件描述符0</span></span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// 复制一个p[0](管道读端)，此后文件描述符0（标准输入）也引用管道读端</span></span><br><span class="line">    close(p[<span class="number">0</span>]); <span class="comment">// 关闭子进程中的管道读端</span></span><br><span class="line">    close(p[<span class="number">1</span>]); <span class="comment">// 如果不关闭p[1]写端，管道的读端会一直等待读取，wc就永远也无法等到EOF</span></span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv); <span class="comment">// wc 从标准输入读取数据，并写入到参数中的每// 一个文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有管道中暂时没有数据可读，管道上的<code>read</code>操作会等待数据被写入，或者等待所有指向写端的文件描述符被关闭；在后一种情况下，读操作将返回0。如果没有数据写入，读操作会无限阻塞，直到新数据不可能到达为止（写端被关闭），这也是子进程在执行上面的wc之前关闭管道的写端很重要的一个原因：如果wc的一个文件描述符仍然引用了管道的写端，那么wc将永远看不到文件的关闭（被自己阻塞）。</p>
<p>xv6的shell实现了管道，如下，shell的实现类似于上面的代码（user&#x2F;sh.c:100）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep fork sh.c | wc -l</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/sh.c:100</span></span><br><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">  pcmd = (*<span class="keyword">struct</span>* pipecmd*)*cmd*;</span><br><span class="line">  <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">   panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">   close(<span class="number">1</span>);</span><br><span class="line">   dup(p[<span class="number">1</span>]);</span><br><span class="line">   close(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">1</span>]);</span><br><span class="line">   runcmd(pcmd-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">   close(<span class="number">0</span>);</span><br><span class="line">   dup(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">0</span>]);</span><br><span class="line">   close(p[<span class="number">1</span>]);</span><br><span class="line">   runcmd(pcmd-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  close(p[<span class="number">0</span>]);</span><br><span class="line">  close(p[<span class="number">1</span>]);</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h1 id="1-4-文件系统"><a href="#1-4-文件系统" class="headerlink" title="1.4 文件系统"></a>1.4 文件系统</h1><p>xv6文件系统包含了文件（byte arrays）和目录（对其他文件和目录的引用）。目录生成了一个树，树从根目录<code>/</code>开始。对于不以<code>/</code>开头的路径，认为是是相对路径。</p>
<ul>
<li><p><code>mknod</code>：创建设备文件，一个设备文件有一个主要设备号（major device #）和一个次要设备号（minor device #）用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将<code>read</code>和<code>write</code>的system call重新定向到设备上。</p>
</li>
<li><p><code>stat</code>：形式：<code>int stat(char *path, struct stat *st)</code>。用于指定文件的元数据，并将信息存储在 <code>struct stat</code> 类型的变量 <code>st</code> 中。</p>
</li>
<li><p><code>fstat</code>：形式：<code>int fstat(int fd, struct stat *st)</code>。用于获取与文件描述符 <code>fd</code> 关联的文件的元数据，并将信息存储在 <code>struct stat</code> 类型的变量 <code>st</code> 中。</p>
<p>文件控制块（FCB）是用来存放控制文件所需的各种信息的数据结构，FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。FCB &#x3D; 文件名称 + 索引节点指针。 索引节点中存放文件的元数据，包括文件类型（文件或目录或设备），文件长度，文件内容在磁盘上的位置，以及文件的链接数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File metadata information</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>link</code>将创建一个指向同一个inode的文件名。<code>unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除。</p>
</li>
</ul>
<p>Unix提供了shell可调用的文件操作程序，作为用户级程序，例如<strong>mkdir</strong>、<strong>ln</strong>和<strong>rm</strong>。这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。现在看来，这个设计似乎是显而易见的，但在Unix时期设计的其他系统通常将这类命令内置到shell中（并将shell内置到内核中）。</p>
<p>有一个例外，那就是cd，它是在shell中实现的 (user&#x2F;sh.c:160)。cd 必须改变 shell 自身的当前工作目录。如果cd作为一个普通命令执行，那么shell就会fork一个子进程，而子进程会运行cd，cd只会改变子进程的当前工作目录。父进程（即shell）的工作目录则保持不变。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/10/6-S081-Lab1-Xv6-and-Unix-utilities/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/10/6-S081-Lab1-Xv6-and-Unix-utilities/" class="post-title-link" itemprop="url">6.S081-Lab1-Xv6 and Unix utilities</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-10 00:28:36" itemprop="dateCreated datePublished" datetime="2024-06-10T00:28:36+08:00">2024-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-22 23:05:03" itemprop="dateModified" datetime="2024-07-22T23:05:03+08:00">2024-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>利用系统调用<code>sleep</code>实现指定tick的时间休眠。如果用户忘记传递参数，sleep 程序要打印错误信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep number_of_ticks\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  number = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;(nothing happens for a little while)\n&quot;</span>);</span><br><span class="line">  sleep(number);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>利用系统调用<code>fork</code>和<code>pipe</code>在父、子进程中传递信息。父、子进程交互流程：</p>
<ul>
<li><p>父进程应向子进程发送一个字节；</p>
</li>
<li><p>子进程应打印”<pid>: received ping”（<pid>是其进程 ID），并将该字节写入父进程的管道，然后退出；</p>
</li>
<li><p>父进程应从子进程读取该字节，打印”<pid>: received pong”，然后退出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pingpong</span></span><br><span class="line">4: received ping</span><br><span class="line">3: received pong</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>思路：</p>
<ul>
<li>正常情况下<code>fork()</code>过后，父、子进程的并发运行的，执行顺序并不能确定。</li>
<li>要确保先运行父进程，必须要阻塞子进程。子进程要从管道中读取信息，当管道中暂时没有数据可读时，<code>read</code>就会阻塞子进程。</li>
<li>父进程发完信息后，要等待子进程执行结束后再次运行。</li>
<li>注意当管道的端口不再使用后要及时关闭。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> buf[<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  pipe(p);</span><br><span class="line">  <span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    read(p[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    wait(<span class="number">0</span>);  <span class="comment">// waiting for child process to exit; not care about the return </span></span><br><span class="line">    read(p[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, pid);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>质数筛选器：对于一组数，先print出最小的一个数，这是一个素数，然后用其他剩下的数依次尝试整除这个素数，如果可以整除则不是质数，则将其drop，不能整除则将其参与下一轮筛选，直到最后打印出所有的素数。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lab1_primes_filter.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = get a number from left neighbor</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = get a number from left neighbor</span><br><span class="line">    if (p does not divide n)</span><br><span class="line">        send n to right neighbor</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>主进程生成初始数字，子进程递归地负责筛选质数，进程间使用管道传递数字。</li>
<li>内核中可以同时存在的管道数是有限的，当管道的端口不再使用后要及时关闭。</li>
<li>在主进程中要注意等待子进程结束。</li>
</ul>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lab1_primes_filter2.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_INT 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">Filter</span><span class="params">(<span class="type">int</span> pipe_fd[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">  close(pipe_fd[<span class="number">1</span>]);  <span class="comment">// close the write port</span></span><br><span class="line">  <span class="type">int</span> prime;</span><br><span class="line">  <span class="keyword">if</span>(read(pipe_fd[<span class="number">0</span>], &amp;prime, SIZE_INT) != SIZE_INT)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when read the prime number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">int</span> flag = read(pipe_fd[<span class="number">0</span>], &amp;num, SIZE_INT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// There are no more numbers to judge.</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pipe_fd2[<span class="number">2</span>];</span><br><span class="line">  pipe(pipe_fd2);</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">    close(pipe_fd2[<span class="number">0</span>]); <span class="comment">// close the read port</span></span><br><span class="line">    <span class="keyword">if</span>(num % prime != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the num is  a prime</span></span><br><span class="line">      write(pipe_fd2[<span class="number">1</span>], &amp;num, SIZE_INT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(read(pipe_fd[<span class="number">0</span>], &amp;num, SIZE_INT) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(num % prime != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// the num is  a prime</span></span><br><span class="line">        write(pipe_fd2[<span class="number">1</span>], &amp;num, SIZE_INT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd2[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    Filter(pipe_fd2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  pipe(p);</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">    close(p[<span class="number">0</span>]);  <span class="comment">// close the read port</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">32</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(write(p[<span class="number">1</span>], &amp;i, SIZE_INT) != SIZE_INT)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when write the number 2-32\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    Filter(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when fork in primes_main\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>一个简单版本的 UNIX find功能，在指定的文件夹下符合某个名字的文件，打印出其路径。</p>
<ul>
<li>首先按照提示阅读<strong>user&#x2F;ls.c</strong>学习如何读取目录，照猫画虎。</li>
</ul>
<ul>
<li>注意检查find命令行中的path参数，要为目录名。</li>
</ul>
<ul>
<li>字符串结尾处要有结束标识符<code>\0</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *target)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The first argument to find must be a directory</span></span><br><span class="line">  <span class="keyword">if</span>(st.type != T_DIR)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: &lt;*directory*&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">  p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">  *p++ = <span class="string">&#x27;/&#x27;</span>; <span class="comment">// now the end is &#x27;/&#x27;, not &#x27;\0&#x27;</span></span><br><span class="line">  <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="comment">// Read one directory entry at a time</span></span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    memmove(p, de.name, DIRSIZ);</span><br><span class="line">    p[DIRSIZ] = <span class="number">0</span>;  <span class="comment">// add the null terminator, \0, to make it a C string.</span></span><br><span class="line">    <span class="comment">// Match successful?</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name, target) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.type == T_DIR)&#123;</span><br><span class="line">      find(buf, target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: %s &lt;directory&gt; &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>实现一个简单版本的 UNIX xargs 程序，从标准输入中读取行，并为每一行运行一个指定的命令，同时将该行作为参数提供给命令。默认每次执行指定的命令时只从标准输入中额外获取一个参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;1\n2&quot;</span> | xargs <span class="built_in">echo</span> line</span></span><br><span class="line">line 1</span><br><span class="line">line 2</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>从标准输入中读取字符，以分隔符为界分割出参数，使用<code>fork</code>和<code>exec</code>执行命令。</li>
<li>ulibs.c中gets()提供类似按行读取的功能。</li>
<li><code>argv[argc] </code>处必须是NULL，用于标识指针数组的结束。字符数组用<code>\0</code>标识结束。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">xargsexec</span><span class="params">(<span class="type">char</span> *argv_xargs[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when xargsexec fork()&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    exec(argv_xargs[<span class="number">0</span>], argv_xargs);</span><br><span class="line">    <span class="comment">// never get there</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error when exec()&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: xargs needs three arguments at least\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *argv_xargs[MAXARG];</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">  argv_xargs[<span class="number">0</span>] = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    gets(buf, <span class="number">512</span>); <span class="comment">// Read a line from standard input</span></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123; </span><br><span class="line">      <span class="comment">// There is no more text in the standard input</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// Read the ulib.c/gets()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; i++)&#123;</span><br><span class="line">      argv_xargs[i] = argv[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    argv_xargs[argc - <span class="number">1</span>] = buf;</span><br><span class="line">    argv_xargs[argc] = (<span class="type">void</span> *)<span class="number">0</span>;  <span class="comment">// add the terminator NULL</span></span><br><span class="line"></span><br><span class="line">    xargsexec(argv_xargs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/23/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%EF%BC%88git%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/23/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%EF%BC%88git%EF%BC%89/" class="post-title-link" itemprop="url">版本控制（git）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-23 11:42:09 / 修改时间：11:44:16" itemprop="dateCreated datePublished" datetime="2024-04-23T11:42:09+08:00">2024-04-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/missing-Semester/" itemprop="url" rel="index"><span itemprop="name">missing-Semester</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>git init</code> 在当前目录下初始化一个新的 Git 仓库、生成一个.git目录和启动 Git 的版本控制功能。</p>
<p><code>git status</code>显示当前工作目录的状态信息。</p>
<p><code>git add</code>于将工作区（workspace）中的文件添加到暂存区（staging area）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file.txt             # 将文件 file.txt 添加到暂存区</span><br><span class="line">git add directory/           # 将目录 directory/ 中的所有文件和子目录添加到暂存区</span><br><span class="line">git add .                    # 将当前目录中的所有文件和子目录添加到暂存区</span><br></pre></td></tr></table></figure>

<p><code>git rm --cached</code>用于从暂存区（staging area）中移除文件，但保留工作目录中的实际文件。这意味着，执行 该命令后，Git 会停止跟踪该文件，但文件本身仍然保留在工作目录中。如果希望将被移除的文件彻底从工作目录中删除，并且不再受版本控制，请使用 <code>git rm</code> 命令。</p>
<p><code>git commit -m &quot;Add Submission Information&quot;</code> 用于将暂存区中的文件更改提交到本地仓库。执行该命令会创建一个新的提交（commit），并将暂存区中的文件更改作为这个提交的一部分。</p>
<p><code>git remote add</code> 用于向当前 Git 仓库添加一个新的远程存储库（remote repository）。执行该命令可以将一个远程存储库添加到当前 Git 仓库的配置中，并分配一个简单易记的名称给这个远程存储库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/username/repository.git</span><br></pre></td></tr></table></figure>

<p> <code>git remote -v </code>参看远程仓库的地址。</p>
<p> <code>git remote set-url</code>修改远程仓库的 URL。需要提供两个参数：远程仓库的名称和新的 URL。</p>
<p><code>git branch</code>用于查看、创建、删除和管理分支（branch）。执行该命令可以列出当前 Git 仓库中的所有分支，或者创建新的分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch                                       # 列出所有已有分支</span><br><span class="line">git branch new-branch-name                       # 创建新分支</span><br><span class="line">git branch -d branch-to-delete                   # 删除分支</span><br><span class="line">git branch -m old-branch-name new-branch-name    # 重命名分支</span><br></pre></td></tr></table></figure>

<p><code>git push</code> 将本地分支的提交推送到远程库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master    # origin是远程库的名称，master是要推送的本地分支名称。</span><br></pre></td></tr></table></figure>

<p> 执行 <code>git push</code> 命令时，需要进行身份验证，只有拥有推送权限的用户才能成功推送更改到远程存储库。</p>
<p> 要生成 SSH 公钥认证，可以按照以下步骤进行：</p>
<ol>
<li>打开终端（或命令提示符），输入以下命令来检查是否已存在 SSH 密钥：<ol>
<li><pre><code class="Bash">ls -al ~/.ssh
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2.   如果已经存在 SSH 密钥，则会显示已存在的密钥文件，通常`id_rsa`（私钥）和 `id_rsa.pub`（公钥）。</span><br><span class="line">2. 如果不存在 SSH 密钥，则可以使用以下命令生成新的 SSH 密钥：</span><br><span class="line">   1. ```Bash</span><br><span class="line">      ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>这条命令会生成一对新的 SSH 密钥，其中 <code>-t rsa</code> 指定密钥类型为 RSA，<code>-b 4096</code> 指定密钥长度为 4096 位，<code>-C &quot;``your_email@example.com``&quot;</code> 指定注释信息为您的邮箱地址。在生成密钥时，系统会提示您选择密钥的保存路径和输入密码。</p>
</li>
</ol>
</li>
<li>生成密钥后，可以使用以下命令来列出生成的 SSH 密钥：<ol>
<li><pre><code class="Bash">ls -al ~/.ssh
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">4. 使用SSH **公钥**（`id_rsa.pub` 文件中的内容）进行身份验证。将公钥添加到 GitHub 的设置中，以便使用 SSH 协议进行身份验证。</span><br><span class="line"></span><br><span class="line">`git clone` 将远程存储库中的所有文件和历史记录复制到本地计算机，创建一个新的 Git 仓库副本。</span><br><span class="line"></span><br><span class="line">`git pull` 从远程存储库获取（fetch）最新的更改并合并（merge）到当前分支。</span><br><span class="line"></span><br><span class="line">`git checkout`用于切换分支、恢复文件、创建分支等操作。</span><br><span class="line"></span><br><span class="line">```Shell</span><br><span class="line">git checkout master           # 切换到 master 分支</span><br><span class="line">git checkout -b new-branch    # 创建分支并切换</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<p><code>git diff</code>用于比较文件内容或提交之间的差异。会显示当前工作目录中未暂存的更改和已暂存的更改之间的差异，或者显示两个提交之间的差异。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/14/Linux2-6-34%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/14/Linux2-6-34%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">Linux2.6.34内核调试环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-14 14:00:16" itemprop="dateCreated datePublished" datetime="2024-04-14T14:00:16+08:00">2024-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 12:11:02" itemprop="dateModified" datetime="2024-04-16T12:11:02+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Linux内核</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>windows11+ VMware 16</li>
</ul>
<ul>
<li>虚拟机镜像：ubuntu-14.04.6-desktop-amd64.iso</li>
<li>Linux  源码版本：2.6.34</li>
<li>busybox 源码版本：1.20.1</li>
<li>qemu-system-x86_64 版本：2.0.0 </li>
<li>gcc 源码版本：4.8.4</li>
</ul>
<h3 id="在-Ubuntu-中安装-SSH服务"><a href="#在-Ubuntu-中安装-SSH服务" class="headerlink" title="在 Ubuntu 中安装 SSH服务"></a>在 Ubuntu 中安装 SSH服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>编辑<code>sshd_config</code>文件，修改<code>PasswordAuthentication </code>项 ，重启服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PermitRootLogin prohibit-password</span></span><br><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>

<h3 id="在Windows-Terminal-中连接-Ubuntu-时出现了错误"><a href="#在Windows-Terminal-中连接-Ubuntu-时出现了错误" class="headerlink" title="在Windows Terminal 中连接 Ubuntu 时出现了错误"></a>在Windows Terminal 中连接 Ubuntu 时出现了错误</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\31259&gt; ssh w@10.70.0.1</span><br><span class="line">ssh: connect to host 10.70.0.1 port 22: Connection timed out</span><br></pre></td></tr></table></figure>

<p>开始以为是 Ubuntu14.04 的问题， 经过更换端口号、设置防火墙等都未解决。尝试用 VMware 16 中的另一个Ubuntu22.04 连接 Ubuntu14.04，成功连接。那问题应该出在 Windows 端，排查到<code>‪C:\Users\31259\.ssh\config</code>中没配置好。</p>
<h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装编译环境</span></span><br><span class="line">sudo apt-get install -y libncurses5-dev build-essential</span><br><span class="line">sudo apt-get install -y lib32readline-gplv2-dev</span><br><span class="line">sudo apt-get install -y wget vim gdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装QEMU</span></span><br><span class="line">sudo apt-get install -y qemu-system-x86</span><br></pre></td></tr></table></figure>



<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><h3 id="获取内核源码"><a href="#获取内核源码" class="headerlink" title="获取内核源码"></a>获取内核源码</h3><p>首先<a target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/linux/kernel/v2.6/">下载内核</a>，选取与书中采用的 Linux-2.6.34。下载到本地后，解压，进入目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xvjf linux-2.6.34.tar.bz2</span><br><span class="line">cd linux-2.6.34</span><br></pre></td></tr></table></figure>

<h3 id="编译内核-1"><a href="#编译内核-1" class="headerlink" title="编译内核"></a>编译内核</h3><p>编译选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=i386 defconfig</span><br><span class="line">make ARCH=i386 menuconfig</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择以下编译选项，使用空格键选择。然后退出</span></span><br><span class="line">Kernel hacking  ---&gt; </span><br><span class="line">    [*] Compile the kernel with debug info </span><br><span class="line">    [*] KGDB: kernel debugging with remote gdb </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始编译</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-jN 代表多任务并行化，数字一般为cpu核数*2</span></span><br><span class="line">make ARCH=i386 -j4</span><br></pre></td></tr></table></figure>

<p>编译出错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/kernel/ptrace.c:1733:17: error: conflicting types for ‘syscall_trace_enter’</span><br><span class="line"> asmregparm long syscall_trace_enter(struct pt_regs *regs)</span><br><span class="line">                 ^</span><br><span class="line">In file included from /home/w/linux-2.6.34/arch/x86/include/asm/vm86.h:130:0,</span><br><span class="line">                 from /home/w/linux-2.6.34/arch/x86/include/asm/processor.h:10,</span><br><span class="line">                 from /home/w/linux-2.6.34/arch/x86/include/asm/thread_info.h:22,</span><br><span class="line">                 from include/linux/thread_info.h:56,</span><br><span class="line">                 from include/linux/preempt.h:9,</span><br><span class="line">                 from include/linux/spinlock.h:50,</span><br><span class="line">                 from include/linux/seqlock.h:29,</span><br><span class="line">                 from include/linux/time.h:8,</span><br><span class="line">                 from include/linux/timex.h:56,</span><br><span class="line">                 from include/linux/sched.h:56,</span><br><span class="line">                 from arch/x86/kernel/ptrace.c:11:</span><br><span class="line">/home/w/linux-2.6.34/arch/x86/include/asm/ptrace.h:146:13: note: previous declaration of ‘syscall_trace_enter’ was here</span><br><span class="line"> extern long syscall_trace_enter(struct pt_regs *);</span><br><span class="line">             ^</span><br><span class="line">arch/x86/kernel/ptrace.c:1778:17: error: conflicting types for ‘syscall_trace_leave’</span><br><span class="line"> asmregparm void syscall_trace_leave(struct pt_regs *regs)</span><br><span class="line">                 ^</span><br><span class="line">In file included from /home/w/linux-2.6.34/arch/x86/include/asm/vm86.h:130:0,</span><br><span class="line">                 from /home/w/linux-2.6.34/arch/x86/include/asm/processor.h:10,</span><br><span class="line">                 from /home/w/linux-2.6.34/arch/x86/include/asm/thread_info.h:22,</span><br><span class="line">                 from include/linux/thread_info.h:56,</span><br><span class="line">                 from include/linux/preempt.h:9,</span><br><span class="line">                 from include/linux/spinlock.h:50,</span><br><span class="line">                 from include/linux/seqlock.h:29,</span><br><span class="line">                 from include/linux/time.h:8,</span><br><span class="line">                 from include/linux/timex.h:56,</span><br><span class="line">                 from include/linux/sched.h:56,</span><br><span class="line">                 from arch/x86/kernel/ptrace.c:11:</span><br><span class="line">/home/w/linux-2.6.34/arch/x86/include/asm/ptrace.h:147:13: note: previous declaration of ‘syscall_trace_leave’ was here</span><br><span class="line"> extern void syscall_trace_leave(struct pt_regs *);</span><br><span class="line">             ^</span><br></pre></td></tr></table></figure>

<ul>
<li>出错原因：<a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/102074919">参考</a>，<code>arch/x86/kernel/ptrace.c</code>文件中第1733行的函数<code>syscall_trace_leave</code>和<code>syscall_trace_enter</code></li>
</ul>
<p>与<code>arch/x86/include/asm/ptrace.h</code>文件中该函数的声明有冲突。</p>
<ul>
<li>解决方法：将<code>ptrace.h</code>文件中的函数声明改得和<code>ptrace.c</code>中的相同即可。</li>
</ul>
<p>再次编译，出错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc: error: elf_i386: No such file or directory</span><br><span class="line">gcc: error: unrecognized command line option ‘-m’</span><br><span class="line">make[2]: *** [arch/x86/vdso/vdso32-int80.so.dbg] Error 1</span><br><span class="line">make[1]: *** [arch/x86/vdso] Error 2</span><br><span class="line">make: *** [arch/x86] Error 2</span><br></pre></td></tr></table></figure>

<ul>
<li>出错原因：<a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/101855564">参考</a>，编译器版本太高（gcc-4.8.4），不再支持 linker-style 架构。</li>
<li>解决方法：修改<code>arch/x86/vdso/Makefile</code>如下：将<code>-m elf_x86_64</code>改为<code>-m64</code>、把 <code>-m elf_i386</code>替换为<code>-m32</code>。</li>
</ul>
<p>再次编译，成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Root device is (8, 1)</span><br><span class="line">Setup is 13088 bytes (padded to 13312 bytes).</span><br><span class="line">System is 4103 kB</span><br><span class="line">CRC c85a2d7a</span><br><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#2)</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 2 modules</span><br></pre></td></tr></table></figure>

<h2 id="制作根文件系统"><a href="#制作根文件系统" class="headerlink" title="制作根文件系统"></a>制作根文件系统</h2><p><a target="_blank" rel="noopener" href="https://busybox.net/downloads/">下载buysbox源码</a>，使用的版本是busybox-1.20.1，下载到本地后，解压，进入目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xvf busybox-1.20.1.tar.bz2</span><br><span class="line">cd busybox-1.20.1</span><br></pre></td></tr></table></figure>

<p> 要编译32位的文件系统，修改 <code>Makefile: line 292</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC        = <span class="variable">$(CROSS_COMPILE)</span>gcc -m32</span><br></pre></td></tr></table></figure>









<p>编译出错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">loginutils/passwd.c: In function ‘passwd_main’:</span><br><span class="line">loginutils/passwd.c:104:16: error: storage size of ‘rlimit_fsize’ isn’t known struct rlimit rlimit_fsize;</span><br><span class="line"></span><br><span class="line">loginutils/passwd.c:188:12: error: ‘RLIMIT_FSIZE’ undeclared (first use in this function)</span><br><span class="line">  setrlimit(RLIMIT_FSIZE, &amp;rlimit_fsize);</span><br><span class="line"> </span><br><span class="line">miscutils/time.c:23:16: error: field ‘ru’ has incomplete type</span><br><span class="line">  struct rusage ru;</span><br><span class="line">                </span><br><span class="line">networking/inetd.c:307:2: error: unknown type name ‘rlim_t’</span><br><span class="line">  rlim_t rlim_ofile_cur;</span><br><span class="line">  ^</span><br><span class="line">networking/inetd.c:308:16: error: field ‘rlim_ofile’ has incomplete type</span><br><span class="line">  struct rlimit rlim_ofile;</span><br><span class="line">                </span><br><span class="line">networking/inetd.c: In function ‘bump_nofile’:</span><br><span class="line">networking/inetd.c:459:16: error: storage size of ‘rl’ isn’t known</span><br><span class="line">  struct rlimit rl;</span><br><span class="line"> </span><br><span class="line">networking/inetd.c:195:25: error: ‘RLIMIT_OFILE’ undeclared (first use in this function)</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">define RLIMIT_NOFILE   RLIMIT_OFILE</span></span><br><span class="line"> </span><br><span class="line">networking/ntpd.c:2015:15: error: ‘PRIO_PROCESS’ undeclared (first use in this function)</span><br><span class="line">   setpriority(PRIO_PROCESS, 0, -15);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>出错原因：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zouli415/article/details/89406778">参考</a>，</p>
</li>
<li><p>解决办法：修改源码，在<code>include/libbb.h </code>中添加一行 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/resource.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel ./linux-2.6.34/arch/x86/boot/bzImage   -initrd ./busybox-1.20.1/initrd.img  -append &quot;root=/dev/ram init=/linuxrc&quot; -serial file:output.txt -curses</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage  -initrd ./busybox-1.30.0/rootfs.img.gz  -append &quot;root=/dev/ram init=/linuxrc&quot; -serial file:output.txt -curses</span><br></pre></td></tr></table></figure>









<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel ./linux-2.6.34/arch/x86/boot/bzImage   -initrd ./busybox-1.30.0/rootfs.img.gz   -append &quot;root=/dev/ram init=/linuxrc&quot;</span><br></pre></td></tr></table></figure>
























      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/CS61A-Lecture-4-Higher-Order-Functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/CS61A-Lecture-4-Higher-Order-Functions/" class="post-title-link" itemprop="url">CS61A-Lecture-4-Higher-Order-Functions</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-08 23:28:24 / 修改时间：23:29:01" itemprop="dateCreated datePublished" datetime="2024-04-08T23:28:24+08:00">2024-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS61A/" itemprop="url" rel="index"><span itemprop="name">CS61A</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上节课没讲完的例子，寻找一个数的因数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  Prime numbers  素数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return True iff N is prime.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; is_prime(1)</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; is_prime(2)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; is_prime(8)</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; is_prime(21)</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; is_prime(23)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">1</span> <span class="keyword">and</span> smallest_factor(n) == n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smallest_factor</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns the smallest value k&gt;1 that evenly divides N.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># The following can be speeded up a great deal!</span></span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> n % k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_factors</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Print the prime factors of N. # 打印一个数的质因数</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print_factors(180)</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        d = smallest_factor(n)</span><br><span class="line">        <span class="built_in">print</span>(d)</span><br><span class="line">        n = n // d     <span class="comment"># or n //= d</span></span><br></pre></td></tr></table></figure>

<p>上述使用了上节介绍的 doctest，使用命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m doctest &lt;FileName&gt;</span><br></pre></td></tr></table></figure>

<p>Python 中使用 doctest，在运行这些测试前，会先扫描整个文件。这就允许了 doctest 出现在 smallest_factor() 前，还能调用smallest_factor()。</p>
<h2 id="函数相关术语"><a href="#函数相关术语" class="headerlink" title="函数相关术语"></a>函数相关术语</h2><ol>
<li>定义域：一个函数的可能参数值的集合，调用函数时的有效参数</li>
<li>值域：函数可以返回的值集，受值域影响</li>
<li>陪域(Codomain)又称上域、到达域。 函数的上域是一个比选择值域范围更大的集合。</li>
</ol>
<p>例如，我们可以说平方函数的定义域是实数，范围是非负数。我们可以选择将其上域描述为实数或仅描述为非负实数。</p>
<h2 id="函数文档注释"><a href="#函数文档注释" class="headerlink" title="函数文档注释"></a>函数文档注释</h2><p>理想情况下，函数的文档注释提供了足够的信息，以便程序员可以正确使用该函数并理解它的作用，而无需阅读其代码主体。</p>
<p>文档注释应该明确哪些输入在什么条件下是有效的，是可以调用函数的。还应该明确对于正确的输入，函数的结果输出或效果是什么。这些共同构成了函数的行为或语义。</p>
<h2 id="两条函数设计原则"><a href="#两条函数设计原则" class="headerlink" title="两条函数设计原则"></a>两条函数设计原则</h2><ol>
<li><p>函数应该做一件明确定义的事情（复杂的文档注释可能暗示你的函数做的太多）。</p>
</li>
<li><p>DRY (Don’t Repeat Yourself)</p>
<p>看起来非常相似的多个代码段迫切需要重构。 用对单个通用函数的简单调用替换重复段，该通用函数仅声明一次它们的共享结构，并使用用于专门针对各种情况的参数。</p>
</li>
</ol>
<h2 id="作为参数的函数"><a href="#作为参数的函数" class="headerlink" title="作为参数的函数"></a>作为参数的函数</h2><p>考虑下面两个函数，它们都计算总和。</p>
<p>但 <code>sum_naturals</code> 专用于计算截至<code>n</code>的自然数的和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_naturals(<span class="number">100</span>)</span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure>

<p>但<code>sum_cubes</code>，计算截至<code>n</code>的自然数的立方和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_cubes</span>(<span class="params">n</span>):</span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + <span class="built_in">pow</span>(k, <span class="number">3</span>), k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_cubes(<span class="number">100</span>)</span><br><span class="line"><span class="number">25502500</span></span><br></pre></td></tr></table></figure>

<p>这两个函数在背后都具有相同模式。它们大部分相同，只是名字、用于计算被加项的<code>k</code>的函数，以及提供<code>k</code>的下一个值的函数不同。我们可以通过向相同的模板中填充槽位来生成每个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(n):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + &lt;term&gt;(k), &lt;<span class="built_in">next</span>&gt;(k)</span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

<p>这个通用模板的出现是一个强有力的证据，证明有一个实用抽象正在等着我们表现出来。作为程序的设计者，我们希望我们的语言足够强大，便于我们编写函数来自我表达求和的概念，而不仅仅是计算特定和的函数。我们可以在 Python 中使用上面展示的通用模板，并且把槽位变成形参来轻易完成它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">n, term, <span class="built_in">next</span></span>):</span><br><span class="line">	total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> k &lt;= n:</span><br><span class="line">		total, k = total + term(k), <span class="built_in">next</span>(k)</span><br><span class="line">	<span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

<p>重新表示 sum_naturals()：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">identity</span>(<span class="params">k</span>):</span><br><span class="line">        <span class="keyword">return</span> k</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">successor</span>(<span class="params">k</span>):</span><br><span class="line">        <span class="keyword">return</span> k + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> summation(n, identity, successor)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_naturals(<span class="number">10</span>)</span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

<p>或者，可以创建匿名函数作为参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum_naturals(<span class="number">10</span>, <span class="keyword">lambda</span> x: x, <span class="keyword">lambda</span> x: x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="回顾-Lambda-表达式"><a href="#回顾-Lambda-表达式" class="headerlink" title="回顾 Lambda 表达式"></a>回顾 Lambda 表达式</h2><p>在 python 中，lambda 只是一个表达式，并不能执行复杂的语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> PARAMS: EXPRESSION</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Name</span>(<span class="params">PARAMS</span>):</span><br><span class="line">    <span class="keyword">return</span> EXPRESSION</span><br></pre></td></tr></table></figure>

<p>上述两式等价。注意 lambda 中没有<code>return</code>，主体必须只是一个简单表达式。</p>
<p>Lambda 表达式非常简短和直接，但复合的 Lambda 表达式非常难以辨认，尽管它们很简洁。下面的定义是是正确的，但是不能很快地理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose1 = <span class="keyword">lambda</span> f,g: <span class="keyword">lambda</span> x: f(g(x))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f,g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> func1</span><br></pre></td></tr></table></figure>

<p>通常，Python 的代码风格倾向于显式的<code>def</code>语句而不是 Lambda 表达式，但是允许它们在简单函数作为参数或返回值的情况下使用。</p>
<h2 id="定义函数：嵌套定义"><a href="#定义函数：嵌套定义" class="headerlink" title="定义函数：嵌套定义"></a>定义函数：嵌套定义</h2><p><strong>词法作用域。</strong>局部定义的函数也可以访问它们定义所在作用域的名称绑定。在上述 <code>compose1()</code>中，<code>func1</code>引用了名称<code>f、g</code>，它们是外层函数<code>compose1</code>的形参。这种在嵌套函数中共享名称的规则叫做词法作用域。严格来说，内部函数能够访问定义所在环境（而不是调用所在位置）的名称。</p>
<p>每个用户定义的函数都有一个关联环境：它的定义所在的环境。</p>
<p>当一个用户定义的函数调用时，它的局部帧扩展于函数所关联的环境。</p>
<img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/CS61A/L04_Higher_Nested_Definitions.png" />

<p>调用<code>com(256)</code>新建的局部帧的父节点指向 f1 帧，而不是直接指向全局环境。</p>
<h2 id="返回值为函数的函数"><a href="#返回值为函数的函数" class="headerlink" title="返回值为函数的函数"></a>返回值为函数的函数</h2><p>函数是 <code>first-class values</code>，这意味着我们可以将它们赋值给变量，将它们传递给函数，并从函数返回它们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add_func</span>(<span class="params">f, g</span>):</span><br><span class="line"><span class="meta">... </span><span class="string">&quot;&quot;&quot;Return function that returns F(x)+G(x) for argument x.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>	<span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">x</span>): <span class="comment">#</span></span><br><span class="line"><span class="meta">... </span>		<span class="keyword">return</span> f(x) + g(x) <span class="comment"># or return lambda x: f(x) + g(x)</span></span><br><span class="line"><span class="meta">... </span>	<span class="keyword">return</span> adder <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos, pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = add_func(sin, cos)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sin(pi/<span class="number">4</span>) + cos(pi/<span class="number">4</span>)</span><br><span class="line"><span class="number">1.414213562373095</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h(pi / <span class="number">4</span>)</span><br><span class="line"><span class="number">1.414213562373095</span></span><br></pre></td></tr></table></figure>

<p>让我们做一个通用的函数组合函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">combine_funcs</span>(<span class="params">op</span>):</span><br><span class="line"><span class="meta">... </span><span class="string">&quot;&quot;&quot;combine funcs(OP)(f, g)(x) = OP(f(x), g(x)).&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>	<span class="keyword">def</span> <span class="title function_">combined</span>(<span class="params">f, g</span>):</span><br><span class="line"><span class="meta">... </span>		<span class="keyword">return</span> <span class="keyword">lambda</span> x: op(f(x), g(x))</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">return</span> combined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_func = combine_funcs(add)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos, pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = add func(sin, cos)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h(pi / <span class="number">4</span>)</span><br><span class="line"><span class="number">1.414213562373095</span></span><br></pre></td></tr></table></figure>

<img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/CS61A/L04_Higher_FuncProduceFunc.png" style="zoom:67%;" />

<h2 id="条件函数？"><a href="#条件函数？" class="headerlink" title="条件函数？"></a>条件函数？</h2><p>设计一个函数 if_func ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> func(<span class="number">1</span>/x, x &gt; <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>要求实现条件表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/x <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以实现吗？</p>
<p>不能！因为函数总会计算全部参数的值，而条件表达式只会计算 TrueExpression、FalseExpression 中的一个。</p>
<p>但是我们可以定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">if_func</span>(<span class="params">then_expr, condition, else_expr</span>):</span><br><span class="line">	<span class="keyword">return</span> then_expr() <span class="keyword">if</span> condition <span class="keyword">else</span> else_expr()</span><br></pre></td></tr></table></figure>

<p>然后调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if_func(<span class="keyword">lambda</span>: <span class="number">1</span>/x, x &gt; <span class="number">0</span>, <span class="keyword">lambda</span>: <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这些无参数 lambda 的术语是 thunks 形实转换函数。</p>
<img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/CS61A/L04_Higher_ConditionalFunc.png" style="zoom:67%;" />

<p>在执行<code>if_func(lambda: 1/x, x &gt; 0, lambda: 0)</code>时，只是计算了<code>x&gt;0</code>的值，引入了两个 thunks，并未求函数值。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wnyxvo</p>
  <div class="site-description" itemprop="description">战战兢兢，如履薄冰</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wnyxvo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">60k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">54 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
