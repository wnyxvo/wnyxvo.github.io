<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="战战兢兢，如履薄冰">
<meta property="og:type" content="website">
<meta property="og:title" content="wnyxvo的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="wnyxvo的博客">
<meta property="og:description" content="战战兢兢，如履薄冰">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wnyxvo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>wnyxvo的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wnyxvo的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">18</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/17/6-S081-Lab5-COW-Fork-for-xv6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/17/6-S081-Lab5-COW-Fork-for-xv6/" class="post-title-link" itemprop="url">6.S081-Lab5-COW Fork for xv6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-17 14:09:27" itemprop="dateCreated datePublished" datetime="2025-02-17T14:09:27+08:00">2025-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-20 13:21:06" itemprop="dateModified" datetime="2025-02-20T13:21:06+08:00">2025-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在xv6内核中实现copy-on-write fork。按照 Hint 一步步来，需要根据 <code>cowtest</code> 和 <code>usertests</code> 的运行结果不断调试。下面直接给出最终实现。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>在 <code>riscv.h </code>中定义 COW flag</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_C (1L <span class="string">&lt;&lt; 8) // 1 -&gt;</span> copy-on-write flag</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>kalloc.c</code>中定义物理页引用计数数组，并使用锁保证互斥访问。与引用计数相关的新函数要在<code>defs.h</code>中声明。</li>
<li><strong>xv6 默认在两个处理器上运行</strong>，代码中要考虑基本的同步互斥。</li>
</ol>
<h2 id="kalloc-c"><a href="#kalloc-c" class="headerlink" title="kalloc.c"></a>kalloc.c</h2><ol>
<li><p>定义引用计数结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_PAGES  ((PHYSTOP - KERNBASE)) / PGSIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct to maintain the ref counts</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> count[NUM_PAGES];</span><br><span class="line">&#125; page_refc;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>NUM_PAGES</code>计算了可用物理页的页数，物理空间是从<code>0x80000000</code>开始的。</p>
</li>
<li><p>数组的大小必须在编译时确定，而 <code>end</code> 是一个运行时确定的地址，因此下面写法是不对的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_PAGES ((PHYSTOP - end) / PGSIZE)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>完成管理页引用计数的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_ref_count</span><span class="params">()</span>&#123;</span><br><span class="line">  initlock(&amp;page_refc.lock, <span class="string">&quot;ref_count_lock&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_PAGES; i++) &#123;</span><br><span class="line">    page_refc.count[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increase_ref_count</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  acquire(&amp;page_refc.lock);</span><br><span class="line">  <span class="type">int</span> index = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= NUM_PAGES) &#123;</span><br><span class="line">    release(&amp;page_refc.lock);</span><br><span class="line">    panic(<span class="string">&quot;invalid ref count index&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  page_refc.count[index]++;</span><br><span class="line">  release(&amp;page_refc.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only use in kfree()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrease_ref_count</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  acquire(&amp;page_refc.lock);</span><br><span class="line">  <span class="type">int</span> index = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= NUM_PAGES) &#123;</span><br><span class="line">    release(&amp;page_refc.lock);</span><br><span class="line">    panic(<span class="string">&quot;invalid ref count index&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (page_refc.count[index] == <span class="number">0</span>) &#123;</span><br><span class="line">    release(&amp;page_refc.lock);</span><br><span class="line">    panic(<span class="string">&quot;decrease_ref_count: ref count already 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  page_refc.count[index]--;</span><br><span class="line">  release(&amp;page_refc.lock);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_ref_count</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">  acquire(&amp;page_refc.lock);</span><br><span class="line">  <span class="type">int</span> index = (pa - KERNBASE) / PGSIZE;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= NUM_PAGES) &#123;</span><br><span class="line">    release(&amp;page_refc.lock);</span><br><span class="line">    panic(<span class="string">&quot;invalid ref count index&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ref_count = page_refc.count[index];</span><br><span class="line">  release(&amp;page_refc.lock);</span><br><span class="line">  <span class="keyword">return</span> ref_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在初始化时，引用计数为0</li>
<li>注意索引值的计算方式，要减去 <code>0x80000000</code></li>
<li>在这些函数中要做参数检查，<code>panic</code>时释放锁</li>
</ul>
</li>
<li><p>更改 <code>kinit</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  init_ref_count();</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    increase_ref_count((uint64)p);</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>freerange</code>中要调用<code>kfree</code>，而<code>kfree</code>中会将页引用计数减 1，这导致页引用计数会变为-1，所以要先将页引用计数加 1，保证初始化后空闲页的引用计数为 0</li>
</ul>
</li>
<li><p>更改 <code>kfree</code>&#x2F;<code>kalloc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  decrease_ref_count((uint64)pa);</span><br><span class="line">  <span class="keyword">if</span> (get_ref_count((uint64)pa) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    increase_ref_count((uint64)r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="uvmcopy"><a href="#uvmcopy" class="headerlink" title="uvmcopy"></a>uvmcopy</h2><p>修改<code>uvmcopy()</code>将父进程的物理页映射到子进程，而不是分配新页。在子进程和父进程的PTE中清除<code>PTE_W</code>标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">// char *mem;</span></span><br><span class="line">  <span class="comment">// Page-by-page traversal by logical address (VA)</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    <span class="comment">// Read-only pages don&#x27;t need to add the COW flag</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_W)&#123;</span><br><span class="line">      *pte &amp;= ~PTE_W; <span class="comment">//  Clear PTE_W in the PTEs of parent.</span></span><br><span class="line">      *pte |= PTE_C;  <span class="comment">// set Copy-On-Write flag</span></span><br><span class="line">    &#125;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// map the parent&#x27;s physical pages into the child, instead of allocating new pages</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    increase_ref_count(pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只有原先是可写页的才设置 COW 位；只读页不会触发后续的 COW 机制</li>
</ul>
<h2 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h2><p>修改<code>usertrap()</code>以识别页面错误。当COW页面出现页面错误时，使用<code>kalloc()</code>分配一个新页面，并将旧页面复制到新页面，然后将新页面添加到PTE中并设置<code>PTE_W</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">        <span class="comment">// page fault triggered by the store directive</span></span><br><span class="line">        <span class="comment">// It could be a parent process or a child process</span></span><br><span class="line">        uint64 va = r_stval();</span><br><span class="line">        va = PGROUNDDOWN(va);</span><br><span class="line">        <span class="keyword">if</span>(va &gt;= MAXVA)&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; (PTE_V)) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span>)&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        uint64 flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*pte &amp; PTE_C)&#123; <span class="comment">// COW</span></span><br><span class="line">            <span class="comment">/* if(get_ref_count(pa) == 1) &#123;</span></span><br><span class="line"><span class="comment">                *pte = (*pte &amp; ~PTE_C) | PTE_W;</span></span><br><span class="line"><span class="comment">              &#125; else &#123; */</span></span><br><span class="line">            <span class="type">char</span> *mem;</span><br><span class="line">            <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)&#123; </span><br><span class="line">                p-&gt;killed = <span class="number">1</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                memmove((<span class="type">void</span> *)mem, (<span class="type">const</span> <span class="type">void</span> *)pa, PGSIZE);</span><br><span class="line">                *pte = PA2PTE((uint64)mem) | (flags &amp; ~PTE_C) | PTE_W;</span><br><span class="line">                kfree((<span class="type">void</span>*)pa);</span><br><span class="line">                <span class="comment">// decrease_ref_count(pa);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="copyout"><a href="#copyout" class="headerlink" title="copyout"></a>copyout</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0, flags;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="keyword">if</span>(va0 &gt;= MAXVA)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; (PTE_V)) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    pa0 = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_C)&#123;</span><br><span class="line">        <span class="type">char</span> *mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memmove((<span class="type">void</span> *)mem, (<span class="type">const</span> <span class="type">void</span> *)pa0, PGSIZE);</span><br><span class="line">            *pte = PA2PTE((uint64)mem) | (flags &amp; ~PTE_C) | PTE_W;</span><br><span class="line">            <span class="comment">// decrease_ref_count(pa0);</span></span><br><span class="line">            kfree((<span class="type">void</span>*)pa0);</span><br><span class="line">            pa0 = (uint64)mem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="usertests-调试"><a href="#usertests-调试" class="headerlink" title="usertests 调试"></a>usertests 调试</h2><ol>
<li><p><code>MAXVAplus</code> ：需要添加检查 va 的合法性，不能大于规定的最大地址。</p>
</li>
<li><p><code>copyout</code>：需要添加检查 pte 的合法性。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lilpig/p/17339689.html#%E9%80%9A%E8%BF%87cowtest">参考</a></p>
</li>
<li><p><code>FAILED -- lost some free pages 31512 (out of 31967)</code>：xv6 默认在两个处理器上运行，访问 <code>page_ref_count</code>数组时需要加锁，互斥访问。 </p>
</li>
<li><p>其他 test failed 多与 <code>kalloc.c</code>相关</p>
</li>
<li><p>一些错误会给出<code>sepc</code>，到<code>kernel.asm</code>中查看是哪条指令导致的</p>
</li>
</ol>
<h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><ol>
<li><p>特别注意 xv6 默认在两个处理器上运行，还要考虑进程间的同步。一个典型例子，在 usertrap 和 copyout 中有一段相同的逻辑，用于处理 COW。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*pte &amp; PTE_C)&#123; <span class="comment">// COW</span></span><br><span class="line">    <span class="keyword">if</span>(get_ref_count(pa) == <span class="number">1</span>) &#123;</span><br><span class="line">        *pte = (*pte &amp; ~PTE_C) | PTE_W;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *mem;</span><br><span class="line">        <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)&#123; </span><br><span class="line">            p-&gt;killed = <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memmove((<span class="type">void</span> *)mem, (<span class="type">const</span> <span class="type">void</span> *)pa, PGSIZE);</span><br><span class="line">            *pte = PA2PTE((uint64)mem) | (flags &amp; ~PTE_C) | PTE_W;</span><br><span class="line">            kfree((<span class="type">void</span>*)pa);</span><br><span class="line">            <span class="comment">// decrease_ref_count(pa);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在判断当前物理页的引用计数为1时，直接改 pte 中的 Flags ，后续直接写入这里。在默认的 xv6 中运行 <code>threetest</code>会出错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">three: scause <span class="number">0x000000000000000d</span></span><br><span class="line">sepc=<span class="number">0x0000000080000330</span> stval=<span class="number">0x000000000000270f</span></span><br><span class="line">panic: kerneltrap</span><br></pre></td></tr></table></figure>

<p>在限定只使用一个CPU后又能顺利通过。</p>
</li>
<li><p><code>usertrap</code>中处理的是来自用户态下的 page fault，而在内核态下触发的 page fault 无法转到<code>usertrap</code>处理，所以需要在发生page fault 的地方就地处理，也就有了<code>copyout </code>的改动。只有这里才会触发。来自用户态和内核态的异常处理方式不同。</p>
</li>
</ol>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/22/6-S081-Lecture-8-Page-Faults/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/22/6-S081-Lecture-8-Page-Faults/" class="post-title-link" itemprop="url">6.S081-Lecture 8 Page Faults</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-22 18:27:21" itemprop="dateCreated datePublished" datetime="2025-01-22T18:27:21+08:00">2025-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-19 21:50:40" itemprop="dateModified" datetime="2025-02-19T21:50:40+08:00">2025-02-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Page-Fault-Basics"><a href="#Page-Fault-Basics" class="headerlink" title="Page Fault Basics"></a>Page Fault Basics</h2><p>虚拟内存有两个主要的优点：</p>
<ul>
<li>隔离性。不同进程间的隔离，每个进程都拥有并使用自己的内存空间。同一进程中内核空间和用户空间的隔离。</li>
<li>level of indirection，提供了一层抽象。处理器和所有的指令都可以使用虚拟地址，而内核会定义从虚拟地址到物理地址的映射关系。</li>
</ul>
<p>到目前为止，内存地址映射相对来说比较静态。不管是 user page table 还是 kernel page table，都是在最开始的时候设置好，之后就不会再做任何变动。<code>page fault</code>可以让地址映射关系变得动态起来。通过 page fault，内核可以更新page table。</p>
<p>当发生 page fault 时，内核需要什么样的信息才能够响应 page fault：</p>
<ul>
<li><p>引起 page fault 的内存地址，即触发 page fault 的源。<code>STVAL</code>寄存器中会保留这个值。注意区分，触发 page fault 的地址与导致 page fault 的指令的地址。</p>
</li>
<li><p>引起 page fault 的原因类型。针对不同场景下的 page fault 有不同的响应。可以分为：</p>
<ul>
<li>因为 load 指令触发的 page faultr</li>
<li>因为 store 指令触发的 page fault</li>
<li>因为 jump 指令触发的 page fault</li>
</ul>
<p><code>SCAUSE</code>寄存器中保存了 trap 机制中进入到 supervisor mode 的原因。最高位：0（同步异常）、1（异步中断）。13 表示是因为load引起的page fault；15表示是因为store引起的page fault；12表示是因为指令执行引起的page fault。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec08_scause_coding.png"></p>
</li>
<li><p>引起 page fault 的 PC 值。作为trap处理代码的一部分，这个地址存放在<code>SEPC</code>寄存器中，并同时会保存在trapframe-&gt;epc中。因为这条指令触发了 page fault，该指令并没有正确执行，需要在处理完缺页异常后重新执行。</p>
</li>
</ul>
<h2 id="Lazy-Page-Allocation"><a href="#Lazy-Page-Allocation" class="headerlink" title="Lazy Page Allocation"></a>Lazy Page Allocation</h2><p><code>sbrk</code>是XV6提供的系统调用，它使得用户应用程序能扩大自己的heap。进程的数据结构中的字段<code>p-&gt;sz</code>用来指示 heap 上使用的空间大小。当调用 <code>sbrk</code>时，它的参数是整数，代表了想要申请的字节数量。当<code>sbrk</code>实际发生或者被调用的时候，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间，然后将内存内容初始化为0。这样，应用程序可以通过多次<code>sbrk</code>系统调用来增加它所需要的内存。</p>
<p>在XV6中，<code>sbrk</code>的实现默认是 eager allocation。即一旦调用了<code>sbrk</code>，内核会立即分配应用程序所需要的物理内存。但是实际上，对于应用程序来说很难预测自己需要多少内存，所以通常来说，应用程序倾向于申请多于自己所需要的内存。</p>
<p>另一种思路是 lazy allocation，核心思想非常简单，<code>sbrk</code>系统调用基本上不做任何事情，唯一需要做的事情就是将<code>p-&gt;sz</code>增加n，其中 n 是需要新分配的内存字节数量。但是内核在当下并不会实际分配任何物理内存。之后在某个时间点，应用程序使用到了新申请的那部分内存，这时会触发 page fault，因为我们还没有将新的内存映射到 page table。</p>
<p>所以，当我们遇到了一个 page fault ，相应的虚拟地址小于当前<em>p-&gt;sz</em>，同时大于 stack，那么我们就知道这是一个来自于 heap 的地址，但是内核还没有分配任何物理内存。所以在 page fault handler 中，通过kalloc函数分配一个内存page；初始化这个 page 内容为0；将这个内存page映射到 user page table 中；最后重新执行指令。</p>
<p>如何在 xv6 的基础上修改为 lazy allocation：</p>
<ul>
<li>修改<code>sys_sbrk</code>函数，<code>sys_sbrk</code>会完成实际增加应用程序的地址空间，分配内存等等一系列相关的操作。现在只让它只对<code>p-&gt;sz</code>加 n，并不执行增加内存的操作。</li>
<li>接下来的执行因为 lazy allocation 产生两种错误：<ul>
<li>要写入某个地址时，该空间还没有实际分配，就会触发 page fault。修改<code>trap.c</code>中的<code>usertrap</code>函数，判断类型，<code>kalloc</code>分配物理空间，全零填充，<code>mappages</code>完成地址映射。 不同于其他异常，这里要重新执行发生异常的指令。</li>
<li>要释放某块空间时，即尝试在释放一个并没有 map 的 page。唯一的原因是<code>sbrk</code>增加了p-&gt;sz，但是应用程序还没有使用那部分内存，那么对应的物理内存还没有分配。</li>
</ul>
</li>
</ul>
<h2 id="Zero-Fill-On-Demand"><a href="#Zero-Fill-On-Demand" class="headerlink" title="Zero Fill On Demand"></a>Zero Fill On Demand</h2><p>在用户程序的地址空间中，存在不同的<code>segment</code>：.text（程序的指令）、.data（初始化了的全局变量）、.bss（未被初始化或初始化为0的全局变量）等。</p>
<p>在程序执行 <code>exec</code> 时，操作系统需要为新的地址空间分配虚拟内存，通常包括 <code>.text</code>、<code>.data</code> 和 <code>.bss</code> 段。</p>
<p><strong><code>.bss</code> 段</strong> 存储未初始化的全局变量。这段区域往往需要初始化为零，但其内容可能会占用大量虚拟地址空间。</p>
<ul>
<li><code>.bss</code> 可能涉及许多连续虚拟页，每页都需要全零初始化。</li>
<li>如果直接为每个 <code>.bss</code> 页分配物理内存并清零，启动时会造成性能损失和内存浪费。</li>
</ul>
<p>共享单页全零映射：</p>
<ul>
<li>预先分配 <strong>一个全零物理页</strong>（Zero Page），其物理内容完全为 0。</li>
<li>所有需要全零的 <code>.bss</code> 页（虚拟地址空间）都指向该同一个零页。</li>
<li>页表中设置这些映射为 <strong>只读</strong> 以避免数据篡改。</li>
<li>当程序试图向 <code>.bss</code> 段写入数据时，由于全零页是只读的，触发 **页错误 (Page Fault)**。</li>
<li>操作系统捕获异常，为该虚拟页分配新的物理内存，并将全零内容复制到新页。更新PTE中的映射关系，要设置成可读可写。</li>
</ul>
<h2 id="Copy-On-Write-Fork"><a href="#Copy-On-Write-Fork" class="headerlink" title="Copy On Write Fork"></a>Copy On Write Fork</h2><p>当 Shell 处理指令时，它会通过<code>fork</code>创建一个子进程。子进程执行的第一件事情就是调用<code>exec</code>运行一些其他程序，比如运行echo。现在的情况是，<code>fork</code>创建了<code>Shell</code>地址空间的一个完整的拷贝，而<code>exec</code>做的第一件事情就是丢弃这个地址空间，取而代之的是一个包含了<code>echo</code>的地址空间。</p>
<p> <strong>Copy-on-Write Fork</strong> 的工作原理：</p>
<ol>
<li><p>父子进程共享同一物理内存页：</p>
<ul>
<li>在 <code>fork()</code> 时，操作系统 <strong>不复制内存</strong>，而是将父子进程的页表项指向相同的物理内存页。</li>
<li>这些内存页被标记为 <strong>只读</strong>（read-only），这样父子进程共享同一内存数据，避免了不必要的复制。</li>
</ul>
</li>
<li><p>写时触发复制：</p>
<ul>
<li>当父进程或子进程尝试写入这些共享的内存页时，由于页表中的内存页是只读的，这会<strong>触发 Page Fault</strong>。</li>
<li>操作系统捕获到这个 Page Fault 后，<strong>为写操作的进程分配新的物理内存页</strong>，并将原来的内存页的内容复制到新分配的页中。新分配的页的 PTE 权限位为可读写，原来共享的物理内存页的 PTE 权限位页变为可读写。</li>
<li>写操作的进程使用新的物理内存页，其他进程仍然共享原有的内存页，直到它们也触发写操作。</li>
</ul>
</li>
</ol>
<blockquote>
<p>学生提问：当发生page fault时，我们其实是在向一个只读的地址执行写操作。内核如何能分辨现在是一个copy-on-write fork的场景，而不是应用程序在向一个正常的只读地址写数据。是不是说默认情况下，用户程序的PTE都是可读写的，除非在copy-on-write fork的场景下才可能出现只读的PTE？</p>
<p>Frans教授：内核必须要能够识别这是一个copy-on-write场景。几乎所有的page table硬件都支持了这一点。对于PTE的标志位，我之前介绍过第0bit到第7bit，但是没有介绍最后两位RSW。这两位保留给supervisor software使用，supervisor softeware指的就是内核。内核可以随意使用这两个bit位。所以可以做的一件事情就是，将bit8标识为当前是一个copy-on-write page。</p>
</blockquote>
<p>在 Copy-on-Write Fork 的实现中，父子进程共享物理内存页，带来一个新的问题：当父进程退出时是否要释放全部的物理 page。所以我们需要对于每一个物理内存页的引用进行计数，当我们释放虚拟页时，我们将物理内存页的引用数减1，如果引用数等于0，那么我们就能释放物理内存页。</p>
<h2 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h2><ul>
<li>从磁盘读文件到内存中开销大</li>
<li>内存空间有限</li>
<li>不是所有调入内存的页都会被访问，造成浪费</li>
</ul>
<p>在 <strong>Demand Paging（按需分页）</strong>中，进程启动时，<strong>只有必要的页（如程序入口点所在页）被加载到物理内存</strong>，其余的页仍然存放在磁盘（swap 或文件系统）中，对应的 PTE 中 Valid 为 0。只有当进程真正访问这些未加载的页时，才会触发<strong>缺页异常（Page Fault）</strong>，然后操作系统将所需页面加载到内存中，并更新页表。</p>
<p>当内存空间耗尽时，会将一些页调出内存，这就涉及到页面替换算法。如 LRU，这就涉及到 PTE 中的另两个标志位：</p>
<ul>
<li>Accessed bit，一段时间内该页被读或被写都会置位</li>
<li>Dirty bit，一段时间内该页被写会置位</li>
</ul>
<h2 id="Memory-Mapped-Files"><a href="#Memory-Mapped-Files" class="headerlink" title="Memory Mapped Files"></a>Memory Mapped Files</h2><p><strong>Memory-Mapped Files（MMF，内存映射文件）</strong> 是一种 <strong>将文件内容映射到进程的虚拟内存地址空间</strong> 的技术。这样，应用程序可以像访问普通内存一样访问文件，而不需要传统的 <code>read()</code> 和 <code>write()</code> 系统调用，提高 I&#x2F;O 访问效率。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/14/6-S081-Lab4-Traps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/14/6-S081-Lab4-Traps/" class="post-title-link" itemprop="url">6.S081-Lab4-Traps</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-14 19:26:09" itemprop="dateCreated datePublished" datetime="2025-01-14T19:26:09+08:00">2025-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-17 13:53:18" itemprop="dateModified" datetime="2025-01-17T13:53:18+08:00">2025-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><ol>
<li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?<br> a0-7.<br> a2 holds 13，because 13 is the third parameter.</li>
<li>Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)<br> The function f and g are handled with inline optimization. As can be seen from the code li a1,12, main directly computes the result and stores it.</li>
<li>At what address is the function printf located?<br> ra &#x3D; 0x30，0x30 + 0x608 &#x3D; 0x638</li>
<li>What value is in the register ra just after the jalr to printf in main?<br> jalr: PC + 4 &#x3D; 0x38</li>
<li>Run the following code: unsigned int i &#x3D; 0x00646c72;printf(“H%x Wo%s”, 57616, &amp;i);What is the output? The output depends on that fact that the RISC-V is little-endian.<br>If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?<br> 57616 &#x3D; 0xe110; little-endian:0x00646c72-&gt;72-6c-64-00; output: Hell0 World<br> For big-endian, i should be changed to 0x726c6400 without changing 57616</li>
<li>In the following code, what is going to be printed after ‘y&#x3D;’? (note: the answer is not a specific value.) Why does this happen?<br>printf(“x&#x3D;%d y&#x3D;%d”, 3);<br> The result printed after y&#x3D; depends on the data previously saved in a2</li>
</ol>
<h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>在 kernel&#x2F;printf.c 中实现一个<code>backtrace</code>函数，来打印堆栈上的函数调用列表。在 sys_sleep 中插入对该函数的调用，然后运行 bttest，调用 sys_sleep。 输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">backtrace:</span><br><span class="line">0x00000000800020c8</span><br><span class="line">0x0000000080001fa4</span><br><span class="line">0x0000000080001c8e</span><br></pre></td></tr></table></figure>

<p>bttest 之后退出 qemu。 在终端中：地址可能略有不同，但如果运行 addr2line -e kernel&#x2F;kernel（或 riscv64-unknown-elf-addr2line -e kernel&#x2F;kernel）并粘贴上述地址，则如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ addr2line -e kernel/kernel</span><br><span class="line">    0x0000000080002de2</span><br><span class="line">    0x0000000080002f4a</span><br><span class="line">    0x0000000080002bfc</span><br></pre></td></tr></table></figure>

<p>编译器会在每个堆栈帧中放置一个帧指针，用于保存调用者帧指针的地址。<code>backtrace</code>应使用这些帧指针在堆栈中向上走动，并在每个堆栈帧中打印保存的返回地址。</p>
<p>背景：</p>
<ul>
<li>xv6 为 stack 以 page 为单位分配空间。下面的实现简单根据 fp 是否还在当前页中来判断是否栈回溯到无效区域。</li>
<li>stack frame 是 stack 的一部分，stack 中包含多个 stack frame。</li>
<li>每次调用函数时，由编译器生成的指令完成栈帧的分配。函数返回后，栈帧被释放（通常通过调整栈指针 sp 完成）。</li>
<li>帧指针 <code>fp</code> 指向当前栈帧的底部，栈指针 <code>sp</code> 指向当前栈的顶部。也就是<code>sp</code>会指向当前栈帧的顶部。</li>
</ul>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fp, ra;</span><br><span class="line">  uint64 start, end;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  fp = r_fp();</span><br><span class="line">  end = PGROUNDUP(fp);</span><br><span class="line">  start = PGROUNDDOWN(fp);</span><br><span class="line">  <span class="keyword">while</span> (fp &gt; start &amp;&amp; fp &lt; end)</span><br><span class="line">  &#123;</span><br><span class="line">    ra = *(uint64 *)(fp - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ra);</span><br><span class="line">    fp = *(uint64 *)(fp - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>while (fp &gt; start &amp;&amp; fp &lt;= end)</code>是错的。<code>PGROUNDUP(sz)</code> 表示的是将给定地址向下取整到页面大小的倍数，实际已经不是当前页的地址范围了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br></pre></td></tr></table></figure>

<h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>添加一个新的<code>sigalarm(interval, handler)</code>系统调用，如果一个程序调用了<code>sigalarm(n, fn)</code>，那么每当程序消耗了CPU时间达到n个tick，内核应当使应用程序函数<code>fn</code>被调用。当<code>fn</code>返回时，应当在它离开的地方恢复执行。在XV6中，一个tick是一段相当任意的时间单元，取决于硬件计时器生成中断的频率。如果一个程序调用了<code>sigalarm(0, 0)</code>，系统应当停止生成周期性的报警调用。</p>
<h3 id="test0-invoke-handler"><a href="#test0-invoke-handler" class="headerlink" title="test0: invoke handler"></a>test0: invoke handler</h3><p>首先修改内核以跳转到用户空间中的报警处理程序，这将导致<code>test0</code>打印“alarm!”。不用担心输出“alarm!”之后会发生什么；在打印“alarm！” 程序后崩溃。</p>
<p>实现：</p>
<ul>
<li><p>按照提示，完成添加系统调用的常规操作。目前来说，<code>sys_sigreturn</code>返回零。</p>
</li>
<li><p>在<code>proc.h</code>中的<code>struct proc</code>新增3个新字段，并在<code>allocproc()</code>中完成初始化，在<code>freeproc()</code>中重置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sigticks;                <span class="comment">// the alarm interval</span></span><br><span class="line"><span class="type">void</span> (*sighandler)();        <span class="comment">// sigalarm handler function </span></span><br><span class="line"><span class="type">int</span> passedticks;             <span class="comment">// keep track of how many ticks have passed since the last call to a process&#x27;s alarm handler</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>sysproc.c</code>中实现系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  <span class="type">void</span> (*handler)();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, (uint64 *)&amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;sigticks = ticks;</span><br><span class="line">  p-&gt;sighandler = handler;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>usertrap()</code>，以便当进程的报警间隔期满时，用户进程执行处理程序函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    p-&gt;passedticks++;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;passedticks == p-&gt;sigticks) &#123;</span><br><span class="line">        p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;sighandler;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>想要从 trap 返回用户空间后执行警报处理函数，修改<code>p-&gt;trapframe-&gt;epc</code>，这里的值会被写入<code>SEPC</code>寄存器，在执行 <code>SRET</code>时被写入<code>PC</code>寄存器。</li>
</ul>
</li>
</ul>
<p>问题：</p>
<ul>
<li>直接将处理函数的值写入<code>p-&gt;trapframe-&gt;epc</code>，这里之前的值被覆盖，也就无法返回触发 定时器中断的用户空间处了。</li>
<li><code>sigalarm(0, 0);</code>也没有实现关闭<code>sigalarm</code>的功能。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ alarmtest                                                             test0 start      </span><br><span class="line">...alarm!                    </span><br><span class="line">test0 passed     </span><br><span class="line">test1 start                             </span><br><span class="line">.alarm!                                                  </span><br><span class="line">alarm!                                                       </span><br><span class="line">.alarm!                                                         </span><br><span class="line">.alarm!                                                          </span><br><span class="line">alarm!                                                             </span><br><span class="line">alarm!                                                          </span><br><span class="line">.alarm!                                                         </span><br><span class="line">alarm!                                                            </span><br><span class="line">.alarm!                                                        </span><br><span class="line">alarm!                                                              </span><br><span class="line">test1 failed: foo() executed fewer times than it was called            </span><br><span class="line"><span class="title function_">usertrap</span><span class="params">()</span>: unexpected scause 0x000000000000000c pid=<span class="number">3</span>                </span><br><span class="line">            sepc=<span class="number">0xfffffffffffffac8</span> stval=<span class="number">0xfffffffffffffac8</span></span><br></pre></td></tr></table></figure>

<h3 id="test1-test2-resume-interrupted-code"><a href="#test1-test2-resume-interrupted-code" class="headerlink" title="test1&#x2F;test2(): resume interrupted code"></a>test1&#x2F;test2(): resume interrupted code</h3><p>要解决上述的问题，必须确保完成报警处理程序后，返回到用户程序最初被计时器中断的指令执行。必须确保寄存器内容恢复到中断时的值，以便用户程序在报警后可以不受干扰地继续运行。</p>
<p>简单来说就是要在执行处理函数前保存当前的环境，处理程序需要在完成后调用<code>sigreturn</code>来恢复环境。</p>
<p>同时，如果处理程序还没有返回，就不该再次调用它。假设处理程序执行的时间很长，在此期间又过了 sigticks 个 tick，此时不能再次调用处理函数。</p>
<p>实现：</p>
<ul>
<li><p>为了保存跳转到处理函数之前的环境，新设一个<code>trapframe</code>结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">savedtrapframe</span>;</span></span><br></pre></td></tr></table></figure>

<p>并在<code>allocproc()</code>中分配空间，在<code>freeproc()</code>中释放空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocproc</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;savedtrapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">   freeproc(p);</span><br><span class="line">   release(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// freeproc</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;savedtrapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;savedtrapframe);</span><br><span class="line">  p-&gt;savedtrapframe = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>trap.c</code>中保存<code>p-&gt;trapframe</code>，在处理函数完成（调用 <code>sigreturn</code>）后恢复。<code>sigreturn</code> 处于内核空间，恢复<code>p-&gt;trapframe</code>就恢复了定时器中断发生时的PC。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">	p-&gt;passedticks++;</span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;passedticks == p-&gt;sigticks) &amp;&amp; (p-&gt;ishandling == <span class="number">0</span>)) &#123;</span><br><span class="line">      p-&gt;ishandling = <span class="number">1</span>;</span><br><span class="line">      memmove(p-&gt;savedtrapframe, p-&gt;trapframe, PGSIZE);</span><br><span class="line">      p-&gt;trapframe-&gt;epc = (uint64)p-&gt;sighandler;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行处理函数前保存当前的环境，处理程序需要在完成后调用<code>sigreturn</code>来恢复环境。</p>
</li>
<li><p>为了防止处理程序重复调用，设立一个参数来指示当前是否在执行处理函数。同时这个参数也可以用来实现<code>sigalarm(0, 0)</code>关闭<code>sigalarm</code>的功能，只要该参数指示当前在执行处理函数，自然就关闭了sigalarm。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ishandling;   <span class="comment">// handler function is running? 1 is yes, 0 is no</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;savedtrapframe, PGSIZE);</span><br><span class="line">  p-&gt;ishandling = <span class="number">0</span>;</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  <span class="type">void</span> (*handler)();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, (uint64 *)&amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ticks == <span class="number">0</span> &amp;&amp; handler == <span class="number">0</span>) &#123;</span><br><span class="line">    p-&gt;ishandling = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;sigticks = ticks;</span><br><span class="line">  p-&gt;sighandler = handler;</span><br><span class="line">  p-&gt;ishandling = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>passedticks</code>的重置放在了<code>sigreturn</code>中，也就是处理函数的执行间隔是：上一次执行完成到下一次开始执行中的间隔是<code>sigticks</code>个tick。</p>
</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/09/6-S081-Lecture-6-Trap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/09/6-S081-Lecture-6-Trap/" class="post-title-link" itemprop="url">6.S081-Lecture 6 Trap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-09 11:07:41" itemprop="dateCreated datePublished" datetime="2025-01-09T11:07:41+08:00">2025-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-22 18:25:38" itemprop="dateModified" datetime="2025-01-22T18:25:38+08:00">2025-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有三种事件会导致CPU暂停当前普通指令的执行，强制将控制权转移给处理该事件的特殊代码。</p>
<ul>
<li>系统调用 syscall：用户程序执行 <strong>ecall</strong> 指令要求内核为其做某事时。</li>
<li>指令异常 exception：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址。</li>
<li>设备中断 interrupt：外部设备发出请求信号，例如当磁盘硬件完成一个读写请求时。</li>
</ul>
<p>前两种来自 CPU 内部（同步），第三种来自 CPU 外部的 I&#x2F;O 设备（异步）。在本课程中这三者统称为<strong>trap</strong>。</p>
<p>trap的执行对当前正常指令流是透明的。通常的顺序是：</p>
<ul>
<li><p>trap迫使控制权转移到内核；</p>
</li>
<li><p>内核保存寄存器和其他状态，以便恢复执行；</p>
</li>
<li><p>内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；</p>
</li>
<li><p>内核恢复保存的状态，并从trap中返回；</p>
</li>
<li><p>代码从原来的地方恢复执行。</p>
</li>
</ul>
<p>Xv6 trap 处理分为四个阶段：</p>
<ul>
<li><p>RISC-V CPU采取的硬件行为，</p>
</li>
<li><p>为内核C代码准备入口的汇编程序，如<code>trampoline.S</code> 中的uservec</p>
</li>
<li><p>处理trap的C 处理程序，</p>
</li>
<li><p>系统调用处理或设备驱动服务。</p>
</li>
</ul>
<h2 id="RISC-V-trap-machinery"><a href="#RISC-V-trap-machinery" class="headerlink" title="RISC-V trap machinery"></a>RISC-V trap machinery</h2><p>每个RISC-V CPU都有一组控制寄存器，当系统发生一个陷阱（trap）时，这些寄存器会被使用或修改以处理 trap。</p>
<p>可能会用到的特权寄存器：</p>
<ol>
<li><p><code>sepc</code> (Supervisor Exception Program Counter)</p>
<ul>
<li>保存发生 trap 时的程序计数器（PC），在 trap 处理完成后，<code>sepc</code> 的值通常用于恢复到 trap 发生的地方继续执行。</li>
<li>当 trap 发生时，硬件会自动将当前 PC 的值保存到 <code>sepc</code>。</li>
<li><code>sret</code>（从trap中返回）指令将<code>sepc</code>复制到<code>pc</code>中。内核可以写<code>sepc</code>来控制<code>sret</code>的返回到哪里。</li>
</ul>
</li>
<li><p><code>stvec</code>(Supervisor Trap Vector Register)</p>
<ul>
<li>内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。</li>
</ul>
</li>
<li><p><code>scause</code>(Supervisor Cause Register)</p>
<ul>
<li>保存导致陷阱的原因</li>
</ul>
</li>
<li><p><code>sstatus</code> (Supervisor Status Register)</p>
<ul>
<li>保存陷阱发生时的系统状态，例如中断使能位。</li>
</ul>
</li>
<li><p><code>satp</code> (Supervisor Address Translation and Protection Register)</p>
<ul>
<li>保存根页表的地址</li>
</ul>
</li>
<li><p><code>SSRATCH</code>(Supervisor Scratch Register)</p>
<ul>
<li><p>是一个通用寄存器，没有固定用途</p>
</li>
<li><p>保存操作系统在进入中断或异常处理前需要暂存的值。</p>
</li>
</ul>
</li>
</ol>
<p>当需要执行trap时，<strong>RISC-V 硬件</strong>对所有的trap类型（除定时器中断外）进行以下操作：</p>
<ol>
<li>如果该trap是设备中断，且<code>sstatus</code> <strong>SIE</strong>位为0，则不执行以下任何操作。</li>
<li>通过清除SIE来禁用中断。</li>
<li>复制<code>pc</code>到<code>sepc</code>。</li>
<li>将当前模式（用户态或特权态）保存在<code>sstatus</code>的<strong>SPP</strong>位。</li>
<li>在<code>scause</code>设置该次trap的原因。</li>
<li>将模式转换为特权态。</li>
<li>将<code>stvec</code>复制到<code>pc</code>。</li>
<li>从新的<code>pc</code>开始执行。</li>
</ol>
<p>切换为 supervisor mode 后可以读写上述的特权寄存器和可以使用 PTE_U 标志位为 0 的PTE。supervisor mode 中的代码并不能读写任意物理地址。在supervisor mode中，就像普通的用户代码一样，也需要通过page table来访问内存，受限于当前页表设置的虚拟地址。。</p>
<h2 id="Trap-代码执行流程"><a href="#Trap-代码执行流程" class="headerlink" title="Trap 代码执行流程"></a>Trap 代码执行流程</h2><p>下面以 shell 中调用 write 系统调用为例子说明 trao 代码的执行流程。</p>
<p>从Shell的角度来说，write 就是个Shell代码中的C函数调用，但是实际上，write 通过执行ECALL指令来执行系统调用。ECALL指令会切换到具有supervisor mode的内核中。在这个过程中，内核中执行的第一个指令是一个由汇编语言写的函数，叫做<code>uservec</code>。这个函数是内核代码<code>trampoline.s</code>文件的一部分。所以执行的第一个代码就是这个uservec汇编函数。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_trap_flow.png" alt="trap_flow"></p>
<h2 id="ECALL-指令执行之前的状态"><a href="#ECALL-指令执行之前的状态" class="headerlink" title="ECALL 指令执行之前的状态"></a>ECALL 指令执行之前的状态</h2><p><code>sh.c</code>中的 getcmd() 调用了 fprintf() ，fprintf()封装了 write 库函数。可以在 <code>usys.S</code>（由 usys.pl 生成）在查看这个库函数的源代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>首先将系统调用号<code>SYS_write</code>加载到 a7 寄存器，再执行<code>ecall</code>指令，从这里开始代码执行跳转到了内核。内核完成它的工作之后，代码执行会返回到用户空间，继续执行<code>ecall</code>之后的指令<code>ret</code>，最终返回到Shell中。</p>
<p>为了在<code>ecall</code>指令处放置一个断点，可以通过查看由编译过程产生的<code>sh.asm</code>找出这个地址。这里的地址是 <code>0xde4</code>。打好断点，执行，如下图。还可以查看当前寄存器中的值。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb1.jpg"></p>
<p>这里的a0，a1，a2是Shell传递给write系统调用的参数。所以a0是文件描述符2；a1是Shell想要写入字符串的指针；a2是想要写入的字符数。查看<code>stvec</code>中的值，执行<code>ecall</code>后会跳转到这里。</p>
<p>使用 gdb-multiarch 调试，<code>si</code>后无法追踪<code>ecall</code>，而是直接到了<code>ret</code>。所以需要手动打断点，跳转到<code>03ffffff000</code>。另若不在 ecall 后追踪 03ffffff000 而是进入gdb后直接打断点，程序停止运行的 03ffffff000 不是我们所需要的。</p>
<p>从QEMU界面，输入<code>ctrl a + c</code>可以进入到QEMU的console，之后输入<em>info mem</em>，QEMU会打印完整的page table。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_mem1.jpg"></p>
<p>当前的地址属于第一条PTE指向的空间，且这条PTE用户空间可访问，可见当前是在用户态。最后两条PTE的虚拟地址非常大，非常接近虚拟地址的顶端，这两个page分别是trapframe page和trampoline page。它们都没有设置 u 标志，所以用户代码不能访问这两条PTE。一旦我们进入到了supervisor mode，就可以访问这两条PTE了。</p>
<p>即使trampoline page是在用户地址空间的user page table完成的映射，但用户代码不能写它，因为这些page对应的PTE并没有设置PTE_u标志位。这也是为什么trap机制是安全的。</p>
<h2 id="ECALL-指令执行之后的状态"><a href="#ECALL-指令执行之后的状态" class="headerlink" title="ECALL 指令执行之后的状态"></a>ECALL 指令执行之后的状态</h2><p>现在已经到了<code>uservec</code>处，再次打印页表，发现<strong>页表并没有改变</strong>。而且当前的地址属于最后一条PTE指向的空间<code>trampoline</code>，这里没有设置 u 标志。可以访问且程序没有崩溃，说明此时已不是用户态了。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb2.jpg"></p>
<p>查看寄存器，值也没有改变，这里还是用户程序拥有的一些寄存器内容。接下<code>uservec</code>中的代码就是要保存寄存器中的值。</p>
<p>ecall实际上只会改变三件事情：</p>
<ul>
<li>user mode 改到 supervisor mode</li>
<li>将 PC 的值保存在了<code>SEPC</code>寄存器</li>
<li>跳转到 <code>STVEC</code> 寄存器指向的指令</li>
</ul>
<p>RISC-V秉持了这样一个观点：<code>ecal</code>l只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这样能为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。</p>
<h2 id="uservec-函数"><a href="#uservec-函数" class="headerlink" title="uservec 函数"></a>uservec 函数</h2><p>现在程序位于trampoline page的起始，也是uservec函数的起始。现在要做的第一件事情就是保存寄存器的内容。在RISC-V中，supervisor mode下的代码不允许直接访问物理内存。所以只能使用page table中的内容。</p>
<p>对于保存用户寄存器，XV6在RISC-V上的实现包括了两个部分:</p>
<ol>
<li><p>XV6在每个user page table映射了trapframe page，这样每个进程都有自己的trapframe page。这个page中放置了<code>trapframe</code>结构体（定义在<code>proc.h</code>），有用来保存用户寄存器的32个空槽位和5个特殊用途槽位（对应了特殊的寄存器）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>比如第一个数据保存了kernel page table地址，这将会是trap处理代码将要加载到<code>SATP</code>寄存器的数值。这些值的设置在<code>usertrapret</code>函数中。</p>
</li>
<li><p><code>SSCRATCH</code>寄存器。它在这里的作用就是保存另一个寄存器的值，并将自己的值加载给另一个寄存器。RISC-V有一个指令<code>csrrw</code>允许交换任意两个寄存器的值。</p>
<p><code>csrrw</code>指令执行前，<code>SSCRATCH</code>寄存器中保存trapframe page的起始地址，a0寄存器保存的是write函数的第一个参数。这里换值，是为了下面使用a0寄存器而又要保存原值。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb3.jpg"></p>
</li>
</ol>
<p><strong>当与 a0 寄存器进行交换时，trapframe page的地址是怎么出现在<code>SSCRATCH</code>寄存器中的？</strong></p>
<p>​	在内核<strong>上一次</strong>切换回用户空间时，内核会执行set sscratch指令，将这个寄存器的内容设置为0x3fffffe000，也就是trapframe page的虚拟地址。具体来说就是，在 <code>trampoline.S</code> 的 <code>userret</code> 的最后两行，也是内核返回到用户空间前的最后两行代码。内核已经提前设置了a0保存的是trapframe地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line"># return to user mode and user pc.</span><br><span class="line"># usertrapret() set up sstatus and sepc.</span><br><span class="line">sret</span><br></pre></td></tr></table></figure>

<p><strong>那 a0 是如何有trapframe page的地址？（有点套娃）</strong></p>
<p>​	无论是内核启动后第一次切换到用户空间，还是 trap 完成后返回到用户空间，都要执行<code>sret</code> 流程。在 xv6 中，<code>sret</code> 被封装在 <code>trampoline.S</code> 的 <code>userret</code> 函数中。大概流程：</p>
<ul>
<li>要切换到用户空间时，调用<code>trap.c/usertrapret()</code>。详见下文。</li>
<li><code>usertrapret()</code>再调用 <code>trampoline.S</code> 中的 <code>userret</code> 函数，并为<code>userret</code> 设置参数TRAPFRAME, satp。调用函数时，第一个参数<code>TRAPFRAME</code>当然会存在a0中。也就是说哪怕在处理 trap 时使用的 a0 寄存器也是ok的（a0 在开始时存放了trapframe page的地址），内核会再次设置。</li>
</ul>
<hr>
<p><code>csrrw</code>指令后，a0 中就是trapframe page地址了。接下就是将寄存器中的值保存到trapframe 。</p>
<p>然后开始将 trapframe 中提前设置好的5个特殊值写入寄存器中。首先是加载进程的kernel stack pointer到 sp 寄存器。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb4.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Virtual Address Space:</span><br><span class="line"><span class="number">0x3ffffff000</span> - TRAMPOLINE (trampoline code)</span><br><span class="line"><span class="number">0x3fffffe000</span> - TRAPFRAME (trapframe <span class="keyword">struct</span>)</span><br><span class="line"><span class="number">0x3fffffd000</span> - Guard <span class="title function_">Page</span> <span class="params">(unmapped, invalid access)</span></span><br><span class="line">0x3fffffc000 - Kernel <span class="title function_">Stack</span> <span class="params">(<span class="keyword">for</span> process <span class="number">0</span>)</span></span><br><span class="line">0x3fffffb000 - Guard <span class="title function_">Page</span> <span class="params">(unmapped, invalid access)</span></span><br><span class="line">0x3fffffa000 - Kernel <span class="title function_">Stack</span> <span class="params">(<span class="keyword">for</span> process <span class="number">1</span>)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下一条指令是向 tp 寄存器写入处理器编号。make 时配置了单核运行，所以只能运行在核0上。</p>
<p>下一条指令是向 t0 寄存器写入函数<code>usertrap</code>的指针，这是将要执行的第一个C函数的指针。</p>
<p>下一条指令是向 t1 寄存器写入kernel page table的地址；接下来交换<code>SATP</code>和t1寄存器。这条指令执行完成之后，当前程序会从user page table切换到kernel page table。在QEMU中打印page table，可以看出与之前的page table不一样了。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/lec06_gdb5.jpg"></p>
<p>trampoline 代码在用户空间和内核空间都映射到了同一个地址，所以即使是切换了页表程序仍能运行。至于前面加载的几个值，本来就是内核空间中的地址。</p>
<p>最后一条指令是 <em>jr t0</em>。执行了这条指令，就从 trampoline 跳到内核的C代码中。</p>
<h2 id="usertrap-函数"><a href="#usertrap-函数" class="headerlink" title="usertrap 函数"></a>usertrap 函数</h2><p><code>usertrap</code>函数是位于<code>trap.c</code>文件的一个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>更换中断向量表。当前已经处于内核空间中，此时若发生 trap ，处理方式与处于用户空间不同。</li>
<li>要获取当前进程，因为处于用户空间的参数等数据已被拷贝到 trapframe 中，需要通过proc 来获取。</li>
<li>要保存用户程序计数器，它仍然保存在<code>SEPC</code>寄存器中。因为当程序还在内核中执行时，可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致<code>SEPC</code>寄存器的内容被覆盖。</li>
<li><code>SCAUSE</code>寄存器会根据 trap 的类型不同而设置不同的值，需要据此了解当前 trap 的类型，进而进行不同的处理。</li>
<li><code> p-&gt;trapframe-&gt;epc += 4</code>，因为之前保存的用户 pc 是发生 ecall 指令的地址，返回用户态要执行的是下一条指令。</li>
<li>设置<code>SSTATUS_SIE</code>，Supervisor Interrupt Enable。XV6会在处理系统调用的时候使能中断，这样可以更快地处理中断，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，需要显式的打开中断。</li>
<li>系统调用的核心逻辑由 <code>syscall()</code> 处理，而 <code>usertrap</code> 仅负责识别和转发。</li>
<li>syscall() 中会将系统调用返回值写入<code>trapframe-&gt;a0</code>，当返回到用户空间，trapframe中的 a0 槽位的数值会写到实际的 a0 寄存器。</li>
</ol>
<h2 id="usertrapret-函数"><a href="#usertrapret-函数" class="headerlink" title="usertrapret 函数"></a>usertrapret 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将要返回用户态了，关闭<code>SSTATUS_SIE</code>。 </p>
</li>
<li><p>更换中断向量表，将要返回用户空间了。<code>TRAMPOLINE + (uservec - trampoline)</code> 为什么这么写？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># MAXVA:  MAXVA is actually one bit less than the max allowed by Sv39</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>w_stvec</code>的参数必须是物理地址。</li>
<li><code>TRAMPOLINE </code>是trapframe page的固定虚拟地址，但是映射到物理空间的也是这个地址。</li>
<li><code>uservec - trampoline</code>计算的是绝对偏移量，这样写也便于维护。</li>
</ul>
</li>
<li><p>设置进程的内核栈，<code>p-&gt;kstack</code> 是进程分配到的进程栈的栈底（低地址），<code>p-&gt;kstack + PGSIZE</code>才是栈顶。</p>
</li>
<li><p><code>SSTATUS_SPIE</code> 是 Supervisor Previous Interrupt Enable 位，也在 <code>sstatus</code> 寄存器中。它保存了<strong>上一个模式</strong>的中断使能状态。在异常或系统调用发生时，<code>SPIE</code> 的值 硬件自动保存到 <code>SSTATUS</code> 寄存器中。</p>
</li>
<li><p><code>((void (*)(uint64,uint64))fn)(TRAPFRAME, satp)</code>调用<code>userret</code>函数，并为其准备了参数。</p>
</li>
</ol>
<h2 id="userret-函数"><a href="#userret-函数" class="headerlink" title="userret 函数"></a>userret 函数</h2><p>现在程序执行又到了<code>trampoline.S</code>。<strong>到这里，<code>a0</code>寄存器中放置的是 trapframe page 地址。</strong>其中多次用到了<code>t0</code>寄存器，因为有些指令的操作数只能是寄存器。</p>
<ol>
<li>切换回用户页表。user page table 在<code>usertrapret</code>中作为第二个参数传递给了这里的<code>userret</code>函数，所以存在a1寄存器中。</li>
<li>恢复用户寄存器。<code>trapframe-&gt;a0</code>槽位的值作为返回值写入<code>ra</code>寄存器。</li>
<li>将 trap 前的 a0 寄存器中的值（一直保存在 trapframe中）写入 <code>SSCRATCH</code>，交换<code>SSCRATCH</code>和<code>a0</code>中的值。</li>
<li><code>SRET</code>。具体作用：<ul>
<li>根据 <code>SSTATUS.SPP</code> 位决定返回的模式</li>
<li>跳转到 <code>sepc</code> 中保存的地址</li>
<li>根据 <code>SSTATUS.SPIE</code> 位，恢复之前的中断状态</li>
</ul>
</li>
</ol>
<h2 id="Code-System-call-arguments"><a href="#Code-System-call-arguments" class="headerlink" title="Code: System call arguments"></a>Code: System call arguments</h2><ol>
<li><p>内核的系统调用实现需要找到用户代码传递的参数。</p>
<ul>
<li>用户代码调用系统调用的包装函数，参数首先会存放在寄存器a0、a1…中，<code>trampoline.S</code>将用户寄存器中的值保存到当前进程的trapframe中。函数<code>argint</code>、<code>argaddr</code>和<code>argfd</code>从trap rame中以整数、指针或文件描述符的形式检索第n个系统调用参数。</li>
<li>一些系统调用传递指针作为参数，而内核必须使用这些指针来读取或写入用户内存。但是这些地址可能是恶意的，况且内核页表映射与用户页表映射不一样，所以内核不能使用普通指令从用户提供的地址加载或存储。</li>
</ul>
</li>
<li><p>内核需要将数据复制到到用户提供的地址，例如系统调用需要将结果保存到提供的结构体中。</p>
<ul>
<li><code>fetchstr</code>（kernel&#x2F;syscall.c）</li>
<li><code>copyinstr</code>（kernel&#x2F;vm.c）</li>
<li><code>copyout</code>（kernel&#x2F;vm.c）</li>
</ul>
</li>
</ol>
<h2 id="Traps-from-kernel-space"><a href="#Traps-from-kernel-space" class="headerlink" title="Traps from kernel space"></a>Traps from kernel space</h2><p>Xv6 会根据当前是在用户空间还是内核空间，对<code>stvec</code>寄存器的配置略有不同行为。当处于内核空间时，<code>stvec</code>指向<code>kernelvec</code>上的汇编代码（kernel&#x2F;kernelvec.S）。由于xv6已经在内核中，<code>kernelvec</code>使用内核页表和内核的堆栈指针。</p>
<p><code>kernelvec</code>首先将所有寄存器保存到（被 trap 的）内核栈中，随后跳转到<code>kerneltrap</code>。</p>
<ol>
<li>要保存 trap 发生时的 <code>sepc</code>、<code>sstatus</code> 。因为当前 trao 若是定时器中断，当前进程会放弃 CPU， <code>sepc</code>、<code>sstatus</code>会被覆盖。</li>
<li>同样根据<code>scause</code> 中断号进行不同的处理。主要还是分为设备中断、定时器中断。</li>
<li>当<code>kerneltrap</code>的工作完成时，它需要返回到被中断的代码。也就需要恢复<code>sepc</code>、<code>sstatus</code> 。</li>
</ol>
<p><code>kerneltrap</code>执行完成后，<code>kernelvec</code>从栈中恢复保存的寄存器并执行<code>sret</code>，<code>sret</code>将<code>sepc</code>复制到<code>pc</code>并恢复中断的内核代码。</p>
<p>另，当CPU从用户空间进入内核时，Xv6将CPU的<code>stvec</code>设置为<code>kernelvec</code>的操作并不是首先执行的。内核空间一开始有段运行时间中<code>stvec</code>被设置为<code>uservec</code>，所以在这个窗口期，禁用设备中断是至关重要的。<strong>RISC-V总是在开始使用 trap 时禁用中断</strong>，xv6在设置<code>stvec</code>之前不会再次启用它们。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/29/LKD3-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/29/LKD3-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">LKD3-进程管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-29 23:49:26" itemprop="dateCreated datePublished" datetime="2024-08-29T23:49:26+08:00">2024-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-31 01:04:05" itemprop="dateModified" datetime="2024-08-31T01:04:05+08:00">2024-08-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><p>内核把进程的列表存放在任务队列中（task list）。链表中的每一项都是类型为<code>task_struct</code>的结构，被称为进程描述符（process descriptor）。该结构体定义在<code>include/linux/sched.h/line1172</code>，大约400行。它包含了进程管理中所需的所有信息，如进程状态、进程标识符 (PID)、调度信息、内存管理信息、打开的文件等。<code>task_struct</code> 在进程控制块 (PCB) 中扮演了关键角色，操作系统通过它来管理进程。</p>
<h3 id="分配进程描述符"><a href="#分配进程描述符" class="headerlink" title="分配进程描述符"></a>分配进程描述符</h3><p>2.6以后的内核使用<code>slab</code>分配器动态生成<code>task_struct</code> ，并在栈底创建一个新的结构体<code>thread_info</code>，可以称为线程描述符。<code>thread_info</code> 保存了指向 <code>task_struct</code> 的指针，并且保存了一些与线程执行状态有关的低级别信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/asm/thread_info.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>	*<span class="title">exec_domain</span>;</span>	<span class="comment">/* execution domain */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="type">int</span>			preempt_count;	<span class="comment">/* 0 =&gt; preemptable,</span></span><br><span class="line"><span class="comment">						          &lt;0 =&gt; BUG */</span></span><br><span class="line">	<span class="type">mm_segment_t</span>		addr_limit;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>    <span class="title">restart_block</span>;</span></span><br><span class="line">	<span class="type">void</span> __user		*sysenter_return;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>           previous_esp;   <span class="comment">/* ESP of the previous stack in</span></span><br><span class="line"><span class="comment">						   case of nested (IRQ) stacks */</span></span><br><span class="line">	__u8			supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span>			uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>task</strong>: 指向与该线程相关的主 <code>task_struct</code> 结构体。<code>task_struct</code> 是进程&#x2F;线程的主要描述符，而 <code>thread_info</code> 主要存储的是与特定线程的执行环境相关的低级信息。</li>
<li><strong>exec_domain</strong>: 指向线程的执行域结构体，执行域决定了线程运行的上下文，特别是在跨平台内核中，这个域可以包含与线程执行相关的特定信息。</li>
<li><strong>flags</strong>: 低级别的标志位，用于记录线程的各种状态和属性。这些标志位可以用于表示线程的某些特定状态，例如是否正在调试中，是否已被杀死等。</li>
</ul>
<ul>
<li><strong>status</strong>: 线程的同步标志，主要用于管理线程的同步状态，例如阻塞、挂起等。</li>
<li><strong>cpu</strong>: 当前线程正在运行的处理器编号。该字段在多核系统中特别重要，指示线程当前在哪个 CPU 核上执行。</li>
<li><strong>preempt_count</strong>: 用于管理线程的抢占计数器。<code>0</code> 表示线程是可抢占的，如果该值为负数，则意味着发生了错误。</li>
<li><strong>addr_limit</strong>: 线程的地址限制，用于定义线程能够访问的内存区域。通常用于区分用户态和内核态的地址空间。</li>
<li><strong>restart_block</strong>: 线程重启块，用于处理系统调用在某些情况下（例如被信号中断）需要重新启动的情况。</li>
<li><strong>sysenter_return</strong>: 指向用户态返回地址，用于 <code>sysenter</code> 系统调用快速路径的返回处理。</li>
<li><strong>previous_esp</strong> (仅在 <code>CONFIG_X86_32</code> 配置下有效): 保存之前栈的 ESP 值，用于嵌套（例如 IRQ）栈的情况。</li>
<li><strong>supervisor_stack</strong> (仅在 <code>CONFIG_X86_32</code> 配置下有效): 用于保存管理栈的值。</li>
<li><strong>uaccess_err</strong>: 记录用户态访问错误，用于在执行用户空间内存访问时检测并处理潜在的错误。</li>
</ul>
<p>对每个进程来说，Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的存储区间中：一个内核态的进程堆栈、另一个就是<code>thread_info</code>。这块区域的大小通常为8192B（2个连续的页），并且第一个页框的起始地址为2^13的倍数。<code>thread_info</code>结构时52个字节长，所以内核栈能扩展到8140字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">thread_union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">stack</span>[<span class="number">2048</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取进程描述符"><a href="#获取进程描述符" class="headerlink" title="获取进程描述符"></a>获取进程描述符</h3><p>内核很容易利用<code>esp</code>寄存器（存放栈指针）的值获取当前CPU上运行的进程的<code>thread_info</code>结构的地址。因为<code>thread_union</code>的长度为8K，且起始地址是2^13的倍数，所以清除<code>esp</code>的低13位后就可得到<code>thread_union</code>的基地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/asm/thread_info.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title function_">current_thread_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)</span><br><span class="line">		(current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>current_thread_info()-&gt;task</code>即可获得当前进程的<code>task_struct</code> 地址。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在 Linux 内核中，进程（<code>task_struct</code>）具有多种状态，用于表示进程当前的活动情况。这些状态定义在 <code>include/linux/sched.h</code> 文件中，并且通过不同的状态值来描述进程的不同执行情况。</p>
<ul>
<li><p>TASK_RUNNING（运行状态）：进程处于可执行状态，表示该进程正在运行或在就绪队列中等待 CPU 时间片。当 CPU 分配给该进程时，它将进入运行状态。</p>
</li>
<li><p>TASK_INTERRUPTIBLE（可中断的睡眠状态）：进程正在等待某个事件（例如 I&#x2F;O 操作完成），并且在等待期间可以被信号中断。如果进程收到信号，它将从睡眠状态唤醒，并处理信号。</p>
</li>
<li><p>TASK_UNINTERRUPTIBLE（不可中断的睡眠状态）：进程也在等待某个事件，但此状态下它不会响应任何信号，也不会被中断，直到等待的事件发生。例如，等待磁盘 I&#x2F;O 完成时，进程可能进入不可中断的睡眠状态。</p>
</li>
<li><p>TASK_STOPPED（停止状态）：进程已停止运行，通常是因为收到了 <code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code> 或 <code>SIGTTOU</code> 等信号。此时进程不会被调度执行，直到收到继续运行的信号（例如 <code>SIGCONT</code>）。</p>
</li>
<li><p>TASK_TRACED（跟踪状态）：进程处于被跟踪状态，通常是因为调试器（例如 <code>gdb</code>）正在跟踪该进程。当一个进程处于跟踪状态时，它不会被调度执行，除非被调试器释放。</p>
</li>
<li><p>EXIT_DEAD（僵尸进程状态）：进程的执行已经终止，所有资源已经被释放，但其父进程还没有通过 <code>wait()</code> 系列系统调用获取子进程的终止状态，导致进程仍然保留在进程表中。这种状态称为僵尸进程（Zombie）。</p>
</li>
<li><p>EXIT_ZOMBIE（僵尸状态）：进程已经终止，内核已经释放了该进程的大部分资源，但仍保留了一些信息以供父进程查询。这些信息会在父进程调用 <code>wait()</code> 后完全释放。</p>
</li>
<li><p>TASK_DEAD（死亡状态）：进程的所有资源都已经释放，进程完全终止。此状态意味着进程已不再存在。</p>
</li>
<li><p>TASK_WAKEKILL（可唤醒状态）：这是一个标志位，表示进程在 <code>TASK_INTERRUPTIBLE</code> 或 <code>TASK_UNINTERRUPTIBLE</code> 状态下，可以被唤醒并被信号杀死。</p>
</li>
<li><p>TASK_WAKING（唤醒中状态）：进程正在从睡眠状态转变为可运行状态，但尚未实际进入 <code>TASK_RUNNING</code> 状态。这是一个过渡状态，表示进程即将被调度器重新调度执行。</p>
</li>
<li><p>TASK_PARKED（暂停状态）：这个状态表示进程被暂停调度，一般与 CPU 热插拔或一些特殊的调度需求相关联。</p>
</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/21/6-S081-Lecture-5-Calling-conventions-and-stack-frames/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/21/6-S081-Lecture-5-Calling-conventions-and-stack-frames/" class="post-title-link" itemprop="url">6.S081-Lecture 5 Calling conventions and stack frames</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-21 00:07:02" itemprop="dateCreated datePublished" datetime="2024-08-21T00:07:02+08:00">2024-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-22 18:26:19" itemprop="dateModified" datetime="2025-01-22T18:26:19+08:00">2025-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RISC-V-vs-x86"><a href="#RISC-V-vs-x86" class="headerlink" title="RISC-V vs x86"></a>RISC-V vs x86</h2><p>RISC-V：一种精简指令集（Reduced Instruction Set Computer）。</p>
<p>RISC-V区分了 Base Integer Instruction Set 和 Standard Extension Instruction Set。Base Integer Instruction Set 包含了所有的常用指令，比如add，mult。除此之外，处理器还可以选择性的支持 Standard Extension Instruction Set。每一个RISC-V处理器可以声明支持了哪些扩展指令集，然后编译器可以根据支持的指令集来编译代码。</p>
<p>x86：一种复杂指令集（Complex Instruction Set Computer）。</p>
<h2 id="RISC-V寄存器"><a href="#RISC-V寄存器" class="headerlink" title="RISC-V寄存器"></a>RISC-V寄存器</h2><p>下图展示了 RISC-V 的寄存器调用约定：</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/RISC-V%20calling%20convention%20register%20usage..jpg" alt="RVG calling convention"></p>
<p>表中第一列是寄存器名称，但是一般使用第二列的 ABI 名称，在编写汇编代码时也是使用ABI 名称。</p>
<p>在标准 RISC-V 调用约定中，堆栈向下增长，并且堆栈指针 sp 始终保持 16 字节对齐。</p>
<p>在寄存器中传递参数，最多 8 个整数寄存器 a0–a7 和最多 8 个浮点寄存器 fa0–fa7。如果一个函数有超过8个参数，就需要用内存了。</p>
<p>返回值保存在 a0 和 a1 以及浮点寄存器 fa0 和 fa1 。较大的返回值在内存中传递；调用者分配此内存区域并将指向它的指针作为第一个参数传递给被调用者。</p>
<p>RISC-V 采用小端法保存数据。寄存器都是 64 bits，各种各样的数据类型都会被改造的可以放进这64bit中。。比如说有一个32bit的整数，取决于整数是不是有符号的，会通过在前面补32个0或者1来使得这个整数变成64bit并存在这些寄存器中。</p>
<p>Caller Saved 调用者寄存器中的值有调用者保存，被调用者直接使用这些寄存器。</p>
<p>Callee Saved 被调用者寄存器的用法与 Caller Saved 相对应。被调用者若想使用 Callee Saved Reg ，则需要在使用前保存寄存器中的值，并在返回前恢复寄存器。</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>函数的 stack frame 是由编译器生成的机器代码在运行时构造的，调整堆栈指针（<code>sp</code>）以分配栈帧。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/stack%20frame.png" alt="stack frame"></p>
<p>对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。</p>
<p>一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。所以Stack Frame大小并不总是一样。</p>
<p>fp是frame pointer，用于指向当前帧底部（高地址），保存在寄存器s0中，同时每个函数栈帧中保存了调用当前函数的函数（父函数）的fp（保存在to prev frame那一栏中）</p>
<p>有关Stack Frame有两件事情是确定的：</p>
<ul>
<li>Return address总是会出现在Stack Frame的第一位</li>
<li>指向前一个Stack Frame的指针也会出现在栈中的固定位置</li>
</ul>
<p>返回地址位于堆栈帧指针的固定偏移量（-8）处，而保存的帧指针位于帧指针的固定偏移量（-16）处</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/6-S081-Lab3-Page-Tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/14/6-S081-Lab3-Page-Tables/" class="post-title-link" itemprop="url">6.S081-Lab3-Page Tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-14 20:42:54" itemprop="dateCreated datePublished" datetime="2024-08-14T20:42:54+08:00">2024-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-07 18:29:11" itemprop="dateModified" datetime="2025-01-07T18:29:11+08:00">2025-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>一些操作系统（如 Linux）通过在用户空间和内核之间共享只读区域中的数据来加快某些系统调用的速度。创建每个进程时，在 USYSCALL（memlayout.h 中定义的一个 VA）处映射一个只读页面。 在该页面的开头，存储一个 struct usyscall（也在 memlayout.h 中定义），并将其初始化以存储当前进程的 PID。 在本实验中，用户空间侧提供了 ugetpid()，它将自动使用 USYSCALL 映射。 </p>
<p>实现：</p>
<ul>
<li><p>从<code>memlayout.h</code>中了解到USYSCALL在用户地址空间中的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建每个进程时完成映射。在<code>kernel/proc.c</code>的<code>proc_pagetable()</code>中学习<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的映射方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map one read-only page at USYSCALL(a VA defined in memlayout.h) just below   TRAPFRAME</span></span><br><span class="line"><span class="comment">// to speed up system calls who needs get the the PID of the current process.</span></span><br><span class="line"><span class="comment">// At the start of this page, store a struct usyscall (also defined in memlayout.h),</span></span><br><span class="line"><span class="comment">// and initialize it to store the PID of the current process.</span></span><br><span class="line"><span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;usyscallpage), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意要设置<code>PTE_U</code>，确保用户态下可以访问该PTE。</p>
<p>参照<code>p-&gt;trapframe</code>，需要在<code>proc</code>结构体中定义<code>usyscallpage</code>用于存放<code>struct usyscall</code>的地址，实际上就是<code>USYSCALL</code>的物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usyscallpage</span>;</span> <span class="comment">// Shared with kernel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个进程时的工作。在<code>kernel/proc.c</code>的<code>allocproc()</code>中为<code>USYSCALL</code>分配一个物理页空间。同时将当前进程的<code>pid</code>存放到<code>USYSCALL</code>页中的<code>usyscall</code>结构体中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a USYSCALL page.</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;usyscallpage = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;usyscallpage-&gt;pid = p-&gt;pid;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁一个进程时的工作。在<code>kernel/proc.c</code>的<code>freeproc()</code>中释放<code>USYSCALL</code>页空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;usyscallpage)</span><br><span class="line">  kfree((<span class="type">void</span>*)p-&gt;usyscallpage);</span><br><span class="line">p-&gt;usyscallpage = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此刻完成之后，运行 qemu 会 <code>panic</code> 错误。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">panic: freewalk: leaf</span><br></pre></td></tr></table></figure>

<p><code>panic: freewalk: leaf</code> 错误通常表示系统在页表管理过程中遇到了页表结构的损坏或误操作。这是因为在 <code>pagetable</code> 中任然存在我们之前的 PTE 映射。我们需要在 <code>kernel/proc.c</code> 的 <code>proc_freepagetable()</code> 中对其取消映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>编写一个可以打印页表内容的函数，定义一个名为 vmprint() 的函数。 它应该接受一个 pagetable_t 参数，并按照下面描述的格式打印该页表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line"> ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line"> .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line"> .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line"> .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line"> .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line"> ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line"> .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line"> .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000</span><br><span class="line"> .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000</span><br><span class="line"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>

<p> 在<code> exec.c</code> 中<code>return argc</code> 之前插入 <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，以打印第一个进程的页表。 </p>
<p>实现：</p>
<ul>
<li><p>按照提示参考<code>freewalk()</code>的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// A read/write/execute permission of 0 means it points to the next level of the page table.</span></span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      <span class="comment">// This is an intermediate page table, recursively released.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">// At least one of the read/write/execute permissions is 1, indicating that it points to physical memory.</span></span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：如何遍历页表、如何区分第三级页表的PTE(更高级别PTE中FLAG中没有RWX权限)。</p>
</li>
<li><p>关于打印格式中要注意，不同级别中PTE前面的<code> ..</code>不一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, uint16 level)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= level; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);     </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, (uint64)pte, child);</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        level++;</span><br><span class="line">        _vmprint((<span class="type">pagetable_t</span>)child, level);</span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, (uint64)pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>freewalk()</code>需要释放页表，所以要有<code>pagetable[i] = 0</code>，<code>_vmprint</code>中不能出现，否则会清空页表中的页表项，导致程序无法继续运行。</p>
</li>
</ul>
<h2 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h2><p>实现<code> pgaccess()</code>系统调用，用于报告哪些页面已被访问。系统调用需要三个参数。首先，它需要第一个要检查的用户页面的起始虚拟地址。其次，它接受要检查的页面数。最后，它需要一个缓冲区的用户地址，以便将结果存储到位掩码（一种数据结构，每页使用一位，其中第一页对应的是最小有效位）中。</p>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 baseaddr;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  uint64 maskbits = <span class="number">0</span>;</span><br><span class="line">  uint64 maskaddr;</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;baseaddr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">2</span>, &amp;maskaddr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va = PGROUNDDOWN(baseaddr);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    pte = walk(pagetable, va, <span class="number">1</span>);</span><br><span class="line">    va += PGSIZE;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_A)&#123;</span><br><span class="line">      maskbits |= (<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">      *pte &amp;= ~PTE_A;  <span class="comment">// clear PTE_A after checking if it is set.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, maskaddr, (<span class="type">char</span>*)&amp;maskbits, <span class="keyword">sizeof</span>(maskbits)) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;sys_pgacess copyout error&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>PTE_A</code>需要在<code>riscv.h</code>中设置；<code>walk()</code>需要在<code>defs.h</code>中声明。</p>
</li>
<li><p>获取<code>pagetable</code>时，下面的写法执行会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint64 x;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, satp&quot;</span> : <span class="string">&quot;=r&quot;</span> (x))</span>; </span><br><span class="line"><span class="type">pagetable_t</span> pagetable = (<span class="type">pagetable_t</span>)(x &amp; ~((uint64)<span class="number">0xfff</span>)); <span class="comment">// 去掉低12位</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="bug-Unresolved"><a href="#bug-Unresolved" class="headerlink" title="bug(Unresolved )"></a>bug(Unresolved )</h2><p><code>make grade</code>时<code>usertest</code>测试有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">== Test   usertests: all tests ==</span><br><span class="line">  usertests: all tests: FAIL</span><br><span class="line">    ...</span><br><span class="line">         test createdelete: OK</span><br><span class="line">         test linkunlink: OK</span><br><span class="line">         test linktest: OK</span><br><span class="line">         test unlinkread: OK</span><br><span class="line">         test concreate: qemu-system-riscv64: terminating on signal 15 from pid 19225 (make)</span><br><span class="line">    MISSING &#x27;^ALL TESTS PASSED$&#x27;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/24/6-S081-Lecture-4-Page-tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/24/6-S081-Lecture-4-Page-tables/" class="post-title-link" itemprop="url">6.S081-Lecture 4 Page tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-24 22:55:27" itemprop="dateCreated datePublished" datetime="2024-07-24T22:55:27+08:00">2024-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-22 18:24:40" itemprop="dateModified" datetime="2025-01-22T18:24:40+08:00">2025-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>RISC-V 指令（包括用户和内核）操作的是虚拟地址。机器的 RAM，或者说物理内存，是用物理地址来做索引的。RISC-V的页表硬件通过将每个虚拟地址映射到（转换成）一个物理地址。</p>
<p> 由虚拟地址转换为物理地址是在处理器中的<strong>内存管理单元（Memory Management Unit, MMU）</strong>中完成的。将MMU视为一个“黑箱”，输入VP，输出PP。注意，<strong>页表保存在内存中</strong>，MMU只是会去查看页表。</p>
<p>xv6运行在Sv39 RISC-V上，这意味着只会使用64位虚拟地址的低39位，高25位没有被使用。可使用的低39位中的低12位为页内偏移地址<code>offset</code>，可以得知页大小为2^12B（4096B）；剩余的27位为页表的索引项<code>index</code>（或者称低12位为<strong>虚拟页偏移VPO</strong>，称剩余的27位为<strong>虚拟页号VPN</strong>）。</p>
<p>在这种Sv39配置中，一个RISC-V页表在逻辑上是一个由2^27（134,217,728）个<strong>页表项（Page Table Entry, PTE）</strong>组成的数组。每个PTE包含一个44位的<strong>物理页号（Physical Page Number, PPN）</strong>和一些标志位。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_pagework.jpg"></p>
<p>分页硬件通过利用39位中的高27位索引到页表中找到一个PTE来转换一个虚拟地址，并计算出一个56位的物理地址，它的前44位来自于PTE中的PPN，而它的后12位则是从原来的虚拟地址复制过来的。在逻辑上可以把页表看成是一个简单的PTE数组。</p>
<p>在Sv39 RISC-V中，虚拟地址的高25位不用于地址转换；将来RISC-V可能会使用这些位来定义更多的转换层。物理地址也有增长的空间：在PTE格式中，物理页号还有 10 位的增长空间。</p>
<p>VPN转换成PPN的实际过程分三步进行。一个页表以三层树的形式存储在物理内存中，多级页表。树的根部是一个 4096 字节的页表页，它包含 512 个 PTE，这些 PTE 包含树的下一级页表页的物理地址。每一页都包含 512 个 PTE，用于指向下一个页表或物理地址。分页硬件用 27 位中的高 9 位选择<strong>根页表页</strong>中的 PTE，用中间 9 位选择树中下一级页表页中的 PTE，用低 9 位选择最后的 PTE。根页表页的基地址存放在<code>satp</code>寄存器中。<code>satp</code>寄存器包含了还一些控制位，用于配置地址转换和保护机制。</p>
<p>页表页存放在单独的页中，每个页表页都包含 512 个 PTE，512*64bit&#x3D;4096B。</p>
<p>每个进程都有自己独立的页表，这个页表定义了进程的地址空间。所以当操作系统将CPU从一个进程切换到另一个进程时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应页表。写SATP寄存器是一条特权指令。在每个proc结构体，proc.h，里面有一个指向根页表的指针，这对应了SATP寄存器中的内容。</p>
<p>如果转换一个地址所需的三个 PTE 中的任何一个不存在，分页硬件就会引发一个<strong>缺页异常（page-fault exception）</strong>，让内核来处理这个异常。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_riscv_address_translation.jpg"></p>
<p>每个 PTE 都包含标志位，用于告诉分页硬件相关的虚拟地址被允许怎样使用。</p>
<ul>
<li><code>PTE_V</code> 表示 PTE 是否存在：如果Valid bit位为1，那么表明这是一条合法的PTE，可以用它来做地址翻译。如果没有设置（Valid bit位为0），对该页的引用会引起缺页异常。</li>
<li><code>PTE_R</code> 控制是否允许指令读取该页；<code>PTE_W</code> 控制是否允许指令向该页写入。</li>
<li><code>PTE_X</code> 控制 CPU 是否可以将页面的内容解释为指令并执行。</li>
<li><code>PTE_U</code> 控制是否允许用户态下的指令访问页面；如果不设置 <code>PTE_U</code>， 对应 PTE 只能在内核态下使用。</li>
</ul>
<p>标志位和与分页硬件相关的数据结构定义在（<code>kernel/riscv.h</code>）中。</p>
<p>每一级页表项可以有两种角色（前提是<code>PTE_V</code> 有效）：</p>
<ul>
<li><p><strong>指向物理页（叶节点）</strong>：如果设置了 R、W、X 中的任意一位，表示当前页表项是一个叶节点，映射到物理地址。</p>
</li>
<li><p><strong>指向下一级页表</strong>：如果 R&#x2F;W&#x2F;X 都为 0，表示当前页表项是一个中间节点，指向下一级页表。</p>
</li>
</ul>
<h2 id="页表缓存TLB"><a href="#页表缓存TLB" class="headerlink" title="页表缓存TLB"></a>页表缓存TLB</h2><p>如果回想一下虚拟地址转换成物理地址的过程，基本上都要做3次内存查找，第一次在最高级的page directory，第二次在中间级的page directory，最后一次在最低级的page directory。所以对于一个虚拟内存地址的寻址，需要读三次内存，代价有点高。</p>
<p>所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的转换结果有缓存。这个缓存被称为<strong>页表缓存（Translation Lookside Buffer, TLB）</strong>。TLB是对PTE的缓存，TLB会保存虚拟地址到物理地址的映射关系。这样访问虚拟地址时，处理器优先查看TLB，若TLB中存在对应的缓存会直接返回物理地址，而不需要通过页表得到结果。若TLB没有对应的缓存，再查看页表。这里用到cache的思想。</p>
<h2 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h2><p>Xv6 为每个进程维护一个用于描述进程的用户地址空间的页表，外加一个单独的描述内核地址空间的页表。</p>
<p>内核配置其地址空间的布局，使其能够通过可预测的虚拟地址访问物理内存和各种硬件资源。下图显示了这个设计是如何将内核虚拟地址映射到物理地址的。文件（<code>kernel/memlayout.h</code>）声明了 xv6 内核内存布局的常量。</p>
<p>图中左边是内核的虚拟地址空间，右边上半部分是物理内存（DRAM），右边下半部分是I&#x2F;O设备。图中的右半部分的结构完全由主板硬件设计者决定，如果得到的物理地址大于<code>0x80000000</code>会走向DRAM芯片，如果得到的物理地址低于<code>0x80000000</code>会流向不同的I&#x2F;O设备。在图中，I&#x2F;O设备是与DRAM统一编址的。</p>
<p>CPU只是主板的一小部分，DRAM芯片位于处理器之外。是主板设计者将处理器，DRAM和许多I&#x2F;O设备汇总在一起。对于一个操作系统来说，CPU只是一个部分，I&#x2F;O设备同样也很重要。所以当你在写一个操作系统时，你需要同时处理CPU和I&#x2F;O设备。下图左边是内核的虚拟地址空间，右边上半部分是物理内存或者说是DRAM。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_address_mapped.png"></p>
<p>回到上图的右侧，可以看到最下面是未被使用的地址。地址0x1000是boot ROM的物理地址，当主板上电时，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址<code>0x80000000</code>，操作系统需要确保那个地址有一些数据能够接着启动操作系统。</p>
<p>这里还有一些其他的I&#x2F;O设备：</p>
<ul>
<li>PLIC是中断控制器（Platform-Level Interrupt Controller）。</li>
<li>CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适 的处理函数。</li>
<li>UART0（Universal Asynchronous Receiver&#x2F;Transmitter）负责与Console和显示器交互。</li>
<li>VIRTIO disk，与磁盘进行交互。</li>
</ul>
<p>回到上图的左侧，这就是xv6的虚拟内存地址空间。当机器刚刚启动时，还没有可用的页，xv6操作系统会设置好内核使用的虚拟地址空间，也就是这张图左边的地址分布。虚拟内存从物理地址 <code>0x80000000</code> 开始， 到 <code>0x86400000</code>（xv6内存大小为128M），xv6 称之为 <code>PHYSTOP</code>。</p>
<p>因为想让xv6尽可能的简单易懂，内核对RAM和内存映射的设备寄存器使用“直接映射”，也就是将这些资源映射到和它们物理地址相同的虚拟地址上。例如，内核本身在虚拟地址空间和物理内存中的位置都是<code>KERNBASE=0x80000000</code>。直接映射简化了读&#x2F;写物理内存的内核代码。例如，当 <code>fork</code> 为子进程分配用户内存时，分配器返回该内存的物理地址；<code>fork</code> 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。</p>
<p>有几个内核虚拟地址不是直接映射：</p>
<ul>
<li><code>trampoline</code>页。它被映射在虚拟地址空间的顶端；用户页表也有这个映射。第 4 章讨论了 trampoline 页的作用，但我们在这里看到了页表的一个有趣的用例；一个物理页（存放 trampoline 代码）在内核的虚拟地址空间中被映射了两次：一次是在虚拟地址空间的顶部，一次是PHYSTOP下的Kernel text中直接映射，但是实际使用的时候用的是上面的部分，因为有Guard page会更加安全。可以两个虚拟地址映射到同一个物理地址。</li>
<li>内核栈页。<strong>每个进程都有自己的内核栈</strong>，内核栈被映射到高地址处，所以 xv6 可以在它后面留下一个未映射的保护页。<strong>Guard page（保护页）</strong>是操作系统用于检测和防止程序栈溢出的一种内存管理技术。它是一种特殊的内存页，Guard page对应的PTE的Valid 标志位没有设置，故意将其标记为不可访问，来捕获对该页的访问异常，从而实现栈溢出检测和处理。同时又不想浪费物理内存给Guard page，所以Guard page不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。</li>
</ul>
<p>内核将 trampoline 和 text（可执行程序的代码段）映射为有 <code>PTE_R</code> 和 <code>PTE_X</code> 权限的页。内核从这些页读取和执行指令。内核映射的其他页会有 <code>PTE_R</code> 和 <code>PTE_W</code> 权限，以便内核读写这些页面的内存。保护页的映射是无效的（不设置 <code>PTE_V</code>）。</p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p>为了保证强隔离性，每个程序都运行在自己的地址空间，并且这些地址空间彼此之间相互独立。所以现在我们的问题是如何在一个物理内存上，创建不同的地址空间，因为归根到底，我们使用的还是一堆存放了内存信息的DRAM芯片。</p>
<p>每个进程有一个页表，用于描述进程的用户地址空间，还有一个内核地址空间（所有进程共享这一个描述内核地址空间的页表）。为了让内核使用物理内存和硬件资源，内核需要按照一定的规则排布内核地址空间，以能够确定哪个虚拟地址对应自己需要的硬件资源地址。用户地址空间不需要也不能够知道这个规则，因为用户空间不允许直接访问这些硬件资源。</p>
<p>QEMU会模拟一个从0x80000000开始的RAM，一直到0x86400000。QEMU会将设备接口以控制寄存器的形式暴露给内核，这些控制寄存器在0x80000000以下。kernel对这些设备接口控制寄存器的访问是直接和这些设备而不是RAM进行交互的。</p>
<p>不同的进程页表将用户地址转化为物理内存的不同页，这样每个进程都有私有的用户内存。第二，每个进程都认为自己的内存具有从零开始的连续的虚拟地址，而进程的物理内存可以是不连续的。第三，内核会映射带有 <code>trampoline</code> 代码的页到用户地址空间顶端，因此有一个物理内存页在所有地址空间中都会出现。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/chapter3_useraddress_space.png"></p>
<p>图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。栈只有一页，图中显示的是由<code>exec</code> 创建的初始内容。位于栈顶部的字符串中包含了命令行中输入的参数和指向他们的指针数组。在下方是允许程序在 <code>main</code> 启动的值，就像函数 <code>main(argc, argv)</code> 是刚刚被调用一样。</p>
<h2 id="Code-creating-an-address-space"><a href="#Code-creating-an-address-space" class="headerlink" title="Code: creating an address space"></a>Code: creating an address space</h2><p>大部分用于操作地址空间和页表的 xv6 代码都在<code>vm.c</code>（<code>kernel/vm.c:1</code>）中。核心数据结构是 <code>pagetable_t</code>，它实际上是一个指向 RISC-V 根页表页的指针；<code>pagetable_t</code>可以是内核页表，也可以是进程的页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br></pre></td></tr></table></figure>

<p>在机器启动时，在启动序列的靠前部分，<code>main</code> 调用 <code>kvminit</code>（<code>kernel/vm.c:22</code>）来创建内核页表。这个调用发生在 xv6 在 RISC-V 启用分页之前，所以地址直接指向物理内存。<code>kvminit</code>中直接调用<code>kvmmake</code>：</p>
<ul>
<li>为内核创建一个新的页表，分配顶级页表（根页表）。</li>
<li>调用 <code>kvmmap</code> 将内核所需要的硬件资源映射到物理地址。这些资源包括内核的指令和数据，<code>KERNBASE</code> 到 <code>PHYSTOP</code>的物理内存，以及实际上是设备的内存范围。</li>
<li>随后调用 <code>proc_mapstacks</code>为每个进程分配一个内核栈，并将其映射到内核虚拟地址空间中。</li>
</ul>
<p><code>kvmmap</code>（<code>kernel/vm.c:118</code>）调用 <code>mappages</code>（<code>kernel/vm.c:149</code>），它将指定范围的虚拟地址映射到一段物理地址。本质上就是按格式创建页表项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table .</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="comment">// perm: Permission flags for page table entries (e.g., PTE_R, PTE_W, PTE_X).</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// Page table not allocated and allocation of page table page failed</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      <span class="comment">// The page table entry has been marked as valid (PTE_V), </span></span><br><span class="line">      <span class="comment">// indicating that the virtual address has been mapped</span></span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>walk</code>：给定一个虚拟地址和一个页表，返回最低层页表中的PTE的地址，模拟MMU的功能。如果 PTE 无效，那么所需的物理页还没有被分配；如果 <code>alloc</code> 参数被设置，<code>walk</code> 会分配一个新的页表页，并把它的物理地址放在 PTE 中。（<code>kernel/vm.c:88</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>proc_mapstacks</code> 为每个进程分配内核栈，并建立映射，确保每个栈的位置固定且相互隔离。通过引入保护页，进一步提高了内核的稳定性和安全性。<code>KSTACK</code> 宏计算了每个进程内核栈在虚拟地址空间中的位置，并保证了它们之间的分布合理且一致。</p>
<p>虚拟内存中的保护页不会实际映射到物理地址中。由下面的宏可知，连续的两个内核栈地址相差2个<code>PGSIZE</code>，一个内核栈实际只占一个页，剩余的一个页即为保护页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for each process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_mapstacks</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="type">char</span> *pa = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code> 调用 <code>kvminithart</code>（<code>kernel/vm.c:53</code>）来映射内核页表。它将根页表页的物理地址写入寄存器 <code>satp</code> 中。在这之后，CPU 将使用内核页表翻译地址。</p>
<p><code>main</code> 调用<code>procinit</code>（<code>kernel/proc.c:26</code>），为每个进程分配一个内核栈。就是将<code>KSTACK(p)</code> 赋给<code>proc-&gt;kstack</code>。</p>
<p>每个 RISC-V CPU 都会在 **Translation Look-aside Buffer(TLB)**中缓存页表项，当 xv6 改变页表时，必须告诉 CPU 使相应的缓存 TLB 项无效。RISC-V 有一条指令 <code>sfence.vma</code>，可以刷新当前 CPU 的 TLB。xv6 在<code>kvminithart</code>中，重新加载 <code>satp</code> 寄存器后， 执行 <code>sfence.vma</code>，也会在从内核空间返回用户空间前，切换到用户页表的trampoline 代码中执行 <code>sfence.vma</code>（<code>kernel/trampoline.S:79</code>）。</p>
<h2 id="kvminithart"><a href="#kvminithart" class="headerlink" title="kvminithart"></a>kvminithart</h2><p><code>kvminithart</code> 是一个用于初始化每个硬件线程（hart）分页机制的函数。它的主要任务是将硬件的页表寄存器切换到内核页表，并启用分页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  sfence_vma();	<span class="comment">// flush the TLB.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数首先设置了SATP寄存器，kernel_pagetable变量来自于kvminit第一行。所以这里实际上是内核告诉MMU来使用刚刚设置好的page table。在这条指令之前，还不存在可用的page table，所以也就不存在地址翻译。执行完这条指令之后，程序计数器（Program Counter）增加了4。而之后的下一条指令被执行时，程序计数器会被内存中的page table翻译。</p>
<p>所以这条指令的执行时刻是一个非常重要的时刻。因为整个地址翻译从这条指令之后开始生效，之后的每一个使用的内存地址都可能对应到与之不同的物理内存地址。因为在这条指令之前，我们使用的都是物理内存地址，这条指令之后page table开始生效，所有的内存地址都变成了另一个含义，也就是虚拟内存地址。</p>
<h2 id="Code-Physical-memory-allocator"><a href="#Code-Physical-memory-allocator" class="headerlink" title="Code: Physical memory allocator"></a>Code: Physical memory allocator</h2><p>xv6对kernel space和<code>PHYSTOP</code>之间的物理空间在运行时进行分配，分配以页(4096 bytes)为单位。分配和释放是通过对空闲页链表进行追踪完成的，分配空间就是将一个页从链表中移除，释放空间就是将一页增加到链表中</p>
<p>kernel的物理空间的分配函数在<code>kernel/kalloc.c</code>中，每个页在链表中的元素是<code>struct run</code>。这个空闲页的链表<code>freelist</code>由自旋锁保护，包装在<code>struct kmem</code>中。</p>
<ul>
<li><code>kinit()</code>：对自旋锁进行初始化，并将kernel结尾到PHYSTOP之间的所有空闲空间都添加到kmem链表中，这是通过调用<code>freerange(end, PHYSTOP)</code>实现的</li>
<li><code>freerange()</code>对这个范围内所有页都调用一次<code>kfree</code>来将这个范围内的页添加到<code>freelist</code>链表中</li>
<li><code>kfree()</code>接受参数pa，pa必须是物理页的起始地址。将该页空间用1填充，并加入空闲页链表<code>freelist</code>中</li>
<li><code>kalloc()</code>从<code>freelist</code>中分配出一个空闲物理页。</li>
</ul>
<h2 id="Code-sbrk"><a href="#Code-sbrk" class="headerlink" title="Code: sbrk"></a>Code: sbrk</h2><p><code>sbrk</code> 是 一 个 进 程 收 缩 或 增 长 内 存 的 系 统 调 用 。 该 系 统 调 用 由 函 数<code>growproc</code>（<code>kernel/proc.c:239</code>）实现，<code>growproc</code> 调用 <code>uvmalloc</code> 或 <code>uvmdealloc</code>，取决于 <code>n</code> 是正数还是负数。</p>
<ul>
<li><p><code>uvmalloc</code>（<code>kernel/vm.c:229</code>）通过 <code>kalloc</code> 分配物理内存，并使用 <code>mappages</code> 将 PTE 添加到用户页表中。 </p>
</li>
<li><p><code>uvmdealloc</code> 调用 <code>uvmunmap</code>（<code>kernel/vm.c:174</code>），它使用 <code>walk</code> 来查找 PTE 并使用 <code>kfree</code> 来释放它们所引用的物理内存。</p>
</li>
</ul>
<p>xv6 使用进程的页表不仅是为了告诉硬件如何映射用户虚拟地址，也是将其作为分配给该进程的物理地址的唯一记录。这就是为什么释放用户内存（<code>uvmunmap</code> 中）需要检查用户页表的原因。</p>
<h2 id="Code-exec"><a href="#Code-exec" class="headerlink" title="Code: exec"></a>Code: exec</h2><p><code>exec</code> 系统调用用来创建一个地址空间的用户部分。相关代码在<code>kernel/exec.c</code>中，它读取储存在文件系统上的文件用来初始化一个地址空间的用户部分。其内部使用了<code>vm. c</code>和<code>kalloc.c</code>中的多个函数实现对用户地址空间的布置。</p>
<ul>
<li>二进制可执行文件数据读取，并检查ELF头部格式。首先通过<code>namei()</code>读取文件的inode，再快速检查文件是否是ELF格式。</li>
<li>分配用户页表。<code>proc_pagetable()</code>中调用<code>uvmcreate()</code>创建一个空的用户页表，再调用<code>mappages()</code>将<code>trampoline</code>和<code>trapframe</code>载入页表。</li>
<li>根据 ELF 文件的 Program headers 加载代码和数据段到内存。首先调用<code>uvmalloc</code>分配物理内存和PTE，再调用<code>loadseg</code>将各个segment写入内存中。</li>
<li>分配两个页，其中一个作为用户栈，一个作为栈保护页。 将 <code>argv</code> 的内容和指针复制到用户栈中，设置栈指针。</li>
<li>更新进程的页表、大小、用户栈指针以及入口点，并且释放该进程旧的页表。</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/22/6-S081-Lab2-System-calls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/6-S081-Lab2-System-calls/" class="post-title-link" itemprop="url">6.S081-Lab2-System calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 20:13:02" itemprop="dateCreated datePublished" datetime="2024-07-22T20:13:02+08:00">2024-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-06 20:34:37" itemprop="dateModified" datetime="2025-01-06T20:34:37+08:00">2025-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>添加一项系统调用跟踪功能。 创建一个新的系统调用<code>trace</code>来控制跟踪哪个系统调用。<code>trace</code>应该接受一个参数，即一个整数 “掩码”，其位指定要跟踪的系统调用，可以同时追踪多个系统调用。  <code>trace</code>系统调用追踪调用进程及随后派生的任意子进程，但不应影响其他进程。</p>
<p>思路：</p>
<ul>
<li><p><strong>系统调用函数的添加流程：</strong></p>
<ul>
<li><p>声明封装函数，为新的系统调用提供一个简便的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>user/usys.pl</code>注册一个存根，定义<code>ecall</code>到内核态下<code>trace</code>系统调用的入口。脚本文件user&#x2F;usys.pl的作用是生成 <code>usys.S</code> 文件，其中包含每个系统调用（syscall）的汇编桩代码（stub）。这些桩代码是用户程序调用系统调用的入口点，它们封装了触发系统调用的汇编逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.h</span></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...	</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/syscall.h</code>，添加系统调用号（syscall call number）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/syscall.c</code>，添加系统调用外部声明，更新系统调用表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/sysproc.c</code>，实现系统调用<code>trace</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// control trace System Calls</span></span><br><span class="line"><span class="comment">// save the mask fo tracing system calls</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;   <span class="comment">// an integer &quot;mask&quot;, whose bits specify which system calls to trace</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)  <span class="comment">// get the a0 register on the kernel stack</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;syscallnum = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意系统调用<code>trace</code>的实现中只是将要追踪的系统调用（可多个）的mask传递给进程的变量<code>syscallnum</code>，打印内容在<code>syscall</code>中实现。</p>
</li>
</ul>
</li>
<li><p>在<code>kernel/proc.h</code>中结构体<code>proc</code>的定义中添加一个变量来存储要追踪的系统调用的mask。</p>
</li>
<li><p>在<code>kernel/proc.c</code>中的<code>fork()</code>中，添加功能保证<code>trace</code>能追踪子进程中的系统调用情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy system call trace&#x27;s argument</span></span><br><span class="line">  np-&gt;syscallnum = p-&gt;syscallnum;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>kernel/syscall.c</code>中的<code>syscall()</code>来打印<code>trace</code>的追踪情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> *syscallname[<span class="number">22</span>]=&#123;<span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;   <span class="comment">// system call number</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;syscallnum &amp; (<span class="number">1</span> &lt;&lt; num))&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallname[num<span class="number">-1</span>], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在判断当前的系统调用是否被追踪时，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;syscallnum == (<span class="number">1</span> &lt;&lt; num))&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这里判断是否相等只能追踪一个系统调用。再看<code>mask</code>的含义，二进制下<code>00001000</code>表示追踪系统调用3，二进制下<code>00011000</code>表示追踪系统调用3和系统调用4。</p>
</li>
<li><p><code>Timeout! trace children</code>超时怎么办？电脑性能问题，在<code>gradelib.py</code>中改变超时判断时间30s为更长时间即可。</p>
</li>
</ul>
<h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>添加一个系统调用<code>sysinfo</code>，它收集有关正在运行的系统的信息。系统调用采用一个参数：一个指向<code>struct sysinfo</code>的指针。内核应该填写这个结构的字段：<code>freemem</code>字段应该设置为空闲内存的字节数，<code>nproc</code>字段应该设置为<code>state</code>字段不为<code>UNUSED</code>的进程数。</p>
<p>思路：</p>
<ul>
<li><p>按照系统调用函数的添加流程，添加系统调用。</p>
</li>
<li><p>在<code>kernel/kalloc.c</code>实现计算空闲内存的字节数的函数。查看该文件，系统的内存是<strong>按页分配</strong>空闲的，只要计算出空闲页数即可。系统中有空闲页链表<code>kmem.freelist</code>来记录空闲页，遍历空闲页链表即可得空闲页数。注意在访问<code>kmem</code>时要保证互斥，加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the number of bytes of free memory</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kgetfreemem</span><span class="params">(uint64 *freemem)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 freepage = <span class="number">0</span>;   <span class="comment">// the num of free page</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">p</span>;</span>    <span class="comment">// working pointer, is used to traverse the freelist</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  p = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(p)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    freepage++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  *freemem = freepage * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/proc.c</code>中实现计算<code>state</code>字段不为<code>UNUSED</code>的进程数的功能。查看该文件，系统中有一个<code>proc</code>结构体数组用于管理进程，遍历该数组分别查看<code>proc-&gt;state</code>即可。函数书写风格源于该文件下其他函数的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collect the number of processes.</span></span><br><span class="line"><span class="comment">// Traverse the process table, looking for processes with a statu of not UNUSED.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">collectproc</span><span class="params">(uint64 *nproc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> freeprocnum = <span class="number">0</span>;  <span class="comment">// the number of free proc</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      freeprocnum++;</span><br><span class="line">    &#125;</span><br><span class="line">     release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *nproc = NPROC - freeprocnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kernel/sysproc.c</code>中实现系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 infopointer;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  kgetfreemem(&amp;info.freemem);</span><br><span class="line">  collectproc(&amp;info.nproc);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;infopointer) &lt; <span class="number">0</span>)  <span class="comment">// get the a0 register on the kernel stack</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                     <span class="comment">// a0 register sacves a pointer to a struct sysinfo</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, infopointer, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意要在<code>sysproc.c</code>中添加头文件<code>sysinfo.h</code>；在<code>defs.h</code>中添加<code>kgetfreemem()</code>和<code>collectproc()</code>的函数声明。</p>
</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/22/6-S081-xv6%E5%9C%A8qemu%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wnyxvo">
      <meta itemprop="description" content="战战兢兢，如履薄冰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wnyxvo的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/6-S081-xv6%E5%9C%A8qemu%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">6.S081-xv6在qemu中的启动过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 10:56:00" itemprop="dateCreated datePublished" datetime="2024-07-22T10:56:00+08:00">2024-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-09 11:09:00" itemprop="dateModified" datetime="2025-01-09T11:09:00+08:00">2025-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Make-qemu-推导"><a href="#Make-qemu-推导" class="headerlink" title="Make qemu 推导"></a>Make qemu 推导</h2><p>参看 Makefile 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu: $K/kernel fs.img</span><br><span class="line">    $(QEMU) $(QEMUOPTS)</span><br></pre></td></tr></table></figure>

<p>目标 <code>kernel</code> 和 <code>fs.img</code> 存在且最新，执行 <code>$(QEMU) $(QEMUOPTS)</code> ，即 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -bios none \</span><br><span class="line">    -kernel kernel/kernel \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -smp 3 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -global virtio-mmio.force-legacy=false \</span><br><span class="line">    -drive file=fs.img,if=none,format=raw,id=x0 \</span><br><span class="line">    -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>qemu-system-riscv64</code>：启动 QEMU 的命令，模拟一台 64 位 RISC-V 架构的计算机。</li>
<li><code>-machine virt</code>：指定要模拟的虚拟机硬件的机器类型为 virt。</li>
<li><code>-bios none</code>：不使用 BIOS，因为 RISC-V 架构通常不需要 BIOS。</li>
<li><code>-kernel kernel/kernel</code>：指定要加载的内核映像文件路径。</li>
<li><code>-m 128M</code>：指定虚拟机的内存大小为128MB。</li>
<li><code>-smp 3</code>：指定虚拟机的 CPU 核心数量为3个。</li>
<li><code>-nographic</code>：以无图形界面模式运行虚拟机，所有输出将会通过终端输出。</li>
<li><code>-global virtio-mmio.force-legacy=false</code>：设置 virtio-mmio 设备为非遗留模式。在虚拟化环境中，virtio 是一种用于虚拟机和宿主机之间通信的设备标准。virtio-mmio 是一种 virtio 设备的接口规范，用于在内存映射 I&#x2F;O（MMIO）方式下与虚拟机进行通信。通过在 QEMU 中启用非遗留模式的 virtio-mmio 设备，可以提高设备的性能和功能。</li>
<li><code>-drive file=fs.img,if=none,format=raw,id=x0</code>：添加一个虚拟硬盘设备，并指定硬盘镜像文件为 “fs.img”。</li>
<li><code>-device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</code>：添加一个 virtio 块设备，并将之前创建的虚拟硬盘设备连接到其中。</li>
</ul>
<h2 id="Qemu-启动"><a href="#Qemu-启动" class="headerlink" title="Qemu 启动"></a>Qemu 启动</h2><p>在 QEMU 模拟的 virt 硬件平台上，物理内存的起始物理地址通常为0x80000000（即2GB）。由于使用了 <code>-m 128M</code> 选项进行配置，虚拟机 128MB 大小的内存对应物理地址区间为 <code>[0x80000000,0x88000000)</code> 。如果使用上面给出的命令启动 QEMU ，那么在 QEMU 开始执行任何指令之前，会将内核镜像文件 <code>kernel/kernel</code>加载到物理内存 <code>0x80000000</code> 上，<code>0x80000000</code> 这个位置是 QEMU 本身设置的[<a target="_blank" rel="noopener" href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c">https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c</a>]。</p>
<p>将必要的文件载入到 QEMU 物理内存之后，QEMU CPU 的程序计数器 PC 会被初始化为 <code>0x1000</code> ，因此 QEMU 实际执行的第一条指令位于物理地址 <code>0x1000</code> ，接下来它将执行数条指令并跳转到物理地址 <code>0x80000000</code> 。</p>
<p>启动QEMU，并打开gdb，<code>CPUS=1</code>单核启动便于调试。本质上来说 QEMU 内部有一个 gdb server，当我们启动之后，QEMU 会等待 gdb 客户端连接。运行 <code>gdb-multiarch</code>再启动一个gdb客户端，会出现一个警告，按照提示处理即可。可见 PC 确实被初始化为 <code>0x1000</code>。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu1.PNG"></p>
<p>运行 <code>layout asm</code> 命令，查看汇编指令，就是这几条指令控制程序转到物理地址 <code>0x80000000</code> 。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu2.PNG"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x1000 auipc t0,0x0      ; t0 = PC + (0x0 &lt;&lt; 12) = 0x1000</span><br><span class="line">0x1004 addi  a2,t0,40    ; a2 = t0 + 40 = 0x1028</span><br><span class="line">0x1008 csrr  a0,mhartid  ; 将硬件寄存器 mhartid 的值（当前硬件线程 ID 为 0）存入寄存器 a0 中。</span><br><span class="line">0x100c ld    a1,32(t0)   ; a1 = (0x1000 + 32) = (0x1020) = 0x87000000</span><br><span class="line">0x1010 ld    t0,24(t0)   ; t0 = (0x1000 + 24) = (0x1018) = 0x80000000</span><br><span class="line">0x1014 jr    t0          ; PC = t0，跳转到寄存器 t0 中保存的地址</span><br><span class="line">0x1018 unimp             ; unimplemented operation，0x0000</span><br><span class="line">0x101a .2byte 0x8000     ; .2byte汇编伪指令,直接将值0x8000存储到目标内存0x101a中</span><br></pre></td></tr></table></figure>

<p>RISC-V 架构通常使用小端（Little Endian）字节序来存储数据。在小端字节序中，最低有效字节（Least Significant Byte，LSB）存储在地址的最低字节处，而最高有效字节（Most Significant Byte，MSB）存储在地址的最高字节处。</p>
<p><img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu3.png"></p>
<p>跳转到 t0 中保存的地址 0x80000000，进入内核的第一条指令，计算机的控制权已经被移交给内核。</p>
<p>地址0x80000000是一个被QEMU认可的地址。也就是说如果你想使用QEMU，那么第一个指令地址必须是它。所以，我们会让内核加载器从那个位置开始加载内核。查看kernel.ld：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * ensure that entry.S / _entry is at 0x80000000,</span></span><br><span class="line"><span class="comment">   * where qemu&#x27;s -kernel jumps.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  . = <span class="number">0x80000000</span>;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h2 id="内核的第一个进程"><a href="#内核的第一个进程" class="headerlink" title="内核的第一个进程"></a>内核的第一个进程</h2><p>xv6内核已被加载到物理地址<code>0x80000000</code>的内存中。在<strong>机器模式</strong>下，CPU从 <code>_entry</code>（kernel&#x2F;entry.S:6）开始执行xv6。RISC-V在禁用分页硬件的情况下启动：虚拟地址直接映射到物理地址。</p>
<p>之所以将内核放在<code>0x80000000</code>而不是<code>0x0</code>，是因为地址范围<code>0x0:0x80000000</code>包含 I&#x2F;O 设备。现代的体系结构大多使用 MMIO(Memory-mapped IO) 的形式，使用相同的地址总线来寻址内存和 I&#x2F;O 设备。当CPU访问某个地址的时候，可能是要访问某一部分物理内存，也可能是要访问I&#x2F;O设备上的内存。</p>
<img src="https://blog-image-1325547455.cos.ap-beijing.myqcloud.com/6.S081/xv6_qemu5.jpg"/>

<p>在程序的入口处设置一个端点这是QEMU会跳转到的第一个指令。设置完断点之后，运行程序，但并没有停在<code>0x80000000</code>（在<code>kernel.asm</code>中，0x80000000是程序的起始位置），而是停在了<code>0x8000000a</code>。</p>
<p><code>_entry</code> 阶段主要是为硬件线程分配栈并跳转到内核初始化的主要逻辑 <code>start</code>。同时注意到<code>entry.s</code>与编译后的<code>kernel.asm</code>中的代码不尽相同，因为编译器对伪指令进行了解析、对符号进行了替换、并对目标内存地址进行了调整。</p>
<p>在现代操作系统中，<strong>硬件线程栈</strong>、<strong>用户栈</strong>和<strong>内核栈</strong>各自有明确的职责和作用，但它们之间相互关联，共同支持进程的运行和上下文切换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">######################                entry.S:                ######################   </span><br><span class="line">        # qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each hart (i.e. CPU) to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la    sp, stack0     ; sp = &amp;stack0</span><br><span class="line">        li    a0, 1024*4     ; a0 = 4096</span><br><span class="line">        csrr  a1, mhartid    ; a1 = mhartid</span><br><span class="line">        addi  a1, a1, 1      ; a1++</span><br><span class="line">        mul   a0, a0, a1     ; a0 = a0 * a1 = 4096 * (hartid + 1)</span><br><span class="line">        add   sp, sp, a0     ; sp += a0 = &amp;stack0 + 4096 * (hartid + 1)</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure>

<p>xv6从entry.S开始启动，这个时候没有内存分页，没有隔离性，并且运行在M-mode（machine mode）。xv6会尽可能快的跳转到supervisor mode。<code>call start</code>后，执行<code>kernel/start.c/start()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configure Physical Memory Protection to give supervisor mode</span></span><br><span class="line">  <span class="comment">// access to all of physical memory.</span></span><br><span class="line">  w_pmpaddr0(<span class="number">0x3fffffffffffff</span>ull);</span><br><span class="line">  w_pmpcfg0(<span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要完成了以下任务：</p>
<ul>
<li><p>将上一个特权模式设置为监督模式，以便从机器模式返回时进入监督模式。</p>
</li>
<li><p>设置异常返回地址为<code>main</code>函数的地址。</p>
</li>
<li><p>使用<code>mret</code>指令切换到监督模式并跳转到<code>main</code>函数。</p>
</li>
</ul>
<p>kernel&#x2F;main.c中代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main()</code>主要进行各种初始化，通过<code>userinit</code>运行第一个用户进程。<code>userinit()</code> 函数负责创建并初始化第一个用户态进程，<code>p-&gt;state = RUNNABLE</code>方便调度器调度。接下来会执行通过 <code>exec()</code> 来加载用户态的 <code>/init</code> 程序，这个进程执行了一个<code>initcode.S</code>的汇编程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a user program that calls exec(&quot;/init&quot;)</span></span><br><span class="line"><span class="comment">// od -t xC initcode</span></span><br><span class="line">uchar initcode[] = &#123;</span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x13</span>, <span class="number">0x05</span>, <span class="number">0x45</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x97</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x93</span>, <span class="number">0x85</span>, <span class="number">0x35</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xef</span>, <span class="number">0xf0</span>, <span class="number">0x9f</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x69</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个汇编程序中，它首先将init中的地址加载到a0，argv中的地址加载到a1，<code>exec</code>对应的系统调用号加载到a7，最后调用<code>ECALL</code>。所以这里执行了3条指令，之后在第4条指令执行系统调用将控制权交给了操作系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>num = p-&gt;trapframe-&gt;a7</code> 会读取使用的系统调用对应的整数。<code>p-&gt;trapframe-&gt;a0 = syscall[num]()</code> 这是实际执行系统调用。这里可以看出，num用来索引一个数组，这个数组是一个函数指针数组，可以预期的是syscall[7]对应了exec的入口函数<code>sys_exec</code>，从 <code>exec()</code> 系统调用返回后，用户态开始运行 <code>/init</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># user/init.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *argv[] = &#123; <span class="string">&quot;sh&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">      <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">      wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">        <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init会为用户空间设置好一些东西，比如配置好console，调用<code>fork</code>，并在子进程中执行shell。至此整个系统启动了。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wnyxvo</p>
  <div class="site-description" itemprop="description">战战兢兢，如履薄冰</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wnyxvo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">95k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
